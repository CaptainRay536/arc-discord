(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};









var asyncToGenerator = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new Promise(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var runtime = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  !function (global) {
    "use strict";

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    var inModule = 'object' === "object";
    var runtime = global.regeneratorRuntime;
    if (runtime) {
      if (inModule) {
        // If regeneratorRuntime is defined globally and we're in a module,
        // make the exports object identical to regeneratorRuntime.
        module.exports = runtime;
      }
      // Don't bother evaluating the rest of this file if the runtime was
      // already defined globally.
      return;
    }

    // Define the runtime globally (as expected by generated code) as either
    // module.exports (if we're in a module) or a new, empty object.
    runtime = global.regeneratorRuntime = inModule ? module.exports : {};

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    runtime.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        prototype[method] = function (arg) {
          return this._invoke(method, arg);
        };
      });
    }

    runtime.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction ||
      // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    runtime.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    runtime.awrap = function (arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && hasOwn.call(value, "__await")) {
            return Promise.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return Promise.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration. If the Promise is rejected, however, the
            // result for this iteration will be rejected with the same
            // reason. Note that rejections of yielded Promises are not
            // thrown back into the generator function, as is the case
            // when an awaited Promise is rejected. This difference in
            // behavior between yield and await is important, because it
            // allows the consumer to decide what to do with the yielded
            // rejection (swallow it and continue, manually .throw it back
            // into the generator, abandon iteration, whatever). With
            // await, by contrast, there is no opportunity to examine the
            // rejection reason outside the generator function, so the
            // only option is to throw it from the await expression, and
            // let the generator function handle the exception.
            result.value = unwrapped;
            resolve(result);
          }, reject);
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new Promise(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
        // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    runtime.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    runtime.async = function (innerFn, outerFn, self, tryLocsList) {
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

      return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          if (delegate.iterator.return) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    Gp[toStringTagSymbol] = "Generator";

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    runtime.keys = function (object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    runtime.values = values;

    function doneResult() {
      return { value: undefined, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },

      stop: function stop() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined;
        }

        return ContinueSentinel;
      }
    };
  }(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  function () {
    return this;
  }() || Function("return this")());
});

function expect(val, message) {
    if (val === null || val === undefined) throw new Error(message);
    return val;
}
function unreachable() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "unreachable";

    return new Error(message);
}

// import Logger from './logger';
// let alreadyWarned = false;
function debugAssert(test, msg) {
    // if (!alreadyWarned) {
    //   alreadyWarned = true;
    //   Logger.warn("Don't leave debug assertions on in public builds");
    // }
    if (!test) {
        throw new Error(msg || "assertion failure");
    }
}

var objKeys = Object.keys;

function assign(obj) {
    for (var i = 1; i < arguments.length; i++) {
        var assignment = arguments[i];
        if (assignment === null || (typeof assignment === 'undefined' ? 'undefined' : _typeof(assignment)) !== 'object') continue;
        var keys = objKeys(assignment);
        for (var j = 0; j < keys.length; j++) {
            var key = keys[j];
            obj[key] = assignment[key];
        }
    }
    return obj;
}
function fillNulls(count) {
    var arr = new Array(count);
    for (var i = 0; i < count; i++) {
        arr[i] = null;
    }
    return arr;
}

var GUID = 0;
function initializeGuid(object) {
    return object._guid = ++GUID;
}
function ensureGuid(object) {
    return object._guid || initializeGuid(object);
}

function dict() {
    return Object.create(null);
}

var Stack = function () {
    function Stack() {
        classCallCheck(this, Stack);

        this.stack = [];
        this.current = null;
    }

    Stack.prototype.push = function push(item) {
        this.current = item;
        this.stack.push(item);
    };

    Stack.prototype.pop = function pop() {
        var item = this.stack.pop();
        var len = this.stack.length;
        this.current = len === 0 ? null : this.stack[len - 1];
        return item === undefined ? null : item;
    };

    Stack.prototype.isEmpty = function isEmpty() {
        return this.stack.length === 0;
    };

    createClass(Stack, [{
        key: 'size',
        get: function get$$1() {
            return this.stack.length;
        }
    }]);
    return Stack;
}();

var ListNode = function ListNode(value) {
    classCallCheck(this, ListNode);

    this.next = null;
    this.prev = null;
    this.value = value;
};
var LinkedList = function () {
    function LinkedList() {
        classCallCheck(this, LinkedList);

        this.clear();
    }

    LinkedList.prototype.head = function head() {
        return this._head;
    };

    LinkedList.prototype.tail = function tail() {
        return this._tail;
    };

    LinkedList.prototype.clear = function clear() {
        this._head = this._tail = null;
    };

    LinkedList.prototype.toArray = function toArray$$1() {
        var out = [];
        this.forEachNode(function (n) {
            return out.push(n);
        });
        return out;
    };

    LinkedList.prototype.nextNode = function nextNode(node) {
        return node.next;
    };

    LinkedList.prototype.forEachNode = function forEachNode(callback) {
        var node = this._head;
        while (node !== null) {
            callback(node);
            node = node.next;
        }
    };

    LinkedList.prototype.insertBefore = function insertBefore(node) {
        var reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (reference === null) return this.append(node);
        if (reference.prev) reference.prev.next = node;else this._head = node;
        node.prev = reference.prev;
        node.next = reference;
        reference.prev = node;
        return node;
    };

    LinkedList.prototype.append = function append(node) {
        var tail = this._tail;
        if (tail) {
            tail.next = node;
            node.prev = tail;
            node.next = null;
        } else {
            this._head = node;
        }
        return this._tail = node;
    };

    LinkedList.prototype.remove = function remove(node) {
        if (node.prev) node.prev.next = node.next;else this._head = node.next;
        if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
        return node;
    };

    return LinkedList;
}();
var ListSlice = function () {
    function ListSlice(head, tail) {
        classCallCheck(this, ListSlice);

        this._head = head;
        this._tail = tail;
    }

    ListSlice.prototype.forEachNode = function forEachNode(callback) {
        var node = this._head;
        while (node !== null) {
            callback(node);
            node = this.nextNode(node);
        }
    };

    ListSlice.prototype.head = function head() {
        return this._head;
    };

    ListSlice.prototype.tail = function tail() {
        return this._tail;
    };

    ListSlice.prototype.toArray = function toArray$$1() {
        var out = [];
        this.forEachNode(function (n) {
            return out.push(n);
        });
        return out;
    };

    ListSlice.prototype.nextNode = function nextNode(node) {
        if (node === this._tail) return null;
        return node.next;
    };

    return ListSlice;
}();
var EMPTY_SLICE = new ListSlice(null, null);

var EMPTY_ARRAY = Object.freeze([]);

var CONSTANT = 0;
var INITIAL = 1;
var VOLATILE = NaN;
var RevisionTag = function () {
    function RevisionTag() {
        classCallCheck(this, RevisionTag);
    }

    RevisionTag.prototype.validate = function validate(snapshot) {
        return this.value() === snapshot;
    };

    return RevisionTag;
}();
RevisionTag.id = 0;
var VALUE = [];
var VALIDATE = [];
var TagWrapper = function () {
    function TagWrapper(type, inner) {
        classCallCheck(this, TagWrapper);

        this.type = type;
        this.inner = inner;
    }

    TagWrapper.prototype.value = function value() {
        var func = VALUE[this.type];
        return func(this.inner);
    };

    TagWrapper.prototype.validate = function validate(snapshot) {
        var func = VALIDATE[this.type];
        return func(this.inner, snapshot);
    };

    return TagWrapper;
}();
function register(Type) {
    var type = VALUE.length;
    VALUE.push(function (tag) {
        return tag.value();
    });
    VALIDATE.push(function (tag, snapshot) {
        return tag.validate(snapshot);
    });
    Type.id = type;
}
///
// CONSTANT: 0
VALUE.push(function () {
    return CONSTANT;
});
VALIDATE.push(function (_tag, snapshot) {
    return snapshot === CONSTANT;
});
var CONSTANT_TAG = new TagWrapper(0, null);
// VOLATILE: 1
VALUE.push(function () {
    return VOLATILE;
});
VALIDATE.push(function (_tag, snapshot) {
    return snapshot === VOLATILE;
});
var VOLATILE_TAG = new TagWrapper(1, null);
// CURRENT: 2
VALUE.push(function () {
    return $REVISION;
});
VALIDATE.push(function (_tag, snapshot) {
    return snapshot === $REVISION;
});
var CURRENT_TAG = new TagWrapper(2, null);
function isConst(_ref) {
    var tag = _ref.tag;

    return tag === CONSTANT_TAG;
}
function isConstTag(tag) {
    return tag === CONSTANT_TAG;
}
///
var $REVISION = INITIAL;
var DirtyableTag = function (_RevisionTag) {
    inherits(DirtyableTag, _RevisionTag);

    DirtyableTag.create = function create() {
        var revision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $REVISION;

        return new TagWrapper(this.id, new DirtyableTag(revision));
    };

    function DirtyableTag() {
        var revision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $REVISION;
        classCallCheck(this, DirtyableTag);

        var _this = possibleConstructorReturn(this, _RevisionTag.call(this));

        _this.revision = revision;
        return _this;
    }

    DirtyableTag.prototype.value = function value() {
        return this.revision;
    };

    DirtyableTag.prototype.dirty = function dirty() {
        this.revision = ++$REVISION;
    };

    return DirtyableTag;
}(RevisionTag);
register(DirtyableTag);
function combineTagged(tagged) {
    var optimized = [];
    for (var i = 0, l = tagged.length; i < l; i++) {
        var tag = tagged[i].tag;
        if (tag === VOLATILE_TAG) return VOLATILE_TAG;
        if (tag === CONSTANT_TAG) continue;
        optimized.push(tag);
    }
    return _combine(optimized);
}
function combineSlice(slice) {
    var optimized = [];
    var node = slice.head();
    while (node !== null) {
        var tag = node.tag;
        if (tag === VOLATILE_TAG) return VOLATILE_TAG;
        if (tag !== CONSTANT_TAG) optimized.push(tag);
        node = slice.nextNode(node);
    }
    return _combine(optimized);
}
function combine(tags) {
    var optimized = [];
    for (var i = 0, l = tags.length; i < l; i++) {
        var tag = tags[i];
        if (tag === VOLATILE_TAG) return VOLATILE_TAG;
        if (tag === CONSTANT_TAG) continue;
        optimized.push(tag);
    }
    return _combine(optimized);
}
function _combine(tags) {
    switch (tags.length) {
        case 0:
            return CONSTANT_TAG;
        case 1:
            return tags[0];
        case 2:
            return TagsPair.create(tags[0], tags[1]);
        default:
            return TagsCombinator.create(tags);
    }
}
var CachedTag = function (_RevisionTag2) {
    inherits(CachedTag, _RevisionTag2);

    function CachedTag() {
        classCallCheck(this, CachedTag);

        var _this2 = possibleConstructorReturn(this, _RevisionTag2.apply(this, arguments));

        _this2.lastChecked = null;
        _this2.lastValue = null;
        return _this2;
    }

    CachedTag.prototype.value = function value() {
        var lastChecked = this.lastChecked,
            lastValue = this.lastValue;

        if (lastChecked !== $REVISION) {
            this.lastChecked = $REVISION;
            this.lastValue = lastValue = this.compute();
        }
        return this.lastValue;
    };

    CachedTag.prototype.invalidate = function invalidate() {
        this.lastChecked = null;
    };

    return CachedTag;
}(RevisionTag);

var TagsPair = function (_CachedTag) {
    inherits(TagsPair, _CachedTag);

    TagsPair.create = function create(first, second) {
        return new TagWrapper(this.id, new TagsPair(first, second));
    };

    function TagsPair(first, second) {
        classCallCheck(this, TagsPair);

        var _this3 = possibleConstructorReturn(this, _CachedTag.call(this));

        _this3.first = first;
        _this3.second = second;
        return _this3;
    }

    TagsPair.prototype.compute = function compute() {
        return Math.max(this.first.value(), this.second.value());
    };

    return TagsPair;
}(CachedTag);

register(TagsPair);

var TagsCombinator = function (_CachedTag2) {
    inherits(TagsCombinator, _CachedTag2);

    TagsCombinator.create = function create(tags) {
        return new TagWrapper(this.id, new TagsCombinator(tags));
    };

    function TagsCombinator(tags) {
        classCallCheck(this, TagsCombinator);

        var _this4 = possibleConstructorReturn(this, _CachedTag2.call(this));

        _this4.tags = tags;
        return _this4;
    }

    TagsCombinator.prototype.compute = function compute() {
        var tags = this.tags;

        var max = -1;
        for (var i = 0; i < tags.length; i++) {
            var value = tags[i].value();
            max = Math.max(value, max);
        }
        return max;
    };

    return TagsCombinator;
}(CachedTag);

register(TagsCombinator);
var UpdatableTag = function (_CachedTag3) {
    inherits(UpdatableTag, _CachedTag3);

    UpdatableTag.create = function create(tag) {
        return new TagWrapper(this.id, new UpdatableTag(tag));
    };

    function UpdatableTag(tag) {
        classCallCheck(this, UpdatableTag);

        var _this5 = possibleConstructorReturn(this, _CachedTag3.call(this));

        _this5.tag = tag;
        _this5.lastUpdated = INITIAL;
        return _this5;
    }

    UpdatableTag.prototype.compute = function compute() {
        return Math.max(this.lastUpdated, this.tag.value());
    };

    UpdatableTag.prototype.update = function update(tag) {
        if (tag !== this.tag) {
            this.tag = tag;
            this.lastUpdated = $REVISION;
            this.invalidate();
        }
    };

    return UpdatableTag;
}(CachedTag);
register(UpdatableTag);
var CachedReference = function () {
    function CachedReference() {
        classCallCheck(this, CachedReference);

        this.lastRevision = null;
        this.lastValue = null;
    }

    CachedReference.prototype.value = function value() {
        var tag = this.tag,
            lastRevision = this.lastRevision,
            lastValue = this.lastValue;

        if (lastRevision === null || !tag.validate(lastRevision)) {
            lastValue = this.lastValue = this.compute();
            this.lastRevision = tag.value();
        }
        return lastValue;
    };

    CachedReference.prototype.invalidate = function invalidate() {
        this.lastRevision = null;
    };

    return CachedReference;
}();

var MapperReference = function (_CachedReference) {
    inherits(MapperReference, _CachedReference);

    function MapperReference(reference, mapper) {
        classCallCheck(this, MapperReference);

        var _this6 = possibleConstructorReturn(this, _CachedReference.call(this));

        _this6.tag = reference.tag;
        _this6.reference = reference;
        _this6.mapper = mapper;
        return _this6;
    }

    MapperReference.prototype.compute = function compute() {
        var reference = this.reference,
            mapper = this.mapper;

        return mapper(reference.value());
    };

    return MapperReference;
}(CachedReference);


//////////
var ReferenceCache = function () {
    function ReferenceCache(reference) {
        classCallCheck(this, ReferenceCache);

        this.lastValue = null;
        this.lastRevision = null;
        this.initialized = false;
        this.tag = reference.tag;
        this.reference = reference;
    }

    ReferenceCache.prototype.peek = function peek() {
        if (!this.initialized) {
            return this.initialize();
        }
        return this.lastValue;
    };

    ReferenceCache.prototype.revalidate = function revalidate() {
        if (!this.initialized) {
            return this.initialize();
        }
        var reference = this.reference,
            lastRevision = this.lastRevision;

        var tag = reference.tag;
        if (tag.validate(lastRevision)) return NOT_MODIFIED;
        this.lastRevision = tag.value();
        var lastValue = this.lastValue;

        var value = reference.value();
        if (value === lastValue) return NOT_MODIFIED;
        this.lastValue = value;
        return value;
    };

    ReferenceCache.prototype.initialize = function initialize() {
        var reference = this.reference;

        var value = this.lastValue = reference.value();
        this.lastRevision = reference.tag.value();
        this.initialized = true;
        return value;
    };

    return ReferenceCache;
}();
var NOT_MODIFIED = "adb3b78e-3d22-4e4b-877a-6317c2c5c145";
function isModified(value) {
    return value !== NOT_MODIFIED;
}

var ConstReference = function () {
    function ConstReference(inner) {
        classCallCheck(this, ConstReference);

        this.inner = inner;
        this.tag = CONSTANT_TAG;
    }

    ConstReference.prototype.value = function value() {
        return this.inner;
    };

    return ConstReference;
}();

var ListItem = function (_ListNode) {
    inherits(ListItem, _ListNode);

    function ListItem(iterable, result) {
        classCallCheck(this, ListItem);

        var _this = possibleConstructorReturn(this, _ListNode.call(this, iterable.valueReferenceFor(result)));

        _this.retained = false;
        _this.seen = false;
        _this.key = result.key;
        _this.iterable = iterable;
        _this.memo = iterable.memoReferenceFor(result);
        return _this;
    }

    ListItem.prototype.update = function update(item) {
        this.retained = true;
        this.iterable.updateValueReference(this.value, item);
        this.iterable.updateMemoReference(this.memo, item);
    };

    ListItem.prototype.shouldRemove = function shouldRemove() {
        return !this.retained;
    };

    ListItem.prototype.reset = function reset() {
        this.retained = false;
        this.seen = false;
    };

    return ListItem;
}(ListNode);
var IterationArtifacts = function () {
    function IterationArtifacts(iterable) {
        classCallCheck(this, IterationArtifacts);

        this.iterator = null;
        this.map = dict();
        this.list = new LinkedList();
        this.tag = iterable.tag;
        this.iterable = iterable;
    }

    IterationArtifacts.prototype.isEmpty = function isEmpty() {
        var iterator = this.iterator = this.iterable.iterate();
        return iterator.isEmpty();
    };

    IterationArtifacts.prototype.iterate = function iterate() {
        var iterator = void 0;
        if (this.iterator === null) {
            iterator = this.iterable.iterate();
        } else {
            iterator = this.iterator;
        }
        this.iterator = null;
        return iterator;
    };

    IterationArtifacts.prototype.has = function has(key) {
        return !!this.map[key];
    };

    IterationArtifacts.prototype.get = function get$$1(key) {
        return this.map[key];
    };

    IterationArtifacts.prototype.wasSeen = function wasSeen(key) {
        var node = this.map[key];
        return node !== undefined && node.seen;
    };

    IterationArtifacts.prototype.append = function append(item) {
        var map = this.map,
            list = this.list,
            iterable = this.iterable;

        var node = map[item.key] = new ListItem(iterable, item);
        list.append(node);
        return node;
    };

    IterationArtifacts.prototype.insertBefore = function insertBefore(item, reference) {
        var map = this.map,
            list = this.list,
            iterable = this.iterable;

        var node = map[item.key] = new ListItem(iterable, item);
        node.retained = true;
        list.insertBefore(node, reference);
        return node;
    };

    IterationArtifacts.prototype.move = function move(item, reference) {
        var list = this.list;

        item.retained = true;
        list.remove(item);
        list.insertBefore(item, reference);
    };

    IterationArtifacts.prototype.remove = function remove(item) {
        var list = this.list;

        list.remove(item);
        delete this.map[item.key];
    };

    IterationArtifacts.prototype.nextNode = function nextNode(item) {
        return this.list.nextNode(item);
    };

    IterationArtifacts.prototype.head = function head() {
        return this.list.head();
    };

    return IterationArtifacts;
}();
var ReferenceIterator = function () {
    // if anyone needs to construct this object with something other than
    // an iterable, let @wycats know.
    function ReferenceIterator(iterable) {
        classCallCheck(this, ReferenceIterator);

        this.iterator = null;
        var artifacts = new IterationArtifacts(iterable);
        this.artifacts = artifacts;
    }

    ReferenceIterator.prototype.next = function next() {
        var artifacts = this.artifacts;

        var iterator = this.iterator = this.iterator || artifacts.iterate();
        var item = iterator.next();
        if (item === null) return null;
        return artifacts.append(item);
    };

    return ReferenceIterator;
}();
var Phase;
(function (Phase) {
    Phase[Phase["Append"] = 0] = "Append";
    Phase[Phase["Prune"] = 1] = "Prune";
    Phase[Phase["Done"] = 2] = "Done";
})(Phase || (Phase = {}));
var IteratorSynchronizer = function () {
    function IteratorSynchronizer(_ref) {
        var target = _ref.target,
            artifacts = _ref.artifacts;
        classCallCheck(this, IteratorSynchronizer);

        this.target = target;
        this.artifacts = artifacts;
        this.iterator = artifacts.iterate();
        this.current = artifacts.head();
    }

    IteratorSynchronizer.prototype.sync = function sync() {
        var phase = Phase.Append;
        while (true) {
            switch (phase) {
                case Phase.Append:
                    phase = this.nextAppend();
                    break;
                case Phase.Prune:
                    phase = this.nextPrune();
                    break;
                case Phase.Done:
                    this.nextDone();
                    return;
            }
        }
    };

    IteratorSynchronizer.prototype.advanceToKey = function advanceToKey(key) {
        var current = this.current,
            artifacts = this.artifacts;

        var seek = current;
        while (seek !== null && seek.key !== key) {
            seek.seen = true;
            seek = artifacts.nextNode(seek);
        }
        if (seek !== null) {
            this.current = artifacts.nextNode(seek);
        }
    };

    IteratorSynchronizer.prototype.nextAppend = function nextAppend() {
        var iterator = this.iterator,
            current = this.current,
            artifacts = this.artifacts;

        var item = iterator.next();
        if (item === null) {
            return this.startPrune();
        }
        var key = item.key;

        if (current !== null && current.key === key) {
            this.nextRetain(item);
        } else if (artifacts.has(key)) {
            this.nextMove(item);
        } else {
            this.nextInsert(item);
        }
        return Phase.Append;
    };

    IteratorSynchronizer.prototype.nextRetain = function nextRetain(item) {
        var artifacts = this.artifacts,
            current = this.current;

        current = current;
        current.update(item);
        this.current = artifacts.nextNode(current);
        this.target.retain(item.key, current.value, current.memo);
    };

    IteratorSynchronizer.prototype.nextMove = function nextMove(item) {
        var current = this.current,
            artifacts = this.artifacts,
            target = this.target;
        var key = item.key;

        var found = artifacts.get(item.key);
        found.update(item);
        if (artifacts.wasSeen(item.key)) {
            artifacts.move(found, current);
            target.move(found.key, found.value, found.memo, current ? current.key : null);
        } else {
            this.advanceToKey(key);
        }
    };

    IteratorSynchronizer.prototype.nextInsert = function nextInsert(item) {
        var artifacts = this.artifacts,
            target = this.target,
            current = this.current;

        var node = artifacts.insertBefore(item, current);
        target.insert(node.key, node.value, node.memo, current ? current.key : null);
    };

    IteratorSynchronizer.prototype.startPrune = function startPrune() {
        this.current = this.artifacts.head();
        return Phase.Prune;
    };

    IteratorSynchronizer.prototype.nextPrune = function nextPrune() {
        var artifacts = this.artifacts,
            target = this.target,
            current = this.current;

        if (current === null) {
            return Phase.Done;
        }
        var node = current;
        this.current = artifacts.nextNode(node);
        if (node.shouldRemove()) {
            artifacts.remove(node);
            target.delete(node.key);
        } else {
            node.reset();
        }
        return Phase.Prune;
    };

    IteratorSynchronizer.prototype.nextDone = function nextDone() {
        this.target.done();
    };

    return IteratorSynchronizer;
}();

function tracked() {
    for (var _len = arguments.length, dependencies = Array(_len), _key = 0; _key < _len; _key++) {
        dependencies[_key] = arguments[_key];
    }

    var target = dependencies[0],
        key = dependencies[1],
        descriptor = dependencies[2];

    if (typeof target === "string") {
        return function (target, key, descriptor) {
            return descriptorForTrackedComputedProperty(target, key, descriptor, dependencies);
        };
    } else {
        if (descriptor) {
            return descriptorForTrackedComputedProperty(target, key, descriptor, []);
        } else {
            installTrackedProperty(target, key);
        }
    }
}
function descriptorForTrackedComputedProperty(target, key, descriptor, dependencies) {
    var meta = metaFor(target);
    meta.trackedProperties[key] = true;
    meta.trackedPropertyDependencies[key] = dependencies || [];
    return {
        enumerable: true,
        configurable: false,
        get: descriptor.get,
        set: function set$$1() {
            metaFor(this).dirtyableTagFor(key).inner.dirty();
            descriptor.set.apply(this, arguments);
            propertyDidChange();
        }
    };
}
/**
  Installs a getter/setter for change tracking. The accessor
  acts just like a normal property, but it triggers the `propertyDidChange`
  hook when written to.

  Values are saved on the object using a "shadow key," or a symbol based on the
  tracked property name. Sets write the value to the shadow key, and gets read
  from it.
 */
function installTrackedProperty(target, key) {
    var value = void 0;
    var shadowKey = Symbol(key);
    var meta = metaFor(target);
    meta.trackedProperties[key] = true;
    if (target[key] !== undefined) {
        value = target[key];
    }
    Object.defineProperty(target, key, {
        configurable: true,
        get: function get$$1() {
            return this[shadowKey];
        },
        set: function set$$1(newValue) {
            metaFor(this).dirtyableTagFor(key).inner.dirty();
            this[shadowKey] = newValue;
            propertyDidChange();
        }
    });
}
/**
 * Stores bookkeeping information about tracked properties on the target object
 * and includes helper methods for manipulating and retrieving that data.
 *
 * Computed properties (i.e., tracked getters/setters) deserve some explanation.
 * A computed property is invalidated when either it is set, or one of its
 * dependencies is invalidated. Therefore, we store two tags for each computed
 * property:
 *
 * 1. The dirtyable tag that we invalidate when the setter is invoked.
 * 2. A union tag (tag combinator) of the dirtyable tag and all of the computed
 *    property's dependencies' tags, used by Glimmer to determine "does this
 *    computed property need to be recomputed?"
 */

var Meta = function () {
    function Meta(parent) {
        classCallCheck(this, Meta);

        this.tags = dict();
        this.computedPropertyTags = dict();
        this.trackedProperties = parent ? Object.create(parent.trackedProperties) : dict();
        this.trackedPropertyDependencies = parent ? Object.create(parent.trackedPropertyDependencies) : dict();
    }
    /**
     * The tag representing whether the given property should be recomputed. Used
     * by e.g. Glimmer VM to detect when a property should be re-rendered. Think
     * of this as the "public-facing" tag.
     *
     * For static tracked properties, this is a single DirtyableTag. For computed
     * properties, it is a combinator of the property's DirtyableTag as well as
     * all of its dependencies' tags.
     */


    Meta.prototype.tagFor = function tagFor(key) {
        var tag = this.tags[key];
        if (tag) {
            return tag;
        }
        var dependencies = void 0;
        if (dependencies = this.trackedPropertyDependencies[key]) {
            return this.tags[key] = combinatorForComputedProperties(this, key, dependencies);
        }
        return this.tags[key] = DirtyableTag.create();
    };
    /**
     * The tag used internally to invalidate when a tracked property is set. For
     * static properties, this is the same DirtyableTag returned from `tagFor`.
     * For computed properties, it is the DirtyableTag used as one of the tags in
     * the tag combinator of the CP and its dependencies.
    */


    Meta.prototype.dirtyableTagFor = function dirtyableTagFor(key) {
        var dependencies = this.trackedPropertyDependencies[key];
        var tag = void 0;
        if (dependencies) {
            // The key is for a computed property.
            tag = this.computedPropertyTags[key];
            if (tag) {
                return tag;
            }
            return this.computedPropertyTags[key] = DirtyableTag.create();
        } else {
            // The key is for a static property.
            tag = this.tags[key];
            if (tag) {
                return tag;
            }
            return this.tags[key] = DirtyableTag.create();
        }
    };

    return Meta;
}();

function combinatorForComputedProperties(meta, key, dependencies) {
    // Start off with the tag for the CP's own dirty state.
    var tags = [meta.dirtyableTagFor(key)];
    // Next, add in all of the tags for its dependencies.
    if (dependencies && dependencies.length) {
        for (var i = 0; i < dependencies.length; i++) {
            tags.push(meta.tagFor(dependencies[i]));
        }
    }
    // Return a combinator across the CP's tags and its dependencies' tags.
    return combine(tags);
}
var META = Symbol("ember-object");
function metaFor(obj) {
    var meta = obj[META];
    if (meta && hasOwnProperty(obj, META)) {
        return meta;
    }
    return obj[META] = new Meta(meta);
}
var hOP = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return hOP.call(obj, key);
}
var propertyDidChange = function propertyDidChange() {};
function setPropertyDidChange(cb) {
    propertyDidChange = cb;
}
function hasTag(obj, key) {
    var meta = obj[META];
    if (!obj[META]) {
        return false;
    }
    if (!meta.trackedProperties[key]) {
        return false;
    }
    return true;
}
var UntrackedPropertyError = function (_Error) {
    inherits(UntrackedPropertyError, _Error);

    function UntrackedPropertyError(target, key, message) {
        classCallCheck(this, UntrackedPropertyError);

        var _this = possibleConstructorReturn(this, _Error.call(this, message));

        _this.target = target;
        _this.key = key;
        return _this;
    }

    UntrackedPropertyError.for = function _for(obj, key) {
        return new UntrackedPropertyError(obj, key, "The property '" + key + "' on " + obj + " was changed after being rendered. If you want to change a property used in a template after the component has rendered, mark the property as a tracked property with the @tracked decorator.");
    };

    return UntrackedPropertyError;
}(Error);
function defaultErrorThrower(obj, key) {
    throw UntrackedPropertyError.for(obj, key);
}
function tagForProperty(obj, key) {
    var throwError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultErrorThrower;

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && obj) {
        if (false && !hasTag(obj, key)) {
            installDevModeErrorInterceptor(obj, key, throwError);
        }
        var meta = metaFor(obj);
        return meta.tagFor(key);
    } else {
        return CONSTANT_TAG;
    }
}
/**
 * In development mode only, we install an ad hoc setter on properties where a
 * tag is requested (i.e., it was used in a template) without being tracked. In
 * cases where the property is set, we raise an error.
 */
function installDevModeErrorInterceptor(obj, key, throwError) {
    var target = obj;
    var descriptor = void 0;
    // Find the descriptor for the current property. We may need to walk the
    // prototype chain to do so. If the property is undefined, we may never get a
    // descriptor here.
    var hasOwnDescriptor = true;
    while (target) {
        descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor) {
            break;
        }
        hasOwnDescriptor = false;
        target = Object.getPrototypeOf(target);
    }
    // If possible, define a property descriptor that passes through the current
    // value on reads but throws an exception on writes.
    if (descriptor) {
        if (descriptor.configurable || !hasOwnDescriptor) {
            Object.defineProperty(obj, key, {
                configurable: descriptor.configurable,
                enumerable: descriptor.enumerable,
                get: function get$$1() {
                    if (descriptor.get) {
                        return descriptor.get.call(this);
                    } else {
                        return descriptor.value;
                    }
                },
                set: function set$$1() {
                    throwError(this, key);
                }
            });
        }
    } else {
        Object.defineProperty(obj, key, {
            set: function set$$1() {
                throwError(this, key);
            }
        });
    }
}

/**
 * The `Component` class defines an encapsulated UI element that is rendered to
 * the DOM. A component is made up of a template and, optionally, this component
 * object.
 *
 * ## Defining a Component
 *
 * To define a component, subclass `Component` and add your own properties,
 * methods and lifecycle hooks:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 * }
 * ```
 *
 * ## Lifecycle Hooks
 *
 * Lifecycle hooks allow you to respond to changes to a component, such as when
 * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a
 * component, implement the hook as a method on your component subclass.
 *
 * For example, to be notified when Glimmer has rendered your component so you
 * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   didInsertElement() {
 *     $(this.element).pickadate();
 *   }
 * }
 * ```
 *
 * ## Data for Templates
 *
 * `Component`s have two different kinds of data, or state, that can be
 * displayed in templates:
 *
 * 1. Arguments
 * 2. Properties
 *
 * Arguments are data that is passed in to a component from its parent
 * component. For example, if I have a `UserGreeting` component, I can pass it
 * a name and greeting to use:
 *
 * ```hbs
 * <UserGreeting @name="Ricardo" @greeting="Olá" />
 * ```
 *
 * Inside my `UserGreeting` template, I can access the `@name` and `@greeting`
 * arguments that I've been given:
 *
 * ```hbs
 * {{@greeting}}, {{@name}}!
 * ```
 *
 * Arguments are also available inside my component:
 *
 * ```ts
 * console.log(this.args.greeting); // prints "Olá"
 * ```
 *
 * Properties, on the other hand, are internal to the component and declared in
 * the class. You can use properties to store data that you want to show in the
 * template, or pass to another component as an argument.
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   user = {
 *     name: 'Robbie'
 *   }
 * }
 * ```
 *
 * In the above example, we've defined a component with a `user` property that
 * contains an object with its own `name` property.
 *
 * We can render that property in our template:
 *
 * ```hbs
 * Hello, {{user.name}}!
 * ```
 *
 * We can also take that property and pass it as an argument to the
 * `UserGreeting` component we defined above:
 *
 * ```hbs
 * <UserGreeting @greeting="Hello" @name={{user.name}} />
 * ```
 *
 * ## Arguments vs. Properties
 *
 * Remember, arguments are data that was given to your component by its parent
 * component, and properties are data your component has defined for itself.
 *
 * You can tell the difference between arguments and properties in templates
 * because arguments always start with an `@` sign (think "A is for arguments"):
 *
 * ```hbs
 * {{@firstName}}
 * ```
 *
 * We know that `@firstName` came from the parent component, not the current
 * component, because it starts with `@` and is therefore an argument.
 *
 * On the other hand, if we see:
 *
 * ```hbs
 * {{name}}
 * ```
 *
 * We know that `name` is a property on the component. If we want to know where
 * the data is coming from, we can go look at our component class to find out.
 *
 * Inside the component itself, arguments always show up inside the component's
 * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,
 * inside the component `this.args.firstName` would also be `Tom`.
 */

var Component = function () {
  /**
   * Constructs a new component and assigns itself the passed properties. You
   * should not construct new components yourself. Instead, Glimmer will
   * instantiate new components automatically as it renders.
   *
   * @param options
   */
  function Component(options) {
    classCallCheck(this, Component);

    /**
     * Development-mode only name of the component, useful for debugging.
     */
    this.debugName = null;
    /** @private
     * Slot on the component to save Arguments object passed to the `args` setter.
     */
    this.__args__ = null;
    Object.assign(this, options);
  }
  /**
   * The element corresponding to the main element of the component's template.
   * The main element is the element in the template that has `...attributes` set on it:
   *
   * ```hbs
   * <h1>Modal</h1>
   * <div class="contents" ...attributes>
   *   {{yield}}
   * </div>
   * ```
   *
   * In this example, `this.element` would be the `div` with the class `contents`.
   *
   * You should not try to access this property until after the component's `didInsertElement()`
   * lifecycle hook is called.
   */


  Component.create = function create(injections) {
    return new this(injections);
  };
  /**
   * Called when the component has been inserted into the DOM.
   * Override this function to do any set up that requires an element in the document body.
   */


  Component.prototype.didInsertElement = function didInsertElement() {};
  /**
   * Called when the component has updated and rerendered itself.
   * Called only during a rerender, not during an initial render.
   */


  Component.prototype.didUpdate = function didUpdate() {};
  /**
   * Called before the component has been removed from the DOM.
   */


  Component.prototype.willDestroy = function willDestroy() {};

  Component.prototype.destroy = function destroy() {
    this.willDestroy();
  };

  Component.prototype.toString = function toString() {
    return this.debugName + " component";
  };

  createClass(Component, [{
    key: "element",
    get: function get$$1() {
      var bounds = this.bounds;

      debugAssert(bounds && bounds.firstNode === bounds.lastNode, "The 'element' property can only be accessed on components that contain a single root element in their template. Try using 'bounds' instead to access the first and last nodes.");
      return bounds.firstNode;
    }
    /**
     * Named arguments passed to the component from its parent component.
     * They can be accessed in JavaScript via `this.args.argumentName` and in the template via `@argumentName`.
     *
     * Say you have the following component, which will have two `args`, `firstName` and `lastName`:
     *
     * ```hbs
     * <my-component @firstName="Arthur" @lastName="Dent" />
     * ```
     *
     * If you needed to calculate `fullName` by combining both of them, you would do:
     *
     * ```ts
     * didInsertElement() {
     *   console.log(`Hi, my full name is ${this.args.firstName} ${this.args.lastName}`);
     * }
     * ```
     *
     * While in the template you could do:
     *
     * ```hbs
     * <p>Welcome, {{@firstName}} {{@lastName}}!</p>
     * ```
     *
     */

  }, {
    key: "args",
    get: function get$$1() {
      return this.__args__;
    },
    set: function set$$1(args) {
      this.__args__ = args;
      metaFor(this).dirtyableTagFor("args").inner.dirty();
    }
  }]);
  return Component;
}();

var CAPABILITIES = {
    dynamicLayout: false,
    dynamicTag: true,
    prepareArgs: false,
    createArgs: true,
    attributeHook: true,
    elementHook: true
};

var ComponentDefinition = function () {
    function ComponentDefinition(name, manager, ComponentClass, handle) {
        classCallCheck(this, ComponentDefinition);

        this.name = name;
        this.manager = manager;
        this.ComponentClass = ComponentClass;
        this.handle = handle;
        this.state = {
            name: name,
            capabilities: CAPABILITIES,
            ComponentClass: ComponentClass,
            handle: handle
        };
    }

    ComponentDefinition.prototype.toJSON = function toJSON() {
        return { GlimmerDebug: '<component-definition name="' + this.name + '">' };
    };

    return ComponentDefinition;
}();

var Container = function () {
    function Container(registry) {
        var resolver = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        classCallCheck(this, Container);

        this._registry = registry;
        this._resolver = resolver;
        this._lookups = {};
        this._factoryDefinitionLookups = {};
    }

    Container.prototype.factoryFor = function factoryFor(specifier) {
        var factoryDefinition = this._factoryDefinitionLookups[specifier];
        if (!factoryDefinition) {
            if (this._resolver) {
                factoryDefinition = this._resolver.retrieve(specifier);
            }
            if (!factoryDefinition) {
                factoryDefinition = this._registry.registration(specifier);
            }
            if (factoryDefinition) {
                this._factoryDefinitionLookups[specifier] = factoryDefinition;
            }
        }
        if (!factoryDefinition) {
            return;
        }
        return this.buildFactory(specifier, factoryDefinition);
    };

    Container.prototype.lookup = function lookup(specifier) {
        var singleton = this._registry.registeredOption(specifier, 'singleton') !== false;
        if (singleton && this._lookups[specifier]) {
            return this._lookups[specifier];
        }
        var factory = this.factoryFor(specifier);
        if (!factory) {
            return;
        }
        if (this._registry.registeredOption(specifier, 'instantiate') === false) {
            return factory.class;
        }
        var object = factory.create();
        if (singleton && object) {
            this._lookups[specifier] = object;
        }
        return object;
    };

    Container.prototype.defaultInjections = function defaultInjections(specifier) {
        return {};
    };

    Container.prototype.buildInjections = function buildInjections(specifier) {
        var hash = this.defaultInjections(specifier);
        var injections = this._registry.registeredInjections(specifier);
        var injection = void 0;
        for (var i = 0; i < injections.length; i++) {
            injection = injections[i];
            hash[injection.property] = this.lookup(injection.source);
        }
        return hash;
    };

    Container.prototype.buildFactory = function buildFactory(specifier, factoryDefinition) {
        var injections = this.buildInjections(specifier);
        return {
            class: factoryDefinition,
            create: function create(options) {
                var mergedOptions = Object.assign({}, injections, options);
                return factoryDefinition.create(mergedOptions);
            }
        };
    };

    return Container;
}();

var Registry = function () {
    function Registry(options) {
        classCallCheck(this, Registry);

        this._registrations = {};
        this._registeredOptions = {};
        this._registeredInjections = {};
        if (options && options.fallback) {
            this._fallback = options.fallback;
        }
    }

    Registry.prototype.register = function register(specifier, factoryDefinition, options) {
        this._registrations[specifier] = factoryDefinition;
        if (options) {
            this._registeredOptions[specifier] = options;
        }
    };

    Registry.prototype.registration = function registration(specifier) {
        var registration = this._registrations[specifier];
        if (registration === undefined && this._fallback) {
            registration = this._fallback.registration(specifier);
        }
        return registration;
    };

    Registry.prototype.unregister = function unregister(specifier) {
        delete this._registrations[specifier];
        delete this._registeredOptions[specifier];
        delete this._registeredInjections[specifier];
    };

    Registry.prototype.registerOption = function registerOption(specifier, option, value) {
        var options = this._registeredOptions[specifier];
        if (!options) {
            options = {};
            this._registeredOptions[specifier] = options;
        }
        options[option] = value;
    };

    Registry.prototype.registeredOption = function registeredOption(specifier, option) {
        var result = void 0;
        var options = this.registeredOptions(specifier);
        if (options) {
            result = options[option];
        }
        if (result === undefined && this._fallback !== undefined) {
            result = this._fallback.registeredOption(specifier, option);
        }
        return result;
    };

    Registry.prototype.registeredOptions = function registeredOptions(specifier) {
        var options = this._registeredOptions[specifier];
        if (options === undefined) {
            var _specifier$split = specifier.split(':'),
                type = _specifier$split[0];

            options = this._registeredOptions[type];
        }
        return options;
    };

    Registry.prototype.unregisterOption = function unregisterOption(specifier, option) {
        var options = this._registeredOptions[specifier];
        if (options) {
            delete options[option];
        }
    };

    Registry.prototype.registerInjection = function registerInjection(specifier, property, source) {
        var injections = this._registeredInjections[specifier];
        if (injections === undefined) {
            this._registeredInjections[specifier] = injections = [];
        }
        injections.push({
            property: property,
            source: source
        });
    };

    Registry.prototype.registeredInjections = function registeredInjections(specifier) {
        var _specifier$split2 = specifier.split(':'),
            type = _specifier$split2[0];

        var injections = this._fallback ? this._fallback.registeredInjections(specifier) : [];
        Array.prototype.push.apply(injections, this._registeredInjections[type]);
        Array.prototype.push.apply(injections, this._registeredInjections[specifier]);
        return injections;
    };

    return Registry;
}();

// TODO - use symbol
var OWNER = '__owner__';
function getOwner(object) {
    return object[OWNER];
}
function setOwner(object, owner) {
    object[OWNER] = owner;
}

/**
 * Contains the first and last DOM nodes in a component's rendered
 * template. These nodes can be used to traverse the section of DOM
 * that belongs to a particular component.
 *
 * Note that these nodes *can* change over the lifetime of a component
 * if the beginning or ending of the template is dynamic.
 */
var Bounds = function () {
    function Bounds(_bounds) {
        classCallCheck(this, Bounds);

        this._bounds = _bounds;
    }

    createClass(Bounds, [{
        key: "firstNode",
        get: function get$$1() {
            return this._bounds.firstNode();
        }
    }, {
        key: "lastNode",
        get: function get$$1() {
            return this._bounds.lastNode();
        }
    }]);
    return Bounds;
}();

var AppendOpcodes = function () {
    function AppendOpcodes() {
        classCallCheck(this, AppendOpcodes);

        this.evaluateOpcode = fillNulls(82 /* Size */).slice();
    }

    AppendOpcodes.prototype.add = function add(name, evaluate) {
        var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'syscall';

        this.evaluateOpcode[name] = { syscall: kind === 'syscall', evaluate: evaluate };
    };

    AppendOpcodes.prototype.debugBefore = function debugBefore(vm, opcode, type) {
        var sp = void 0;
        var state = void 0;
        return { sp: sp, state: state };
    };

    AppendOpcodes.prototype.debugAfter = function debugAfter(vm, opcode, type, pre) {
        var expectedChange = void 0;
        var sp = pre.sp,
            state = pre.state;

        var metadata = null;
        if (metadata !== null) {
            if (typeof metadata.stackChange === 'number') {
                expectedChange = metadata.stackChange;
            } else {
                expectedChange = metadata.stackChange({ opcode: opcode, constants: vm.constants, state: state });
                if (isNaN(expectedChange)) throw unreachable();
            }
        }
        var actualChange = vm.stack.sp - sp;
        if (metadata && metadata.check && typeof expectedChange === 'number' && expectedChange !== actualChange) {
            var _ref2 = [],
                name = _ref2[0],
                params = _ref2[1];

            throw new Error('Error in ' + name + ':\n\n' + (vm['pc'] + opcode.size) + '. ' + '\n\nStack changed by ' + actualChange + ', expected ' + expectedChange);
        }
        
    };

    AppendOpcodes.prototype.evaluate = function evaluate(vm, opcode, type) {
        var operation = this.evaluateOpcode[type];
        if (operation.syscall) {
            false && debugAssert(!opcode.isMachine, 'BUG: Mismatch between operation.syscall (' + operation.syscall + ') and opcode.isMachine (' + opcode.isMachine + ') for ' + opcode.type);

            operation.evaluate(vm, opcode);
        } else {
            false && debugAssert(opcode.isMachine, 'BUG: Mismatch between operation.syscall (' + operation.syscall + ') and opcode.isMachine (' + opcode.isMachine + ') for ' + opcode.type);

            operation.evaluate(vm.inner, opcode);
        }
    };

    return AppendOpcodes;
}();
var APPEND_OPCODES = new AppendOpcodes();
var AbstractOpcode = function AbstractOpcode() {
    classCallCheck(this, AbstractOpcode);

    initializeGuid(this);
};
var UpdatingOpcode = function (_AbstractOpcode) {
    inherits(UpdatingOpcode, _AbstractOpcode);

    function UpdatingOpcode() {
        classCallCheck(this, UpdatingOpcode);

        var _this = possibleConstructorReturn(this, _AbstractOpcode.apply(this, arguments));

        _this.next = null;
        _this.prev = null;
        return _this;
    }

    return UpdatingOpcode;
}(AbstractOpcode);

/**
 * Registers
 *
 * For the most part, these follows MIPS naming conventions, however the
 * register numbers are different.
 */
var Register;
(function (Register) {
    // $0 or $pc (program counter): pointer into `program` for the next insturction; -1 means exit
    Register[Register["pc"] = 0] = "pc";
    // $1 or $ra (return address): pointer into `program` for the return
    Register[Register["ra"] = 1] = "ra";
    // $2 or $fp (frame pointer): pointer into the `evalStack` for the base of the stack
    Register[Register["fp"] = 2] = "fp";
    // $3 or $sp (stack pointer): pointer into the `evalStack` for the top of the stack
    Register[Register["sp"] = 3] = "sp";
    // $4-$5 or $s0-$s1 (saved): callee saved general-purpose registers
    Register[Register["s0"] = 4] = "s0";
    Register[Register["s1"] = 5] = "s1";
    // $6-$7 or $t0-$t1 (temporaries): caller saved general-purpose registers
    Register[Register["t0"] = 6] = "t0";
    Register[Register["t1"] = 7] = "t1";
    // $8 or $v0 (return value)
    Register[Register["v0"] = 8] = "v0";
})(Register || (Register = {}));

var PrimitiveReference = function (_ConstReference) {
    inherits(PrimitiveReference, _ConstReference);

    function PrimitiveReference(value) {
        classCallCheck(this, PrimitiveReference);
        return possibleConstructorReturn(this, _ConstReference.call(this, value));
    }

    PrimitiveReference.create = function create(value) {
        if (value === undefined) {
            return UNDEFINED_REFERENCE;
        } else if (value === null) {
            return NULL_REFERENCE;
        } else if (value === true) {
            return TRUE_REFERENCE;
        } else if (value === false) {
            return FALSE_REFERENCE;
        } else if (typeof value === 'number') {
            return new ValueReference(value);
        } else {
            return new StringReference(value);
        }
    };

    PrimitiveReference.prototype.get = function get$$1(_key) {
        return UNDEFINED_REFERENCE;
    };

    return PrimitiveReference;
}(ConstReference);

var StringReference = function (_PrimitiveReference) {
    inherits(StringReference, _PrimitiveReference);

    function StringReference() {
        classCallCheck(this, StringReference);

        var _this2 = possibleConstructorReturn(this, _PrimitiveReference.apply(this, arguments));

        _this2.lengthReference = null;
        return _this2;
    }

    StringReference.prototype.get = function get$$1(key) {
        if (key === 'length') {
            var lengthReference = this.lengthReference;

            if (lengthReference === null) {
                lengthReference = this.lengthReference = new ValueReference(this.inner.length);
            }
            return lengthReference;
        } else {
            return _PrimitiveReference.prototype.get.call(this, key);
        }
    };

    return StringReference;
}(PrimitiveReference);

var ValueReference = function (_PrimitiveReference2) {
    inherits(ValueReference, _PrimitiveReference2);

    function ValueReference(value) {
        classCallCheck(this, ValueReference);
        return possibleConstructorReturn(this, _PrimitiveReference2.call(this, value));
    }

    return ValueReference;
}(PrimitiveReference);

var UNDEFINED_REFERENCE = new ValueReference(undefined);
var NULL_REFERENCE = new ValueReference(null);
var TRUE_REFERENCE = new ValueReference(true);
var FALSE_REFERENCE = new ValueReference(false);
var ConditionalReference$1 = function () {
    function ConditionalReference(inner) {
        classCallCheck(this, ConditionalReference);

        this.inner = inner;
        this.tag = inner.tag;
    }

    ConditionalReference.prototype.value = function value() {
        return this.toBool(this.inner.value());
    };

    ConditionalReference.prototype.toBool = function toBool(value) {
        return !!value;
    };

    return ConditionalReference;
}();

var ConcatReference = function (_CachedReference) {
    inherits(ConcatReference, _CachedReference);

    function ConcatReference(parts) {
        classCallCheck(this, ConcatReference);

        var _this = possibleConstructorReturn(this, _CachedReference.call(this));

        _this.parts = parts;
        _this.tag = combineTagged(parts);
        return _this;
    }

    ConcatReference.prototype.compute = function compute() {
        var parts = new Array();
        for (var i = 0; i < this.parts.length; i++) {
            var value = this.parts[i].value();
            if (value !== null && value !== undefined) {
                parts[i] = castToString(value);
            }
        }
        if (parts.length > 0) {
            return parts.join('');
        }
        return null;
    };

    return ConcatReference;
}(CachedReference);
function castToString(value) {
    if (typeof value.toString !== 'function') {
        return '';
    }
    return String(value);
}

function stackAssert(name, top) {
    return "Expected top of stack to be " + name + ", was " + String(top);
}

APPEND_OPCODES.add(1 /* Helper */, function (vm, _ref) {
    var handle = _ref.op1;

    var stack = vm.stack;
    var helper = vm.constants.resolveHandle(handle);
    var args = stack.pop();
    var value = helper(vm, args);
    vm.loadValue(Register.v0, value);
});
APPEND_OPCODES.add(4 /* GetVariable */, function (vm, _ref2) {
    var symbol = _ref2.op1;

    var expr = vm.referenceForSymbol(symbol);
    vm.stack.push(expr);
});
APPEND_OPCODES.add(2 /* SetVariable */, function (vm, _ref3) {
    var symbol = _ref3.op1;

    var expr = vm.stack.pop();
    vm.scope().bindSymbol(symbol, expr);
});
APPEND_OPCODES.add(3 /* SetBlock */, function (vm, _ref4) {
    var symbol = _ref4.op1;

    var handle = vm.stack.pop();
    var scope = vm.stack.pop(); // FIXME(mmun): shouldn't need to cast this
    var table = vm.stack.pop();
    var block = table ? [handle, scope, table] : null;
    vm.scope().bindBlock(symbol, block);
});
APPEND_OPCODES.add(80 /* ResolveMaybeLocal */, function (vm, _ref5) {
    var _name = _ref5.op1;

    var name = vm.constants.getString(_name);
    var locals = vm.scope().getPartialMap();
    var ref = locals[name];
    if (ref === undefined) {
        ref = vm.getSelf().get(name);
    }
    vm.stack.push(ref);
});
APPEND_OPCODES.add(17 /* RootScope */, function (vm, _ref6) {
    var symbols = _ref6.op1,
        bindCallerScope = _ref6.op2;

    vm.pushRootScope(symbols, !!bindCallerScope);
});
APPEND_OPCODES.add(5 /* GetProperty */, function (vm, _ref7) {
    var _key = _ref7.op1;

    var key = vm.constants.getString(_key);
    var expr = vm.stack.pop();
    vm.stack.push(expr.get(key));
});
APPEND_OPCODES.add(6 /* GetBlock */, function (vm, _ref8) {
    var _block = _ref8.op1;
    var stack = vm.stack;

    var block = vm.scope().getBlock(_block);
    if (block) {
        stack.push(block[2]);
        stack.push(block[1]);
        stack.push(block[0]);
    } else {
        stack.push(null);
        stack.push(null);
        stack.push(null);
    }
});
APPEND_OPCODES.add(7 /* HasBlock */, function (vm, _ref9) {
    var _block = _ref9.op1;

    var hasBlock = !!vm.scope().getBlock(_block);
    vm.stack.push(hasBlock ? TRUE_REFERENCE : FALSE_REFERENCE);
});
APPEND_OPCODES.add(8 /* HasBlockParams */, function (vm) {
    // FIXME(mmun): should only need to push the symbol table
    var block = vm.stack.pop();
    var scope = vm.stack.pop();

    var table = vm.stack.pop();
    false && debugAssert(table === null || table && (typeof table === 'undefined' ? 'undefined' : _typeof(table)) === 'object' && Array.isArray(table.parameters), stackAssert('Option<BlockSymbolTable>', table));

    var hasBlockParams = table && table.parameters.length;
    vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);
});
APPEND_OPCODES.add(9 /* Concat */, function (vm, _ref10) {
    var count = _ref10.op1;

    var out = new Array(count);
    for (var i = count; i > 0; i--) {
        var offset = i - 1;
        out[offset] = vm.stack.pop();
    }
    vm.stack.push(new ConcatReference(out));
});

var Opcodes;
(function (Opcodes) {
    // Statements
    Opcodes[Opcodes["Text"] = 0] = "Text";
    Opcodes[Opcodes["Append"] = 1] = "Append";
    Opcodes[Opcodes["Comment"] = 2] = "Comment";
    Opcodes[Opcodes["Modifier"] = 3] = "Modifier";
    Opcodes[Opcodes["Block"] = 4] = "Block";
    Opcodes[Opcodes["Component"] = 5] = "Component";
    Opcodes[Opcodes["OpenElement"] = 6] = "OpenElement";
    Opcodes[Opcodes["OpenSplattedElement"] = 7] = "OpenSplattedElement";
    Opcodes[Opcodes["FlushElement"] = 8] = "FlushElement";
    Opcodes[Opcodes["CloseElement"] = 9] = "CloseElement";
    Opcodes[Opcodes["StaticAttr"] = 10] = "StaticAttr";
    Opcodes[Opcodes["DynamicAttr"] = 11] = "DynamicAttr";
    Opcodes[Opcodes["AttrSplat"] = 12] = "AttrSplat";
    Opcodes[Opcodes["Yield"] = 13] = "Yield";
    Opcodes[Opcodes["Partial"] = 14] = "Partial";
    Opcodes[Opcodes["DynamicArg"] = 15] = "DynamicArg";
    Opcodes[Opcodes["StaticArg"] = 16] = "StaticArg";
    Opcodes[Opcodes["TrustingAttr"] = 17] = "TrustingAttr";
    Opcodes[Opcodes["Debugger"] = 18] = "Debugger";
    Opcodes[Opcodes["ClientSideStatement"] = 19] = "ClientSideStatement";
    // Expressions
    Opcodes[Opcodes["Unknown"] = 20] = "Unknown";
    Opcodes[Opcodes["Get"] = 21] = "Get";
    Opcodes[Opcodes["MaybeLocal"] = 22] = "MaybeLocal";
    Opcodes[Opcodes["HasBlock"] = 23] = "HasBlock";
    Opcodes[Opcodes["HasBlockParams"] = 24] = "HasBlockParams";
    Opcodes[Opcodes["Undefined"] = 25] = "Undefined";
    Opcodes[Opcodes["Helper"] = 26] = "Helper";
    Opcodes[Opcodes["Concat"] = 27] = "Concat";
    Opcodes[Opcodes["ClientSideExpression"] = 28] = "ClientSideExpression";
})(Opcodes || (Opcodes = {}));

function is(variant) {
    return function (value) {
        return Array.isArray(value) && value[0] === variant;
    };
}
// Statements




// Expressions
var isGet = is(Opcodes.Get);
var isMaybeLocal = is(Opcodes.MaybeLocal);

var Ops$1;
(function (Ops) {
    Ops[Ops["OpenComponentElement"] = 0] = "OpenComponentElement";
    Ops[Ops["DidCreateElement"] = 1] = "DidCreateElement";
    Ops[Ops["SetComponentAttrs"] = 2] = "SetComponentAttrs";
    Ops[Ops["DidRenderLayout"] = 3] = "DidRenderLayout";
    Ops[Ops["Debugger"] = 4] = "Debugger";
})(Ops$1 || (Ops$1 = {}));

var Ops$$1 = Opcodes;
var ATTRS_BLOCK = '&attrs';
var Compilers = function () {
    function Compilers() {
        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        classCallCheck(this, Compilers);

        this.offset = offset;
        this.names = dict();
        this.funcs = [];
    }

    Compilers.prototype.add = function add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    };

    Compilers.prototype.compile = function compile(sexp, builder) {
        var name = sexp[this.offset];
        var index = this.names[name];
        var func = this.funcs[index];
        false && debugAssert(!!func, 'expected an implementation for ' + (this.offset === 0 ? Ops$$1[sexp[0]] : Ops$1[sexp[1]]));

        func(sexp, builder);
    };

    return Compilers;
}();
var _statementCompiler = void 0;
function statementCompiler() {
    if (_statementCompiler) {
        return _statementCompiler;
    }
    var STATEMENTS = _statementCompiler = new Compilers();
    STATEMENTS.add(Ops$$1.Text, function (sexp, builder) {
        builder.text(sexp[1]);
    });
    STATEMENTS.add(Ops$$1.Comment, function (sexp, builder) {
        builder.comment(sexp[1]);
    });
    STATEMENTS.add(Ops$$1.CloseElement, function (_sexp, builder) {
        builder.closeElement();
    });
    STATEMENTS.add(Ops$$1.FlushElement, function (_sexp, builder) {
        builder.flushElement();
    });
    STATEMENTS.add(Ops$$1.Modifier, function (sexp, builder) {
        var resolver = builder.resolver,
            referrer = builder.referrer;
        var name = sexp[1],
            params = sexp[2],
            hash = sexp[3];

        var handle = resolver.lookupModifier(name, referrer);
        if (handle) {
            builder.modifier(handle, params, hash);
        } else {
            throw new Error('Compile Error ' + name + ' is not a modifier: Helpers may not be used in the element form.');
        }
    });
    STATEMENTS.add(Ops$$1.StaticAttr, function (sexp, builder) {
        var name = sexp[1],
            value = sexp[2],
            namespace = sexp[3];

        builder.staticAttr(name, namespace, value);
    });
    STATEMENTS.add(Ops$$1.DynamicAttr, function (sexp, builder) {
        dynamicAttr(sexp, false, builder);
    });
    STATEMENTS.add(Ops$$1.TrustingAttr, function (sexp, builder) {
        dynamicAttr(sexp, true, builder);
    });
    STATEMENTS.add(Ops$$1.OpenElement, function (sexp, builder) {
        builder.openPrimitiveElement(sexp[1]);
    });
    STATEMENTS.add(Ops$$1.OpenSplattedElement, function (sexp, builder) {
        builder.setComponentAttrs(true);
        builder.putComponentOperations();
        builder.openPrimitiveElement(sexp[1]);
    });
    STATEMENTS.add(Ops$$1.Component, function (sexp, builder) {
        var tag = sexp[1],
            _attrs = sexp[2],
            args = sexp[3],
            block = sexp[4];
        var resolver = builder.resolver,
            referrer = builder.referrer;

        var handle = resolver.lookupComponentDefinition(tag, referrer);
        if (handle !== null) {
            var capabilities = resolver.getCapabilities(handle);
            var attrs = [[Ops$$1.ClientSideStatement, Ops$1.SetComponentAttrs, true]].concat(_attrs, [[Ops$$1.ClientSideStatement, Ops$1.SetComponentAttrs, false]]);
            var attrsBlock = builder.inlineBlock({ statements: attrs, parameters: EMPTY_ARRAY });
            var child = builder.template(block);
            if (capabilities.dynamicLayout === false) {
                var layout = resolver.getLayout(handle);
                builder.pushComponentDefinition(handle);
                builder.invokeStaticComponent(capabilities, layout, attrsBlock, null, args, false, child && child);
            } else {
                builder.pushComponentDefinition(handle);
                builder.invokeComponent(attrsBlock, null, args, false, child && child);
            }
        } else {
            throw new Error('Compile Error: Cannot find component ' + tag);
        }
    });
    STATEMENTS.add(Ops$$1.Partial, function (sexp, builder) {
        var name = sexp[1],
            evalInfo = sexp[2];
        var referrer = builder.referrer;

        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        builder.expr(name);
        builder.dup();
        builder.enter(2);
        builder.jumpUnless('ELSE');
        builder.invokePartial(referrer, builder.evalSymbols(), evalInfo);
        builder.popScope();
        builder.popFrame();
        builder.label('ELSE');
        builder.exit();
        builder.return();
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    STATEMENTS.add(Ops$$1.Yield, function (sexp, builder) {
        var to = sexp[1],
            params = sexp[2];

        builder.yield(to, params);
    });
    STATEMENTS.add(Ops$$1.AttrSplat, function (sexp, builder) {
        var to = sexp[1];

        builder.yield(to, []);
        builder.didCreateElement(Register.s0);
        builder.setComponentAttrs(false);
    });
    STATEMENTS.add(Ops$$1.Debugger, function (sexp, builder) {
        var evalInfo = sexp[1];

        builder.debugger(builder.evalSymbols(), evalInfo);
    });
    STATEMENTS.add(Ops$$1.ClientSideStatement, function (sexp, builder) {
        CLIENT_SIDE.compile(sexp, builder);
    });
    STATEMENTS.add(Ops$$1.Append, function (sexp, builder) {
        var value = sexp[1],
            trusting = sexp[2];
        var inlines = builder.macros.inlines;

        var returned = inlines.compile(sexp, builder) || value;
        if (returned === true) return;
        var isGet$$1 = isGet(value);
        var isMaybeLocal$$1 = isMaybeLocal(value);
        if (trusting) {
            builder.guardedAppend(value, true);
        } else {
            if (isGet$$1 || isMaybeLocal$$1) {
                builder.guardedAppend(value, false);
            } else {
                builder.expr(value);
                builder.primitive(false);
                builder.load(Register.t0);
                builder.dynamicContent();
            }
        }
    });
    STATEMENTS.add(Ops$$1.Block, function (sexp, builder) {
        var name = sexp[1],
            params = sexp[2],
            hash = sexp[3],
            _template = sexp[4],
            _inverse = sexp[5];

        var template = builder.template(_template);
        var inverse = builder.template(_inverse);
        var templateBlock = template && template;
        var inverseBlock = inverse && inverse;
        var blocks = builder.macros.blocks;

        blocks.compile(name, params, hash, templateBlock, inverseBlock, builder);
    });
    var CLIENT_SIDE = new Compilers(1);
    CLIENT_SIDE.add(Ops$1.OpenComponentElement, function (sexp, builder) {
        builder.putComponentOperations();
        builder.openPrimitiveElement(sexp[2]);
    });
    CLIENT_SIDE.add(Ops$1.DidCreateElement, function (_sexp, builder) {
        builder.didCreateElement(Register.s0);
    });
    CLIENT_SIDE.add(Ops$1.SetComponentAttrs, function (sexp, builder) {
        builder.setComponentAttrs(sexp[2]);
    });
    CLIENT_SIDE.add(Ops$1.Debugger, function () {
        // tslint:disable-next-line:no-debugger
        debugger;
    });
    CLIENT_SIDE.add(Ops$1.DidRenderLayout, function (_sexp, builder) {
        builder.didRenderLayout(Register.s0);
    });
    return STATEMENTS;
}
function dynamicAttr(sexp, trusting, builder) {
    var name = sexp[1],
        value = sexp[2],
        namespace = sexp[3];

    builder.expr(value);
    if (namespace) {
        builder.dynamicAttr(name, namespace, trusting);
    } else {
        builder.dynamicAttr(name, null, trusting);
    }
}
var _expressionCompiler = void 0;
function expressionCompiler() {
    if (_expressionCompiler) {
        return _expressionCompiler;
    }
    var EXPRESSIONS = _expressionCompiler = new Compilers();
    EXPRESSIONS.add(Ops$$1.Unknown, function (sexp, builder) {
        var resolver = builder.resolver,
            asPartial = builder.asPartial,
            referrer = builder.referrer;

        var name = sexp[1];
        var handle = resolver.lookupHelper(name, referrer);
        if (handle !== null) {
            builder.helper(handle, null, null);
        } else if (asPartial) {
            builder.resolveMaybeLocal(name);
        } else {
            builder.getVariable(0);
            builder.getProperty(name);
        }
    });
    EXPRESSIONS.add(Ops$$1.Concat, function (sexp, builder) {
        var parts = sexp[1];
        for (var i = 0; i < parts.length; i++) {
            builder.expr(parts[i]);
        }
        builder.concat(parts.length);
    });
    EXPRESSIONS.add(Ops$$1.Helper, function (sexp, builder) {
        var resolver = builder.resolver,
            referrer = builder.referrer;
        var name = sexp[1],
            params = sexp[2],
            hash = sexp[3];
        // TODO: triage this in the WF compiler

        if (name === 'component') {
            false && debugAssert(params.length, 'SYNTAX ERROR: component helper requires at least one argument');

            var definition = params[0],
                restArgs = params.slice(1);

            builder.curryComponent(definition, restArgs, hash, true);
            return;
        }
        var handle = resolver.lookupHelper(name, referrer);
        if (handle !== null) {
            builder.helper(handle, params, hash);
        } else {
            throw new Error('Compile Error: ' + name + ' is not a helper');
        }
    });
    EXPRESSIONS.add(Ops$$1.Get, function (sexp, builder) {
        var head = sexp[1],
            path = sexp[2];

        builder.getVariable(head);
        for (var i = 0; i < path.length; i++) {
            builder.getProperty(path[i]);
        }
    });
    EXPRESSIONS.add(Ops$$1.MaybeLocal, function (sexp, builder) {
        var path = sexp[1];

        if (builder.asPartial) {
            var head = path[0];
            path = path.slice(1);
            builder.resolveMaybeLocal(head);
        } else {
            builder.getVariable(0);
        }
        for (var i = 0; i < path.length; i++) {
            builder.getProperty(path[i]);
        }
    });
    EXPRESSIONS.add(Ops$$1.Undefined, function (_sexp, builder) {
        return builder.pushPrimitiveReference(undefined);
    });
    EXPRESSIONS.add(Ops$$1.HasBlock, function (sexp, builder) {
        builder.hasBlock(sexp[1]);
    });
    EXPRESSIONS.add(Ops$$1.HasBlockParams, function (sexp, builder) {
        builder.hasBlockParams(sexp[1]);
    });
    return EXPRESSIONS;
}
var Macros = function Macros() {
    classCallCheck(this, Macros);

    var _populateBuiltins = populateBuiltins(),
        blocks = _populateBuiltins.blocks,
        inlines = _populateBuiltins.inlines;

    this.blocks = blocks;
    this.inlines = inlines;
};
var Blocks = function () {
    function Blocks() {
        classCallCheck(this, Blocks);

        this.names = dict();
        this.funcs = [];
    }

    Blocks.prototype.add = function add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    };

    Blocks.prototype.addMissing = function addMissing(func) {
        this.missing = func;
    };

    Blocks.prototype.compile = function compile(name, params, hash, template, inverse, builder) {
        var index = this.names[name];
        if (index === undefined) {
            false && debugAssert(!!this.missing, name + ' not found, and no catch-all block handler was registered');

            var func = this.missing;
            var handled = func(name, params, hash, template, inverse, builder);
            false && debugAssert(!!handled, name + ' not found, and the catch-all block handler didn\'t handle it');
        } else {
            var _func = this.funcs[index];
            _func(params, hash, template, inverse, builder);
        }
    };

    return Blocks;
}();
var Inlines = function () {
    function Inlines() {
        classCallCheck(this, Inlines);

        this.names = dict();
        this.funcs = [];
    }

    Inlines.prototype.add = function add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    };

    Inlines.prototype.addMissing = function addMissing(func) {
        this.missing = func;
    };

    Inlines.prototype.compile = function compile(sexp, builder) {
        var value = sexp[1];
        // TODO: Fix this so that expression macros can return
        // things like components, so that {{component foo}}
        // is the same as {{(component foo)}}
        if (!Array.isArray(value)) return ['expr', value];
        var name = void 0;
        var params = void 0;
        var hash = void 0;
        if (value[0] === Ops$$1.Helper) {
            name = value[1];
            params = value[2];
            hash = value[3];
        } else if (value[0] === Ops$$1.Unknown) {
            name = value[1];
            params = hash = null;
        } else {
            return ['expr', value];
        }
        var index = this.names[name];
        if (index === undefined && this.missing) {
            var func = this.missing;
            var returned = func(name, params, hash, builder);
            return returned === false ? ['expr', value] : returned;
        } else if (index !== undefined) {
            var _func2 = this.funcs[index];
            var _returned = _func2(name, params, hash, builder);
            return _returned === false ? ['expr', value] : _returned;
        } else {
            return ['expr', value];
        }
    };

    return Inlines;
}();
function populateBuiltins() {
    var blocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Blocks();
    var inlines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Inlines();

    blocks.add('if', function (params, _hash, template, inverse, builder) {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error('SYNTAX ERROR: #if requires a single argument');
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        builder.expr(params[0]);
        builder.toBoolean();
        builder.enter(1);
        builder.jumpUnless('ELSE');
        builder.invokeStaticBlock(template);
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStaticBlock(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('unless', function (params, _hash, template, inverse, builder) {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error('SYNTAX ERROR: #unless requires a single argument');
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        builder.expr(params[0]);
        builder.toBoolean();
        builder.enter(1);
        builder.jumpIf('ELSE');
        builder.invokeStaticBlock(template);
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStaticBlock(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('with', function (params, _hash, template, inverse, builder) {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error('SYNTAX ERROR: #with requires a single argument');
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        builder.expr(params[0]);
        builder.dup();
        builder.toBoolean();
        builder.enter(2);
        builder.jumpUnless('ELSE');
        builder.invokeStaticBlock(template, 1);
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStaticBlock(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('each', function (params, hash, template, inverse, builder) {
        //         Enter(BEGIN, END)
        // BEGIN:  Noop
        //         PutArgs
        //         PutIterable
        //         JumpUnless(ELSE)
        //         EnterList(BEGIN2, END2)
        // ITER:   Noop
        //         NextIter(BREAK)
        // BEGIN2: Noop
        //         PushChildScope
        //         Evaluate(default)
        //         PopScope
        // END2:   Noop
        //         Exit
        //         Jump(ITER)
        // BREAK:  Noop
        //         ExitList
        //         Jump(END)
        // ELSE:   Noop
        //         Evalulate(inverse)
        // END:    Noop
        //         Exit
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        if (hash && hash[0][0] === 'key') {
            builder.expr(hash[1][0]);
        } else {
            builder.pushPrimitiveReference(null);
        }
        builder.expr(params[0]);
        builder.enter(2);
        builder.putIterator();
        builder.jumpUnless('ELSE');
        builder.pushFrame();
        builder.returnTo('ITER');
        builder.dup(Register.fp, 1);
        builder.enterList('BODY');
        builder.label('ITER');
        builder.iterate('BREAK');
        builder.label('BODY');
        builder.invokeStaticBlock(template, 2);
        builder.pop(2);
        builder.exit();
        builder.return();
        builder.label('BREAK');
        builder.exitList();
        builder.popFrame();
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStaticBlock(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('in-element', function (params, hash, template, _inverse, builder) {
        if (!params || params.length !== 1) {
            throw new Error('SYNTAX ERROR: #in-element requires a single argument');
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        var keys = hash[0],
            values = hash[1];

        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key === 'nextSibling' || key === 'guid') {
                builder.expr(values[i]);
            } else {
                throw new Error('SYNTAX ERROR: #in-element does not take a `' + keys[0] + '` option');
            }
        }
        builder.expr(params[0]);
        builder.dup();
        builder.enter(4);
        builder.jumpUnless('ELSE');
        builder.pushRemoteElement();
        builder.invokeStaticBlock(template);
        builder.popRemoteElement();
        builder.label('ELSE');
        builder.exit();
        builder.return();
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('-with-dynamic-vars', function (_params, hash, template, _inverse, builder) {
        if (hash) {
            var names = hash[0],
                expressions = hash[1];

            builder.compileParams(expressions);
            builder.pushDynamicScope();
            builder.bindDynamicScope(names);
            builder.invokeStaticBlock(template);
            builder.popDynamicScope();
        } else {
            builder.invokeStaticBlock(template);
        }
    });
    blocks.add('component', function (_params, hash, template, inverse, builder) {
        false && debugAssert(_params && _params.length, 'SYNTAX ERROR: #component requires at least one argument');

        var tag = _params[0];
        if (typeof tag === 'string') {
            var returned = builder.staticComponentHelper(_params[0], hash, template);
            if (returned) return;
        }

        var definition = _params[0],
            params = _params.slice(1);

        builder.dynamicComponent(definition, params, hash, true, template, inverse);
    });
    inlines.add('component', function (_name, _params, hash, builder) {
        false && debugAssert(_params && _params.length, 'SYNTAX ERROR: component helper requires at least one argument');

        var tag = _params && _params[0];
        if (typeof tag === 'string') {
            var returned = builder.staticComponentHelper(tag, hash, null);
            if (returned) return true;
        }

        var definition = _params[0],
            params = _params.slice(1);

        builder.dynamicComponent(definition, params, hash, true, null, null);
        return true;
    });
    return { blocks: blocks, inlines: inlines };
}

var PLACEHOLDER_HANDLE$1 = -1;

var CompilableTemplate = function () {
    function CompilableTemplate(statements, containingLayout, options, symbolTable) {
        classCallCheck(this, CompilableTemplate);

        this.statements = statements;
        this.containingLayout = containingLayout;
        this.options = options;
        this.symbolTable = symbolTable;
        this.compiled = null;
        this.statementCompiler = statementCompiler();
    }

    CompilableTemplate.topLevel = function topLevel(block, options) {
        return new CompilableTemplate(block.statements, { block: block, referrer: options.referrer }, options, { referrer: options.referrer, hasEval: block.hasEval, symbols: block.symbols });
    };

    CompilableTemplate.prototype.compile = function compile(stdLib) {
        var compiled = this.compiled;

        if (compiled !== null) return compiled;
        // Track that compilation has started but not yet finished by temporarily
        // using a placeholder handle. In eager compilation mode, where compile()
        // may be called recursively, we use this as a signal that the handle cannot
        // be known synchronously and must be linked lazily.
        this.compiled = PLACEHOLDER_HANDLE$1;
        var options = this.options,
            statements = this.statements,
            containingLayout = this.containingLayout;
        var referrer = containingLayout.referrer;
        var program = options.program,
            resolver = options.resolver,
            macros = options.macros,
            asPartial = options.asPartial,
            Builder = options.Builder;

        var builder = new Builder(program, resolver, referrer, macros, containingLayout, asPartial, stdLib);
        for (var i = 0; i < statements.length; i++) {
            this.statementCompiler.compile(statements[i], builder);
        }
        var handle = builder.commit(program.heap, containingLayout.block.symbols.length);
        return this.compiled = handle;
    };

    return CompilableTemplate;
}();

var ComponentBuilder = function () {
    function ComponentBuilder(builder) {
        classCallCheck(this, ComponentBuilder);

        this.builder = builder;
    }

    ComponentBuilder.prototype.static = function _static(handle, args) {
        var params = args[0],
            hash = args[1],
            _default = args[2],
            inverse = args[3];
        var builder = this.builder;
        var resolver = builder.resolver;

        if (handle !== null) {
            var capabilities = resolver.getCapabilities(handle);
            if (capabilities.dynamicLayout === false) {
                var layout = resolver.getLayout(handle);
                builder.pushComponentDefinition(handle);
                builder.invokeStaticComponent(capabilities, layout, null, params, hash, false, _default, inverse);
            } else {
                builder.pushComponentDefinition(handle);
                builder.invokeComponent(null, params, hash, false, _default, inverse);
            }
        }
    };

    return ComponentBuilder;
}();

var InstructionEncoder = function () {
    function InstructionEncoder(buffer) {
        classCallCheck(this, InstructionEncoder);

        this.buffer = buffer;
        this.typePos = 0;
        this.size = 0;
    }

    InstructionEncoder.prototype.encode = function encode(type, machine) {
        if (type > 255 /* TYPE_SIZE */) {
                throw new Error('Opcode type over 8-bits. Got ' + type + '.');
            }
        this.buffer.push(type | machine | arguments.length - 2 << 8 /* ARG_SHIFT */);
        this.typePos = this.buffer.length - 1;
        for (var i = 2; i < arguments.length; i++) {
            var op = arguments[i];
            if (typeof op === 'number' && op > 65535 /* MAX_SIZE */) {
                    throw new Error('Operand over 16-bits. Got ' + op + '.');
                }
            this.buffer.push(op);
        }
        
        this.size = this.buffer.length;
    };

    InstructionEncoder.prototype.patch = function patch(position, operand) {
        if (this.buffer[position + 1] === -1) {
            this.buffer[position + 1] = operand;
        } else {
            throw new Error('Trying to patch operand in populated slot instead of a reserved slot.');
        }
    };

    return InstructionEncoder;
}();

var Labels = function () {
    function Labels() {
        classCallCheck(this, Labels);

        this.labels = dict();
        this.targets = [];
    }

    Labels.prototype.label = function label(name, index) {
        this.labels[name] = index;
    };

    Labels.prototype.target = function target(at, _target) {
        this.targets.push({ at: at, target: _target });
    };

    Labels.prototype.patch = function patch(encoder) {
        var targets = this.targets,
            labels = this.labels;

        for (var i = 0; i < targets.length; i++) {
            var _targets$i = targets[i],
                at = _targets$i.at,
                target = _targets$i.target;

            var address = labels[target] - at;
            encoder.patch(at, address);
        }
    };

    return Labels;
}();

var SimpleOpcodeBuilder = function () {
    function SimpleOpcodeBuilder() {
        classCallCheck(this, SimpleOpcodeBuilder);

        this.encoder = new InstructionEncoder([]);
    }

    SimpleOpcodeBuilder.prototype.push = function push(name) {
        switch (arguments.length) {
            case 1:
                return this.encoder.encode(name, 0);
            case 2:
                return this.encoder.encode(name, 0, arguments[1]);
            case 3:
                return this.encoder.encode(name, 0, arguments[1], arguments[2]);
            default:
                return this.encoder.encode(name, 0, arguments[1], arguments[2], arguments[3]);
        }
    };

    SimpleOpcodeBuilder.prototype.pushMachine = function pushMachine(name) {
        switch (arguments.length) {
            case 1:
                return this.encoder.encode(name, 1024 /* MACHINE_MASK */);
            case 2:
                return this.encoder.encode(name, 1024 /* MACHINE_MASK */, arguments[1]);
            case 3:
                return this.encoder.encode(name, 1024 /* MACHINE_MASK */, arguments[1], arguments[2]);
            default:
                return this.encoder.encode(name, 1024 /* MACHINE_MASK */, arguments[1], arguments[2], arguments[3]);
        }
    };

    SimpleOpcodeBuilder.prototype.commit = function commit(heap, scopeSize) {
        this.pushMachine(20 /* Return */);
        var buffer = this.encoder.buffer;
        // TODO: change the whole malloc API and do something more efficient

        var handle = heap.malloc();
        for (var i = 0; i < buffer.length; i++) {
            var value = buffer[i];
            typeof value === 'function' ? heap.pushPlaceholder(value) : heap.push(value);
        }
        heap.finishMalloc(handle, scopeSize);
        return handle;
    };

    SimpleOpcodeBuilder.prototype.reserve = function reserve(name) {
        this.encoder.encode(name, 0, -1);
    };

    SimpleOpcodeBuilder.prototype.reserveMachine = function reserveMachine(name) {
        this.encoder.encode(name, 1024 /* MACHINE_MASK */, -1);
    };
    ///


    SimpleOpcodeBuilder.prototype.main = function main() {
        this.push(56 /* Main */, Register.s0);
        this.invokePreparedComponent(false);
    };

    SimpleOpcodeBuilder.prototype.dynamicContent = function dynamicContent() {
        this.push(24 /* DynamicContent */);
    };

    SimpleOpcodeBuilder.prototype.beginComponentTransaction = function beginComponentTransaction() {
        this.push(75 /* BeginComponentTransaction */);
    };

    SimpleOpcodeBuilder.prototype.commitComponentTransaction = function commitComponentTransaction() {
        this.push(76 /* CommitComponentTransaction */);
    };

    SimpleOpcodeBuilder.prototype.pushDynamicScope = function pushDynamicScope() {
        this.push(36 /* PushDynamicScope */);
    };

    SimpleOpcodeBuilder.prototype.popDynamicScope = function popDynamicScope() {
        this.push(37 /* PopDynamicScope */);
    };

    SimpleOpcodeBuilder.prototype.pushRemoteElement = function pushRemoteElement() {
        this.push(33 /* PushRemoteElement */);
    };

    SimpleOpcodeBuilder.prototype.popRemoteElement = function popRemoteElement() {
        this.push(34 /* PopRemoteElement */);
    };

    SimpleOpcodeBuilder.prototype.pushRootScope = function pushRootScope(symbols, bindCallerScope) {
        this.push(17 /* RootScope */, symbols, bindCallerScope ? 1 : 0);
    };

    SimpleOpcodeBuilder.prototype.pushChildScope = function pushChildScope() {
        this.push(18 /* ChildScope */);
    };

    SimpleOpcodeBuilder.prototype.popScope = function popScope() {
        this.push(19 /* PopScope */);
    };

    SimpleOpcodeBuilder.prototype.prepareArgs = function prepareArgs(state) {
        this.push(65 /* PrepareArgs */, state);
    };

    SimpleOpcodeBuilder.prototype.createComponent = function createComponent(state, hasDefault) {
        var flag = hasDefault | 0;
        this.push(67 /* CreateComponent */, flag, state);
    };

    SimpleOpcodeBuilder.prototype.registerComponentDestructor = function registerComponentDestructor(state) {
        this.push(68 /* RegisterComponentDestructor */, state);
    };

    SimpleOpcodeBuilder.prototype.putComponentOperations = function putComponentOperations() {
        this.push(69 /* PutComponentOperations */);
    };

    SimpleOpcodeBuilder.prototype.getComponentSelf = function getComponentSelf(state) {
        this.push(70 /* GetComponentSelf */, state);
    };

    SimpleOpcodeBuilder.prototype.getComponentTagName = function getComponentTagName(state) {
        this.push(71 /* GetComponentTagName */, state);
    };

    SimpleOpcodeBuilder.prototype.getComponentLayout = function getComponentLayout(state) {
        this.push(72 /* GetComponentLayout */, state);
    };

    SimpleOpcodeBuilder.prototype.invokeComponentLayout = function invokeComponentLayout(state) {
        this.push(74 /* InvokeComponentLayout */, state);
    };

    SimpleOpcodeBuilder.prototype.didCreateElement = function didCreateElement(state) {
        this.push(77 /* DidCreateElement */, state);
    };

    SimpleOpcodeBuilder.prototype.didRenderLayout = function didRenderLayout(state) {
        this.push(78 /* DidRenderLayout */, state);
    };

    SimpleOpcodeBuilder.prototype.pushFrame = function pushFrame() {
        this.pushMachine(47 /* PushFrame */);
    };

    SimpleOpcodeBuilder.prototype.popFrame = function popFrame() {
        this.pushMachine(48 /* PopFrame */);
    };

    SimpleOpcodeBuilder.prototype.invokeVirtual = function invokeVirtual() {
        this.pushMachine(41 /* InvokeVirtual */);
    };

    SimpleOpcodeBuilder.prototype.invokeYield = function invokeYield() {
        this.push(43 /* InvokeYield */);
    };

    SimpleOpcodeBuilder.prototype.toBoolean = function toBoolean() {
        this.push(51 /* ToBoolean */);
    };

    SimpleOpcodeBuilder.prototype.invokePreparedComponent = function invokePreparedComponent(hasBlock) {
        var populateLayout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        this.beginComponentTransaction();
        this.pushDynamicScope();
        this.createComponent(Register.s0, hasBlock);
        // this has to run after createComponent to allow
        // for late-bound layouts, but a caller is free
        // to populate the layout earlier if it wants to
        // and do nothing here.
        if (populateLayout) populateLayout();
        this.registerComponentDestructor(Register.s0);
        this.getComponentSelf(Register.s0);
        this.invokeComponentLayout(Register.s0);
        this.didRenderLayout(Register.s0);
        this.popFrame();
        this.popScope();
        this.popDynamicScope();
        this.commitComponentTransaction();
    };

    createClass(SimpleOpcodeBuilder, [{
        key: 'pos',
        get: function get$$1() {
            return this.encoder.typePos;
        }
    }, {
        key: 'nextPos',
        get: function get$$1() {
            return this.encoder.size;
        }
    }]);
    return SimpleOpcodeBuilder;
}();

var OpcodeBuilder = function (_SimpleOpcodeBuilder) {
    inherits(OpcodeBuilder, _SimpleOpcodeBuilder);

    function OpcodeBuilder(program, resolver, referrer, macros, containingLayout, asPartial, stdLib) {
        classCallCheck(this, OpcodeBuilder);

        var _this = possibleConstructorReturn(this, _SimpleOpcodeBuilder.call(this));

        _this.program = program;
        _this.resolver = resolver;
        _this.referrer = referrer;
        _this.macros = macros;
        _this.containingLayout = containingLayout;
        _this.asPartial = asPartial;
        _this.stdLib = stdLib;
        _this.component = new ComponentBuilder(_this);
        _this.expressionCompiler = expressionCompiler();
        _this.labelsStack = new Stack();
        _this.isComponentAttrs = false;
        _this.constants = program.constants;
        return _this;
    }

    OpcodeBuilder.prototype.label = function label(name) {
        this.labels.label(name, this.nextPos);
    };

    OpcodeBuilder.prototype.setComponentAttrs = function setComponentAttrs(enabled) {
        this.isComponentAttrs = enabled;
    };

    OpcodeBuilder.prototype.expr = function expr(expression) {
        if (Array.isArray(expression)) {
            this.expressionCompiler.compile(expression, this);
        } else {
            this.pushPrimitiveReference(expression);
        }
    };
    // args


    OpcodeBuilder.prototype.pushArgs = function pushArgs(names, flags) {
        var serialized = this.constants.stringArray(names);
        this.push(63 /* PushArgs */, serialized, flags);
    };
    // helpers


    OpcodeBuilder.prototype.startLabels = function startLabels() {
        this.labelsStack.push(new Labels());
    };

    OpcodeBuilder.prototype.stopLabels = function stopLabels() {
        var label = this.labelsStack.pop();
        label.patch(this.encoder);
    };
    // components


    OpcodeBuilder.prototype.pushComponentDefinition = function pushComponentDefinition(handle) {
        this.push(59 /* PushComponentDefinition */, this.constants.handle(handle));
    };

    OpcodeBuilder.prototype.pushCurriedComponent = function pushCurriedComponent() {
        this.push(61 /* PushCurriedComponent */);
    };

    OpcodeBuilder.prototype.pushDynamicComponentInstance = function pushDynamicComponentInstance() {
        this.push(60 /* PushDynamicComponentInstance */);
    };

    OpcodeBuilder.prototype.resolveDynamicComponent = function resolveDynamicComponent(referrer) {
        this.push(62 /* ResolveDynamicComponent */, this.constants.serializable(referrer));
    };

    OpcodeBuilder.prototype.staticComponentHelper = function staticComponentHelper(tag, hash, template) {
        var handle = this.resolver.lookupComponentDefinition(tag, this.referrer);
        if (handle) {
            var capabilities = this.resolver.getCapabilities(handle);
            if (capabilities.dynamicLayout === false) {
                if (hash) {
                    for (var i = 0; i < hash.length; i = i + 2) {
                        hash[i][0] = '@' + hash[i][0];
                    }
                }
                var layout = this.resolver.getLayout(handle);
                this.pushComponentDefinition(handle);
                this.invokeStaticComponent(capabilities, layout, null, null, hash, false, template && template);
                return true;
            }
        }
        return false;
    };
    // partial


    OpcodeBuilder.prototype.invokePartial = function invokePartial(referrer, symbols, evalInfo) {
        var _meta = this.constants.serializable(referrer);
        var _symbols = this.constants.stringArray(symbols);
        var _evalInfo = this.constants.array(evalInfo);
        this.push(79 /* InvokePartial */, _meta, _symbols, _evalInfo);
    };

    OpcodeBuilder.prototype.resolveMaybeLocal = function resolveMaybeLocal(name) {
        this.push(80 /* ResolveMaybeLocal */, this.string(name));
    };
    // debugger


    OpcodeBuilder.prototype.debugger = function _debugger(symbols, evalInfo) {
        this.push(81 /* Debugger */, this.constants.stringArray(symbols), this.constants.array(evalInfo));
    };
    // dom


    OpcodeBuilder.prototype.text = function text(_text) {
        this.push(22 /* Text */, this.constants.string(_text));
    };

    OpcodeBuilder.prototype.openPrimitiveElement = function openPrimitiveElement(tag) {
        this.push(25 /* OpenElement */, this.constants.string(tag));
    };

    OpcodeBuilder.prototype.openDynamicElement = function openDynamicElement() {
        this.push(26 /* OpenDynamicElement */);
    };

    OpcodeBuilder.prototype.flushElement = function flushElement() {
        this.push(30 /* FlushElement */);
    };

    OpcodeBuilder.prototype.closeElement = function closeElement() {
        this.push(31 /* CloseElement */);
    };

    OpcodeBuilder.prototype.staticAttr = function staticAttr(_name, _namespace, _value) {
        var name = this.constants.string(_name);
        var namespace = _namespace ? this.constants.string(_namespace) : 0;
        if (this.isComponentAttrs) {
            this.pushPrimitiveReference(_value);
            this.push(29 /* ComponentAttr */, name, 1, namespace);
        } else {
            var value = this.constants.string(_value);
            this.push(27 /* StaticAttr */, name, value, namespace);
        }
    };

    OpcodeBuilder.prototype.dynamicAttr = function dynamicAttr(_name, _namespace, trusting) {
        var name = this.constants.string(_name);
        var namespace = _namespace ? this.constants.string(_namespace) : 0;
        if (this.isComponentAttrs) {
            this.push(29 /* ComponentAttr */, name, trusting === true ? 1 : 0, namespace);
        } else {
            this.push(28 /* DynamicAttr */, name, trusting === true ? 1 : 0, namespace);
        }
    };

    OpcodeBuilder.prototype.comment = function comment(_comment) {
        var comment = this.constants.string(_comment);
        this.push(23 /* Comment */, comment);
    };

    OpcodeBuilder.prototype.modifier = function modifier(locator, params, hash) {
        this.pushFrame();
        this.compileArgs(params, hash, null, true);
        this.push(32 /* Modifier */, this.constants.handle(locator));
        this.popFrame();
    };
    // lists


    OpcodeBuilder.prototype.putIterator = function putIterator() {
        this.push(54 /* PutIterator */);
    };

    OpcodeBuilder.prototype.enterList = function enterList(start) {
        this.reserve(52 /* EnterList */);
        this.labels.target(this.pos, start);
    };

    OpcodeBuilder.prototype.exitList = function exitList() {
        this.push(53 /* ExitList */);
    };

    OpcodeBuilder.prototype.iterate = function iterate(breaks) {
        this.reserve(55 /* Iterate */);
        this.labels.target(this.pos, breaks);
    };
    // expressions


    OpcodeBuilder.prototype.setVariable = function setVariable(symbol) {
        this.push(2 /* SetVariable */, symbol);
    };

    OpcodeBuilder.prototype.setBlock = function setBlock(symbol) {
        this.push(3 /* SetBlock */, symbol);
    };

    OpcodeBuilder.prototype.getVariable = function getVariable(symbol) {
        this.push(4 /* GetVariable */, symbol);
    };

    OpcodeBuilder.prototype.getProperty = function getProperty(key) {
        this.push(5 /* GetProperty */, this.string(key));
    };

    OpcodeBuilder.prototype.getBlock = function getBlock(symbol) {
        this.push(6 /* GetBlock */, symbol);
    };

    OpcodeBuilder.prototype.hasBlock = function hasBlock(symbol) {
        this.push(7 /* HasBlock */, symbol);
    };

    OpcodeBuilder.prototype.hasBlockParams = function hasBlockParams(to) {
        this.getBlock(to);
        this.resolveBlock();
        this.push(8 /* HasBlockParams */);
    };

    OpcodeBuilder.prototype.concat = function concat(size) {
        this.push(9 /* Concat */, size);
    };

    OpcodeBuilder.prototype.load = function load(register) {
        this.push(15 /* Load */, register);
    };

    OpcodeBuilder.prototype.fetch = function fetch(register) {
        this.push(16 /* Fetch */, register);
    };

    OpcodeBuilder.prototype.dup = function dup() {
        var register = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Register.sp;
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        return this.push(13 /* Dup */, register, offset);
    };

    OpcodeBuilder.prototype.pop = function pop() {
        var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        return this.push(14 /* Pop */, count);
    };
    // vm


    OpcodeBuilder.prototype.returnTo = function returnTo(label) {
        this.reserveMachine(21 /* ReturnTo */);
        this.labels.target(this.pos, label);
    };

    OpcodeBuilder.prototype.primitive = function primitive(_primitive) {
        var type = 0;
        var primitive = void 0;
        switch (typeof _primitive === 'undefined' ? 'undefined' : _typeof(_primitive)) {
            case 'number':
                if (_primitive % 1 === 0) {
                    if (_primitive > -1) {
                        primitive = _primitive;
                    } else {
                        primitive = this.negative(_primitive);
                        type = 4 /* NEGATIVE */;
                    }
                } else {
                    primitive = this.float(_primitive);
                    type = 1 /* FLOAT */;
                }
                break;
            case 'string':
                primitive = this.string(_primitive);
                type = 2 /* STRING */;
                break;
            case 'boolean':
                primitive = _primitive | 0;
                type = 3 /* BOOLEAN_OR_VOID */;
                break;
            case 'object':
                // assume null
                primitive = 2;
                type = 3 /* BOOLEAN_OR_VOID */;
                break;
            case 'undefined':
                primitive = 3;
                type = 3 /* BOOLEAN_OR_VOID */;
                break;
            default:
                throw new Error('Invalid primitive passed to pushPrimitive');
        }
        this.push(11 /* Primitive */, primitive << 3 | type);
    };

    OpcodeBuilder.prototype.float = function float(num) {
        return this.constants.float(num);
    };

    OpcodeBuilder.prototype.negative = function negative(num) {
        return this.constants.negative(num);
    };

    OpcodeBuilder.prototype.pushPrimitiveReference = function pushPrimitiveReference(primitive) {
        this.primitive(primitive);
        this.primitiveReference();
    };

    OpcodeBuilder.prototype.primitiveReference = function primitiveReference() {
        this.push(12 /* PrimitiveReference */);
    };

    OpcodeBuilder.prototype.helper = function helper(_helper, params, hash) {
        this.pushFrame();
        this.compileArgs(params, hash, null, true);
        this.push(1 /* Helper */, this.constants.handle(_helper));
        this.popFrame();
        this.fetch(Register.v0);
    };

    OpcodeBuilder.prototype.bindDynamicScope = function bindDynamicScope(_names) {
        this.push(35 /* BindDynamicScope */, this.names(_names));
    };

    OpcodeBuilder.prototype.enter = function enter(args) {
        this.push(49 /* Enter */, args);
    };

    OpcodeBuilder.prototype.exit = function exit() {
        this.push(50 /* Exit */);
    };

    OpcodeBuilder.prototype.return = function _return() {
        this.pushMachine(20 /* Return */);
    };

    OpcodeBuilder.prototype.jump = function jump(target) {
        this.reserveMachine(44 /* Jump */);
        this.labels.target(this.pos, target);
    };

    OpcodeBuilder.prototype.jumpIf = function jumpIf(target) {
        this.reserve(45 /* JumpIf */);
        this.labels.target(this.pos, target);
    };

    OpcodeBuilder.prototype.jumpUnless = function jumpUnless(target) {
        this.reserve(46 /* JumpUnless */);
        this.labels.target(this.pos, target);
    };
    // internal helpers


    OpcodeBuilder.prototype.string = function string(_string) {
        return this.constants.string(_string);
    };

    OpcodeBuilder.prototype.names = function names(_names) {
        var names = [];
        for (var i = 0; i < _names.length; i++) {
            var n = _names[i];
            names[i] = this.constants.string(n);
        }
        return this.constants.array(names);
    };

    OpcodeBuilder.prototype.symbols = function symbols(_symbols2) {
        return this.constants.array(_symbols2);
    };
    // convenience methods


    OpcodeBuilder.prototype.inlineBlock = function inlineBlock(block) {
        var parameters = block.parameters,
            statements = block.statements;

        var symbolTable = { parameters: parameters, referrer: this.containingLayout.referrer };
        var options = {
            program: this.program,
            macros: this.macros,
            Builder: this.constructor,
            resolver: this.resolver,
            asPartial: this.asPartial,
            referrer: this.referrer
        };
        return new CompilableTemplate(statements, this.containingLayout, options, symbolTable);
    };

    OpcodeBuilder.prototype.evalSymbols = function evalSymbols() {
        var block = this.containingLayout.block;

        return block.hasEval ? block.symbols : null;
    };

    OpcodeBuilder.prototype.compileParams = function compileParams(params) {
        if (!params) return 0;
        for (var i = 0; i < params.length; i++) {
            this.expr(params[i]);
        }
        return params.length;
    };

    OpcodeBuilder.prototype.compileArgs = function compileArgs(params, hash, blocks, synthetic) {
        if (blocks) {
            this.pushYieldableBlock(blocks.main);
            this.pushYieldableBlock(blocks.else);
            this.pushYieldableBlock(blocks.attrs);
        }
        var count = this.compileParams(params);
        var flags = count << 4;
        if (synthetic) flags |= 8;
        if (blocks) {
            flags |= 7;
        }
        var names = EMPTY_ARRAY;
        if (hash) {
            names = hash[0];
            var val = hash[1];
            for (var i = 0; i < val.length; i++) {
                this.expr(val[i]);
            }
        }
        this.pushArgs(names, flags);
    };

    OpcodeBuilder.prototype.invokeStaticBlock = function invokeStaticBlock(block) {
        var callerCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var parameters = block.symbolTable.parameters;

        var calleeCount = parameters.length;
        var count = Math.min(callerCount, calleeCount);
        this.pushFrame();
        if (count) {
            this.pushChildScope();
            for (var i = 0; i < count; i++) {
                this.dup(Register.fp, callerCount - i);
                this.setVariable(parameters[i]);
            }
        }
        this.pushBlock(block);
        this.resolveBlock();
        this.invokeVirtual();
        if (count) {
            this.popScope();
        }
        this.popFrame();
    };

    OpcodeBuilder.prototype.builtInGuardedAppend = function builtInGuardedAppend() {
        this.dup();
        this.startLabels();
        this.isComponent();
        this.enter(2);
        this.jumpUnless('ELSE');
        this.pushCurriedComponent();
        this.pushDynamicComponentInstance();
        this.invokeComponent(null, null, null, false, null, null);
        this.exit();
        this.return();
        this.label('ELSE');
        this.dynamicContent();
        this.exit();
        this.return();
        this.stopLabels();
    };

    OpcodeBuilder.prototype.guardedAppend = function guardedAppend(expression, trusting) {
        this.startLabels();
        this.pushFrame();
        this.returnTo('END');
        if (this.stdLib) {
            this.primitive(!!trusting);
            this.load(Register.t0);
            this.expr(expression);
            this.primitive(this.stdLib.guardedAppend);
            this.invokeVirtual();
        } else {
            this.expr(expression);
            this.dup();
            this.isComponent();
            this.enter(2);
            this.jumpUnless('ELSE');
            this.pushCurriedComponent();
            this.pushDynamicComponentInstance();
            this.invokeComponent(null, null, null, false, null, null);
            this.exit();
            this.return();
            this.label('ELSE');
            this.primitive(!!trusting);
            this.load(Register.t0);
            this.dynamicContent();
            this.exit();
            this.return();
        }
        this.label('END');
        this.popFrame();
        this.stopLabels();
    };

    OpcodeBuilder.prototype.yield = function _yield(to, params) {
        this.compileArgs(params, null, null, false);
        this.getBlock(to);
        this.resolveBlock();
        this.invokeYield();
        this.popScope();
        this.popFrame();
    };

    OpcodeBuilder.prototype.populateLayout = function populateLayout(state) {
        this.push(73 /* PopulateLayout */, state);
    };

    OpcodeBuilder.prototype.invokeComponent = function invokeComponent(attrs, params, hash, synthetic, block) {
        var _this2 = this;

        var inverse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var layout = arguments[6];

        this.fetch(Register.s0);
        this.dup(Register.sp, 1);
        this.load(Register.s0);
        this.pushFrame();
        var blocks = { main: block, else: inverse, attrs: attrs };
        this.compileArgs(params, hash, blocks, synthetic);
        this.prepareArgs(Register.s0);
        this.invokePreparedComponent(block !== null, function () {
            if (layout) {
                _this2.pushSymbolTable(layout.symbolTable);
                _this2.pushLayout(layout);
                _this2.resolveLayout();
            } else {
                _this2.getComponentLayout(Register.s0);
            }
            _this2.populateLayout(Register.s0);
        });
        this.load(Register.s0);
    };

    OpcodeBuilder.prototype.invokeStaticComponent = function invokeStaticComponent(capabilities, layout, attrs, params, hash, synthetic, block) {
        var inverse = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
        var symbolTable = layout.symbolTable;

        var bailOut = symbolTable.hasEval || capabilities.prepareArgs;
        if (bailOut) {
            this.invokeComponent(attrs, params, hash, synthetic, block, inverse, layout);
            return;
        }
        this.fetch(Register.s0);
        this.dup(Register.sp, 1);
        this.load(Register.s0);
        var symbols = symbolTable.symbols;

        if (capabilities.createArgs) {
            this.pushFrame();
            this.compileArgs(null, hash, null, synthetic);
        }
        this.beginComponentTransaction();
        this.pushDynamicScope();
        this.createComponent(Register.s0, block !== null);
        if (capabilities.createArgs) {
            this.popFrame();
        }
        this.registerComponentDestructor(Register.s0);
        var bindings = [];
        this.getComponentSelf(Register.s0);
        bindings.push({ symbol: 0, isBlock: false });
        for (var i = 0; i < symbols.length; i++) {
            var symbol = symbols[i];
            switch (symbol.charAt(0)) {
                case '&':
                    var callerBlock = null;
                    if (symbol === '&default') {
                        callerBlock = block;
                    } else if (symbol === '&inverse') {
                        callerBlock = inverse;
                    } else if (symbol === ATTRS_BLOCK) {
                        callerBlock = attrs;
                    } else {
                        throw unreachable();
                    }
                    if (callerBlock) {
                        this.pushYieldableBlock(callerBlock);
                        bindings.push({ symbol: i + 1, isBlock: true });
                    } else {
                        this.pushYieldableBlock(null);
                        bindings.push({ symbol: i + 1, isBlock: true });
                    }
                    break;
                case '@':
                    if (!hash) {
                        break;
                    }
                    var keys = hash[0],
                        values = hash[1];

                    var lookupName = symbol;
                    if (synthetic) {
                        lookupName = symbol.slice(1);
                    }
                    var index = keys.indexOf(lookupName);
                    if (index !== -1) {
                        this.expr(values[index]);
                        bindings.push({ symbol: i + 1, isBlock: false });
                    }
                    break;
            }
        }
        this.pushRootScope(symbols.length + 1, !!(block || inverse || attrs));
        for (var _i = bindings.length - 1; _i >= 0; _i--) {
            var _bindings$_i = bindings[_i],
                _symbol = _bindings$_i.symbol,
                isBlock = _bindings$_i.isBlock;

            if (isBlock) {
                this.setBlock(_symbol);
            } else {
                this.setVariable(_symbol);
            }
        }
        this.pushFrame();
        this.invokeStatic(layout);
        this.didRenderLayout(Register.s0);
        this.popFrame();
        this.popScope();
        this.popDynamicScope();
        this.commitComponentTransaction();
        this.load(Register.s0);
    };

    OpcodeBuilder.prototype.dynamicComponent = function dynamicComponent(definition, /* TODO: attrs: Option<RawInlineBlock>, */params, hash, synthetic, block) {
        var inverse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

        this.startLabels();
        this.pushFrame();
        this.returnTo('END');
        this.expr(definition);
        this.dup();
        this.enter(2);
        this.jumpUnless('ELSE');
        this.resolveDynamicComponent(this.referrer);
        this.pushDynamicComponentInstance();
        this.invokeComponent(null, params, hash, synthetic, block, inverse);
        this.label('ELSE');
        this.exit();
        this.return();
        this.label('END');
        this.popFrame();
        this.stopLabels();
    };

    OpcodeBuilder.prototype.isComponent = function isComponent() {
        this.push(57 /* IsComponent */);
    };

    OpcodeBuilder.prototype.curryComponent = function curryComponent(definition, /* TODO: attrs: Option<RawInlineBlock>, */params, hash, synthetic) {
        var referrer = this.referrer;
        this.pushFrame();
        this.compileArgs(params, hash, null, synthetic);
        this.push(66 /* CaptureArgs */);
        this.expr(definition);
        this.push(58 /* CurryComponent */, this.constants.serializable(referrer));
        this.popFrame();
        this.fetch(Register.v0);
    };

    OpcodeBuilder.prototype.pushSymbolTable = function pushSymbolTable(table) {
        if (table) {
            var constant = this.constants.serializable(table);
            this.push(40 /* PushSymbolTable */, constant);
        } else {
            this.primitive(null);
        }
    };

    OpcodeBuilder.prototype.pushBlockScope = function pushBlockScope() {
        this.push(39 /* PushBlockScope */);
    };

    OpcodeBuilder.prototype.pushYieldableBlock = function pushYieldableBlock(block) {
        this.pushSymbolTable(block && block.symbolTable);
        this.pushBlockScope();
        this.pushBlock(block);
    };

    OpcodeBuilder.prototype.template = function template(block) {
        if (!block) return null;
        return this.inlineBlock(block);
    };

    createClass(OpcodeBuilder, [{
        key: 'labels',
        get: function get$$1() {
            return this.labelsStack.current;
        }
    }]);
    return OpcodeBuilder;
}(SimpleOpcodeBuilder);

var LazyOpcodeBuilder = function (_OpcodeBuilder) {
    inherits(LazyOpcodeBuilder, _OpcodeBuilder);

    function LazyOpcodeBuilder() {
        classCallCheck(this, LazyOpcodeBuilder);
        return possibleConstructorReturn(this, _OpcodeBuilder.apply(this, arguments));
    }

    LazyOpcodeBuilder.prototype.pushBlock = function pushBlock(block) {
        if (block) {
            this.pushOther(block);
        } else {
            this.primitive(null);
        }
    };

    LazyOpcodeBuilder.prototype.resolveBlock = function resolveBlock() {
        this.push(38 /* CompileBlock */);
    };

    LazyOpcodeBuilder.prototype.pushLayout = function pushLayout(layout) {
        if (layout) {
            this.pushOther(layout);
        } else {
            this.primitive(null);
        }
    };

    LazyOpcodeBuilder.prototype.resolveLayout = function resolveLayout() {
        this.push(38 /* CompileBlock */);
    };

    LazyOpcodeBuilder.prototype.invokeStatic = function invokeStatic(compilable) {
        this.pushOther(compilable);
        this.push(38 /* CompileBlock */);
        this.pushMachine(41 /* InvokeVirtual */);
    };

    LazyOpcodeBuilder.prototype.pushOther = function pushOther(value) {
        this.push(10 /* Constant */, this.other(value));
    };

    LazyOpcodeBuilder.prototype.other = function other(value) {
        return this.constants.other(value);
    };

    return LazyOpcodeBuilder;
}(OpcodeBuilder);
var EagerOpcodeBuilder = function (_OpcodeBuilder2) {
    inherits(EagerOpcodeBuilder, _OpcodeBuilder2);

    function EagerOpcodeBuilder() {
        classCallCheck(this, EagerOpcodeBuilder);
        return possibleConstructorReturn(this, _OpcodeBuilder2.apply(this, arguments));
    }

    EagerOpcodeBuilder.prototype.pushBlock = function pushBlock(block) {
        var handle = block ? block.compile(this.stdLib) : null;
        this.primitive(handle);
    };

    EagerOpcodeBuilder.prototype.resolveBlock = function resolveBlock() {
        return;
    };

    EagerOpcodeBuilder.prototype.pushLayout = function pushLayout(layout) {
        if (layout) {
            this.primitive(layout.compile(this.stdLib));
        } else {
            this.primitive(null);
        }
    };

    EagerOpcodeBuilder.prototype.resolveLayout = function resolveLayout() {};

    EagerOpcodeBuilder.prototype.invokeStatic = function invokeStatic(compilable) {
        var _this5 = this;

        var handle = compilable.compile();
        // If the handle for the invoked component is not yet known (for example,
        // because this is a recursive invocation and we're still compiling), push a
        // function that will produce the correct handle when the heap is
        // serialized.
        if (handle === PLACEHOLDER_HANDLE$1) {
            this.pushMachine(42 /* InvokeStatic */, function () {
                return compilable.compile(_this5.stdLib);
            });
        } else {
            this.pushMachine(42 /* InvokeStatic */, handle);
        }
    };

    return EagerOpcodeBuilder;
}(OpcodeBuilder);

var Arguments = function () {
    function Arguments() {
        classCallCheck(this, Arguments);

        this.stack = null;
        this.positional = new PositionalArguments();
        this.named = new NamedArguments();
        this.blocks = new BlockArguments();
    }

    Arguments.prototype.setup = function setup(stack, names, blockNames, positionalCount, synthetic) {
        this.stack = stack;
        /*
               | ... | blocks      | positional  | named |
               | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |
         index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |
                       ^             ^             ^  ^
                     bbase         pbase       nbase  sp
        */
        var named = this.named;
        var namedCount = names.length;
        var namedBase = stack.sp - namedCount + 1;
        named.setup(stack, namedBase, namedCount, names, synthetic);
        var positional = this.positional;
        var positionalBase = namedBase - positionalCount;
        positional.setup(stack, positionalBase, positionalCount);
        var blocks = this.blocks;
        var blocksCount = blockNames.length;
        var blocksBase = positionalBase - blocksCount * 3;
        blocks.setup(stack, blocksBase, blocksCount, blockNames);
    };

    Arguments.prototype.at = function at(pos) {
        return this.positional.at(pos);
    };

    Arguments.prototype.realloc = function realloc(offset) {
        if (offset > 0) {
            var positional = this.positional,
                named = this.named,
                stack = this.stack;

            var newBase = positional.base + offset;
            var length = positional.length + named.length;
            for (var i = length - 1; i >= 0; i--) {
                stack.copy(i + positional.base, i + newBase);
            }
            positional.base += offset;
            named.base += offset;
            stack.sp += offset;
        }
    };

    Arguments.prototype.capture = function capture() {
        var positional = this.positional.length === 0 ? EMPTY_POSITIONAL : this.positional.capture();
        var named = this.named.length === 0 ? EMPTY_NAMED : this.named.capture();
        return {
            tag: this.tag,
            length: this.length,
            positional: positional,
            named: named
        };
    };

    Arguments.prototype.clear = function clear() {
        var stack = this.stack,
            length = this.length;

        stack.pop(length);
    };

    createClass(Arguments, [{
        key: 'tag',
        get: function get$$1() {
            return combineTagged([this.positional, this.named]);
        }
    }, {
        key: 'base',
        get: function get$$1() {
            return this.blocks.base;
        }
    }, {
        key: 'length',
        get: function get$$1() {
            return this.positional.length + this.named.length + this.blocks.length * 3;
        }
    }]);
    return Arguments;
}();
var PositionalArguments = function () {
    function PositionalArguments() {
        classCallCheck(this, PositionalArguments);

        this.base = 0;
        this.length = 0;
        this.stack = null;
        this._tag = null;
        this._references = null;
    }

    PositionalArguments.prototype.setup = function setup(stack, base, length) {
        this.stack = stack;
        this.base = base;
        this.length = length;
        if (length === 0) {
            this._tag = CONSTANT_TAG;
            this._references = EMPTY_ARRAY;
        } else {
            this._tag = null;
            this._references = null;
        }
    };

    PositionalArguments.prototype.at = function at(position) {
        var base = this.base,
            length = this.length,
            stack = this.stack;

        if (position < 0 || position >= length) {
            return UNDEFINED_REFERENCE;
        }
        return stack.get(position, base);
    };

    PositionalArguments.prototype.capture = function capture() {
        return new CapturedPositionalArguments(this.tag, this.references);
    };

    PositionalArguments.prototype.prepend = function prepend(other) {
        var additions = other.length;
        if (additions > 0) {
            var base = this.base,
                length = this.length,
                stack = this.stack;

            this.base = base = base - additions;
            this.length = length + additions;
            for (var i = 0; i < additions; i++) {
                stack.set(other.at(i), i, base);
            }
            this._tag = null;
            this._references = null;
        }
    };

    createClass(PositionalArguments, [{
        key: 'tag',
        get: function get$$1() {
            var tag = this._tag;
            if (!tag) {
                tag = this._tag = combineTagged(this.references);
            }
            return tag;
        }
    }, {
        key: 'references',
        get: function get$$1() {
            var references = this._references;
            if (!references) {
                var stack = this.stack,
                    base = this.base,
                    length = this.length;

                references = this._references = stack.sliceArray(base, base + length);
            }
            return references;
        }
    }]);
    return PositionalArguments;
}();
var CapturedPositionalArguments = function () {
    function CapturedPositionalArguments(tag, references) {
        var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : references.length;
        classCallCheck(this, CapturedPositionalArguments);

        this.tag = tag;
        this.references = references;
        this.length = length;
    }

    CapturedPositionalArguments.empty = function empty() {
        return new CapturedPositionalArguments(CONSTANT_TAG, EMPTY_ARRAY, 0);
    };

    CapturedPositionalArguments.prototype.at = function at(position) {
        return this.references[position];
    };

    CapturedPositionalArguments.prototype.value = function value() {
        return this.references.map(this.valueOf);
    };

    CapturedPositionalArguments.prototype.get = function get$$1(name) {
        var references = this.references,
            length = this.length;

        if (name === 'length') {
            return PrimitiveReference.create(length);
        } else {
            var idx = parseInt(name, 10);
            if (idx < 0 || idx >= length) {
                return UNDEFINED_REFERENCE;
            } else {
                return references[idx];
            }
        }
    };

    CapturedPositionalArguments.prototype.valueOf = function valueOf(reference) {
        return reference.value();
    };

    return CapturedPositionalArguments;
}();
var NamedArguments = function () {
    function NamedArguments() {
        classCallCheck(this, NamedArguments);

        this.base = 0;
        this.length = 0;
        this._references = null;
        this._names = EMPTY_ARRAY;
        this._atNames = EMPTY_ARRAY;
    }

    NamedArguments.prototype.setup = function setup(stack, base, length, names, synthetic) {
        this.stack = stack;
        this.base = base;
        this.length = length;
        if (length === 0) {
            this._references = EMPTY_ARRAY;
            this._names = EMPTY_ARRAY;
            this._atNames = EMPTY_ARRAY;
        } else {
            this._references = null;
            if (synthetic) {
                this._names = names;
                this._atNames = null;
            } else {
                this._names = null;
                this._atNames = names;
            }
        }
    };

    NamedArguments.prototype.has = function has(name) {
        return this.names.indexOf(name) !== -1;
    };

    NamedArguments.prototype.get = function get$$1(name) {
        var synthetic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var base = this.base,
            stack = this.stack;

        var names = synthetic ? this.names : this.atNames;
        var idx = names.indexOf(name);
        if (idx === -1) {
            return UNDEFINED_REFERENCE;
        }
        return stack.get(idx, base);
    };

    NamedArguments.prototype.capture = function capture() {
        return new CapturedNamedArguments(this.tag, this.names, this.references);
    };

    NamedArguments.prototype.merge = function merge(other) {
        var extras = other.length;

        if (extras > 0) {
            var names = this.names,
                length = this.length,
                stack = this.stack;
            var extraNames = other.names;

            if (Object.isFrozen(names) && names.length === 0) {
                names = [];
            }
            for (var i = 0; i < extras; i++) {
                var name = extraNames[i];
                var idx = names.indexOf(name);
                if (idx === -1) {
                    length = names.push(name);
                    stack.push(other.references[i]);
                }
            }
            this.length = length;
            this._references = null;
            this._names = names;
            this._atNames = null;
        }
    };

    NamedArguments.prototype.toSyntheticName = function toSyntheticName(name) {
        return name.slice(1);
    };

    NamedArguments.prototype.toAtName = function toAtName(name) {
        return '@' + name;
    };

    createClass(NamedArguments, [{
        key: 'tag',
        get: function get$$1() {
            return combineTagged(this.references);
        }
    }, {
        key: 'names',
        get: function get$$1() {
            var names = this._names;
            if (!names) {
                names = this._names = this._atNames.map(this.toSyntheticName);
            }
            return names;
        }
    }, {
        key: 'atNames',
        get: function get$$1() {
            var atNames = this._atNames;
            if (!atNames) {
                atNames = this._atNames = this._names.map(this.toAtName);
            }
            return atNames;
        }
    }, {
        key: 'references',
        get: function get$$1() {
            var references = this._references;
            if (!references) {
                var base = this.base,
                    length = this.length,
                    stack = this.stack;

                references = this._references = stack.sliceArray(base, base + length);
            }
            return references;
        }
    }]);
    return NamedArguments;
}();
var CapturedNamedArguments = function () {
    function CapturedNamedArguments(tag, names, references) {
        classCallCheck(this, CapturedNamedArguments);

        this.tag = tag;
        this.names = names;
        this.references = references;
        this.length = names.length;
        this._map = null;
    }

    CapturedNamedArguments.prototype.has = function has(name) {
        return this.names.indexOf(name) !== -1;
    };

    CapturedNamedArguments.prototype.get = function get$$1(name) {
        var names = this.names,
            references = this.references;

        var idx = names.indexOf(name);
        if (idx === -1) {
            return UNDEFINED_REFERENCE;
        } else {
            return references[idx];
        }
    };

    CapturedNamedArguments.prototype.value = function value() {
        var names = this.names,
            references = this.references;

        var out = dict();
        for (var i = 0; i < names.length; i++) {
            var name = names[i];
            out[name] = references[i].value();
        }
        return out;
    };

    createClass(CapturedNamedArguments, [{
        key: 'map',
        get: function get$$1() {
            var map$$1 = this._map;
            if (!map$$1) {
                var names = this.names,
                    references = this.references;

                map$$1 = this._map = dict();
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    map$$1[name] = references[i];
                }
            }
            return map$$1;
        }
    }]);
    return CapturedNamedArguments;
}();
var BlockArguments = function () {
    function BlockArguments() {
        classCallCheck(this, BlockArguments);

        this.internalValues = null;
        this.internalTag = null;
        this.names = EMPTY_ARRAY;
        this.length = 0;
        this.base = 0;
    }

    BlockArguments.prototype.setup = function setup(stack, base, length, names) {
        this.stack = stack;
        this.names = names;
        this.base = base;
        this.length = length;
        if (length === 0) {
            this.internalTag = CONSTANT_TAG;
            this.internalValues = EMPTY_ARRAY;
        } else {
            this.internalTag = null;
            this.internalValues = null;
        }
    };

    BlockArguments.prototype.has = function has(name) {
        return this.names.indexOf(name) !== -1;
    };

    BlockArguments.prototype.get = function get$$1(name) {
        var base = this.base,
            stack = this.stack,
            names = this.names;

        var idx = names.indexOf(name);
        if (names.indexOf(name) === -1) {
            return null;
        }
        var table = stack.get(idx * 3, base);
        var scope = stack.get(idx * 3 + 1, base); // FIXME(mmun): shouldn't need to cast this
        var handle = stack.get(idx * 3 + 2, base);
        return handle === null ? null : [handle, scope, table];
    };

    BlockArguments.prototype.capture = function capture() {
        return new CapturedBlockArguments(this.names, this.values);
    };

    createClass(BlockArguments, [{
        key: 'values',
        get: function get$$1() {
            var values = this.internalValues;
            if (!values) {
                var base = this.base,
                    length = this.length,
                    stack = this.stack;

                values = this.internalValues = stack.sliceArray(base, base + length * 3);
            }
            return values;
        }
    }]);
    return BlockArguments;
}();

var CapturedBlockArguments = function () {
    function CapturedBlockArguments(names, values) {
        classCallCheck(this, CapturedBlockArguments);

        this.names = names;
        this.values = values;
        this.length = names.length;
    }

    CapturedBlockArguments.prototype.has = function has(name) {
        return this.names.indexOf(name) !== -1;
    };

    CapturedBlockArguments.prototype.get = function get$$1(name) {
        var idx = this.names.indexOf(name);
        if (idx === -1) return null;
        return [this.values[idx * 3 + 2], this.values[idx * 3 + 1], this.values[idx * 3]];
    };

    return CapturedBlockArguments;
}();

var EMPTY_NAMED = new CapturedNamedArguments(CONSTANT_TAG, EMPTY_ARRAY, EMPTY_ARRAY);
var EMPTY_POSITIONAL = new CapturedPositionalArguments(CONSTANT_TAG, EMPTY_ARRAY);
var EMPTY_ARGS = { tag: CONSTANT_TAG, length: 0, positional: EMPTY_POSITIONAL, named: EMPTY_NAMED };

var CURRIED_COMPONENT_DEFINITION_BRAND = 'CURRIED COMPONENT DEFINITION [id=6f00feb9-a0ef-4547-99ea-ac328f80acea]';
function isCurriedComponentDefinition(definition) {
    return !!(definition && definition[CURRIED_COMPONENT_DEFINITION_BRAND]);
}

var CurriedComponentDefinition = function () {
    /** @internal */
    function CurriedComponentDefinition(inner, args) {
        classCallCheck(this, CurriedComponentDefinition);

        this.inner = inner;
        this.args = args;
        this[CURRIED_COMPONENT_DEFINITION_BRAND] = true;
    }

    CurriedComponentDefinition.prototype.unwrap = function unwrap(args) {
        args.realloc(this.offset);
        var definition = this;
        while (true) {
            var _definition = definition,
                curriedArgs = _definition.args,
                inner = _definition.inner;

            if (curriedArgs) {
                args.positional.prepend(curriedArgs.positional);
                args.named.merge(curriedArgs.named);
            }
            if (!isCurriedComponentDefinition(inner)) {
                return inner;
            }
            definition = inner;
        }
    };
    /** @internal */


    createClass(CurriedComponentDefinition, [{
        key: 'offset',
        get: function get$$1() {
            var inner = this.inner,
                args = this.args;

            var length = args ? args.positional.length : 0;
            return isCurriedComponentDefinition(inner) ? length + inner.offset : length;
        }
    }]);
    return CurriedComponentDefinition;
}();

var IsCurriedComponentDefinitionReference = function (_ConditionalReference) {
    inherits(IsCurriedComponentDefinitionReference, _ConditionalReference);

    function IsCurriedComponentDefinitionReference() {
        classCallCheck(this, IsCurriedComponentDefinitionReference);
        return possibleConstructorReturn(this, _ConditionalReference.apply(this, arguments));
    }

    IsCurriedComponentDefinitionReference.create = function create(inner) {
        return new IsCurriedComponentDefinitionReference(inner);
    };

    IsCurriedComponentDefinitionReference.prototype.toBool = function toBool(value) {
        return isCurriedComponentDefinition(value);
    };

    return IsCurriedComponentDefinitionReference;
}(ConditionalReference$1);
APPEND_OPCODES.add(24 /* DynamicContent */, function (vm) {
    var reference = vm.stack.pop();
    var isTrusting = vm.fetchValue(Register.t0);
    var value = reference.value();
    var content = void 0;
    if (isTrusting) {
        content = vm.elements().appendTrustingDynamicContent(value);
    } else {
        content = vm.elements().appendCautiousDynamicContent(value);
    }
    if (!isConst(reference)) {
        vm.updateWith(new UpdateDynamicContentOpcode(reference, content));
    }
    vm.loadValue(Register.t0, null);
});

var UpdateDynamicContentOpcode = function (_UpdatingOpcode) {
    inherits(UpdateDynamicContentOpcode, _UpdatingOpcode);

    function UpdateDynamicContentOpcode(reference, content) {
        classCallCheck(this, UpdateDynamicContentOpcode);

        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this2.reference = reference;
        _this2.content = content;
        _this2.tag = reference.tag;
        return _this2;
    }

    UpdateDynamicContentOpcode.prototype.evaluate = function evaluate(vm) {
        var content = this.content,
            reference = this.reference;

        content.update(vm.env, reference.value());
    };

    return UpdateDynamicContentOpcode;
}(UpdatingOpcode);

APPEND_OPCODES.add(18 /* ChildScope */, function (vm) {
    return vm.pushChildScope();
});
APPEND_OPCODES.add(19 /* PopScope */, function (vm) {
    return vm.popScope();
});
APPEND_OPCODES.add(36 /* PushDynamicScope */, function (vm) {
    return vm.pushDynamicScope();
});
APPEND_OPCODES.add(37 /* PopDynamicScope */, function (vm) {
    return vm.popDynamicScope();
});
APPEND_OPCODES.add(10 /* Constant */, function (vm, _ref) {
    var other = _ref.op1;

    vm.stack.push(vm.constants.getOther(other));
});
APPEND_OPCODES.add(11 /* Primitive */, function (vm, _ref2) {
    var primitive = _ref2.op1;

    var stack = vm.stack;
    var flag = primitive & 7; // 111
    var value = primitive >> 3;
    switch (flag) {
        case 0 /* NUMBER */:
            stack.push(value);
            break;
        case 1 /* FLOAT */:
            stack.push(vm.constants.getFloat(value));
            break;
        case 2 /* STRING */:
            stack.push(vm.constants.getString(value));
            break;
        case 3 /* BOOLEAN_OR_VOID */:
            stack.pushEncodedImmediate(primitive);
            break;
        case 4 /* NEGATIVE */:
            stack.push(vm.constants.getNegative(value));
            break;
    }
});
APPEND_OPCODES.add(12 /* PrimitiveReference */, function (vm) {
    var stack = vm.stack;
    stack.push(PrimitiveReference.create(stack.pop()));
});
APPEND_OPCODES.add(13 /* Dup */, function (vm, _ref3) {
    var register = _ref3.op1,
        offset = _ref3.op2;

    var position = vm.fetchValue(register) - offset;
    vm.stack.dup(position);
});
APPEND_OPCODES.add(14 /* Pop */, function (vm, _ref4) {
    var count = _ref4.op1;

    vm.stack.pop(count);
});
APPEND_OPCODES.add(15 /* Load */, function (vm, _ref5) {
    var register = _ref5.op1;

    vm.load(register);
});
APPEND_OPCODES.add(16 /* Fetch */, function (vm, _ref6) {
    var register = _ref6.op1;

    vm.fetch(register);
});
APPEND_OPCODES.add(35 /* BindDynamicScope */, function (vm, _ref7) {
    var _names = _ref7.op1;

    var names = vm.constants.getArray(_names);
    vm.bindDynamicScope(names);
});
APPEND_OPCODES.add(49 /* Enter */, function (vm, _ref8) {
    var args = _ref8.op1;

    vm.enter(args);
});
APPEND_OPCODES.add(50 /* Exit */, function (vm) {
    vm.exit();
});
APPEND_OPCODES.add(40 /* PushSymbolTable */, function (vm, _ref9) {
    var _table = _ref9.op1;

    var stack = vm.stack;
    stack.push(vm.constants.getSerializable(_table));
});
APPEND_OPCODES.add(39 /* PushBlockScope */, function (vm) {
    var stack = vm.stack;
    stack.push(vm.scope());
});
APPEND_OPCODES.add(38 /* CompileBlock */, function (vm) {
    var stack = vm.stack;
    var block = stack.pop();
    if (block) {
        stack.pushSmi(block.compile());
    } else {
        stack.pushNull();
    }
});
APPEND_OPCODES.add(43 /* InvokeYield */, function (vm) {
    var stack = vm.stack;

    var handle = stack.pop();
    var scope = stack.pop(); // FIXME(mmun): shouldn't need to cast this
    var table = stack.pop();
    false && debugAssert(table === null || table && (typeof table === 'undefined' ? 'undefined' : _typeof(table)) === 'object' && Array.isArray(table.parameters), stackAssert('Option<BlockSymbolTable>', table));

    var args = stack.pop();
    if (table === null) {
        // To balance the pop{Frame,Scope}
        vm.pushFrame();
        vm.pushScope(scope); // Could be null but it doesnt matter as it is immediatelly popped.
        return;
    }
    var invokingScope = scope;
    // If necessary, create a child scope
    {
        var locals = table.parameters;
        var localsCount = locals.length;
        if (localsCount > 0) {
            invokingScope = invokingScope.child();
            for (var i = 0; i < localsCount; i++) {
                invokingScope.bindSymbol(locals[i], args.at(i));
            }
        }
    }
    vm.pushFrame();
    vm.pushScope(invokingScope);
    vm.call(handle);
});
APPEND_OPCODES.add(45 /* JumpIf */, function (vm, _ref10) {
    var target = _ref10.op1;

    var reference = vm.stack.pop();
    if (isConst(reference)) {
        if (reference.value()) {
            vm.goto(target);
        }
    } else {
        var cache = new ReferenceCache(reference);
        if (cache.peek()) {
            vm.goto(target);
        }
        vm.updateWith(new Assert(cache));
    }
});
APPEND_OPCODES.add(46 /* JumpUnless */, function (vm, _ref11) {
    var target = _ref11.op1;

    var reference = vm.stack.pop();
    if (isConst(reference)) {
        if (!reference.value()) {
            vm.goto(target);
        }
    } else {
        var cache = new ReferenceCache(reference);
        if (!cache.peek()) {
            vm.goto(target);
        }
        vm.updateWith(new Assert(cache));
    }
});
APPEND_OPCODES.add(51 /* ToBoolean */, function (vm) {
    var env = vm.env,
        stack = vm.stack;

    stack.push(env.toConditionalReference(stack.pop()));
});
var Assert = function (_UpdatingOpcode) {
    inherits(Assert, _UpdatingOpcode);

    function Assert(cache) {
        classCallCheck(this, Assert);

        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.type = 'assert';
        _this.tag = cache.tag;
        _this.cache = cache;
        return _this;
    }

    Assert.prototype.evaluate = function evaluate(vm) {
        var cache = this.cache;

        if (isModified(cache.revalidate())) {
            vm.throw();
        }
    };

    return Assert;
}(UpdatingOpcode);
var JumpIfNotModifiedOpcode = function (_UpdatingOpcode2) {
    inherits(JumpIfNotModifiedOpcode, _UpdatingOpcode2);

    function JumpIfNotModifiedOpcode(tag, target) {
        classCallCheck(this, JumpIfNotModifiedOpcode);

        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));

        _this2.target = target;
        _this2.type = 'jump-if-not-modified';
        _this2.tag = tag;
        _this2.lastRevision = tag.value();
        return _this2;
    }

    JumpIfNotModifiedOpcode.prototype.evaluate = function evaluate(vm) {
        var tag = this.tag,
            target = this.target,
            lastRevision = this.lastRevision;

        if (!vm.alwaysRevalidate && tag.validate(lastRevision)) {
            vm.goto(target);
        }
    };

    JumpIfNotModifiedOpcode.prototype.didModify = function didModify() {
        this.lastRevision = this.tag.value();
    };

    return JumpIfNotModifiedOpcode;
}(UpdatingOpcode);
var DidModifyOpcode = function (_UpdatingOpcode3) {
    inherits(DidModifyOpcode, _UpdatingOpcode3);

    function DidModifyOpcode(target) {
        classCallCheck(this, DidModifyOpcode);

        var _this3 = possibleConstructorReturn(this, _UpdatingOpcode3.call(this));

        _this3.target = target;
        _this3.type = 'did-modify';
        _this3.tag = CONSTANT_TAG;
        return _this3;
    }

    DidModifyOpcode.prototype.evaluate = function evaluate() {
        this.target.didModify();
    };

    return DidModifyOpcode;
}(UpdatingOpcode);
var LabelOpcode = function () {
    function LabelOpcode(label) {
        classCallCheck(this, LabelOpcode);

        this.tag = CONSTANT_TAG;
        this.type = 'label';
        this.label = null;
        this.prev = null;
        this.next = null;
        initializeGuid(this);
        this.label = label;
    }

    LabelOpcode.prototype.evaluate = function evaluate() {};

    LabelOpcode.prototype.inspect = function inspect() {
        return this.label + ' [' + this._guid + ']';
    };

    return LabelOpcode;
}();

APPEND_OPCODES.add(22 /* Text */, function (vm, _ref) {
    var text = _ref.op1;

    vm.elements().appendText(vm.constants.getString(text));
});
APPEND_OPCODES.add(23 /* Comment */, function (vm, _ref2) {
    var text = _ref2.op1;

    vm.elements().appendComment(vm.constants.getString(text));
});
APPEND_OPCODES.add(25 /* OpenElement */, function (vm, _ref3) {
    var tag = _ref3.op1;

    vm.elements().openElement(vm.constants.getString(tag));
});
APPEND_OPCODES.add(26 /* OpenDynamicElement */, function (vm) {
    var tagName = vm.stack.pop().value();
    vm.elements().openElement(tagName);
});
APPEND_OPCODES.add(33 /* PushRemoteElement */, function (vm) {
    var elementRef = vm.stack.pop();
    var nextSiblingRef = vm.stack.pop();
    var guidRef = vm.stack.pop();
    var element = void 0;
    var nextSibling = void 0;
    var guid = guidRef.value();
    if (isConst(elementRef)) {
        element = elementRef.value();
    } else {
        var cache = new ReferenceCache(elementRef);
        element = cache.peek();
        vm.updateWith(new Assert(cache));
    }
    if (isConst(nextSiblingRef)) {
        nextSibling = nextSiblingRef.value();
    } else {
        var _cache = new ReferenceCache(nextSiblingRef);
        nextSibling = _cache.peek();
        vm.updateWith(new Assert(_cache));
    }
    vm.elements().pushRemoteElement(element, guid, nextSibling);
});
APPEND_OPCODES.add(34 /* PopRemoteElement */, function (vm) {
    vm.elements().popRemoteElement();
});
APPEND_OPCODES.add(30 /* FlushElement */, function (vm) {
    var operations = vm.fetchValue(Register.t0);
    if (operations) {
        operations.flush(vm);
        vm.loadValue(Register.t0, null);
    }
    vm.elements().flushElement();
});
APPEND_OPCODES.add(31 /* CloseElement */, function (vm) {
    vm.elements().closeElement();
});
APPEND_OPCODES.add(32 /* Modifier */, function (vm, _ref4) {
    var handle = _ref4.op1;

    var manager = vm.constants.resolveHandle(handle);
    var stack = vm.stack;
    var args = stack.pop();

    var _vm$elements = vm.elements(),
        element = _vm$elements.constructing,
        updateOperations = _vm$elements.updateOperations;

    var dynamicScope = vm.dynamicScope();
    var modifier = manager.create(element, args, dynamicScope, updateOperations);
    vm.env.scheduleInstallModifier(modifier, manager);
    var destructor = manager.getDestructor(modifier);
    if (destructor) {
        vm.newDestroyable(destructor);
    }
    var tag = manager.getTag(modifier);
    if (!isConstTag(tag)) {
        vm.updateWith(new UpdateModifierOpcode(tag, manager, modifier));
    }
});
var UpdateModifierOpcode = function (_UpdatingOpcode) {
    inherits(UpdateModifierOpcode, _UpdatingOpcode);

    function UpdateModifierOpcode(tag, manager, modifier) {
        classCallCheck(this, UpdateModifierOpcode);

        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.tag = tag;
        _this.manager = manager;
        _this.modifier = modifier;
        _this.type = 'update-modifier';
        _this.lastUpdated = tag.value();
        return _this;
    }

    UpdateModifierOpcode.prototype.evaluate = function evaluate(vm) {
        var manager = this.manager,
            modifier = this.modifier,
            tag = this.tag,
            lastUpdated = this.lastUpdated;

        if (!tag.validate(lastUpdated)) {
            vm.env.scheduleUpdateModifier(modifier, manager);
            this.lastUpdated = tag.value();
        }
    };

    return UpdateModifierOpcode;
}(UpdatingOpcode);
APPEND_OPCODES.add(27 /* StaticAttr */, function (vm, _ref5) {
    var _name = _ref5.op1,
        _value = _ref5.op2,
        _namespace = _ref5.op3;

    var name = vm.constants.getString(_name);
    var value = vm.constants.getString(_value);
    var namespace = _namespace ? vm.constants.getString(_namespace) : null;
    vm.elements().setStaticAttribute(name, value, namespace);
});
APPEND_OPCODES.add(28 /* DynamicAttr */, function (vm, _ref6) {
    var _name = _ref6.op1,
        trusting = _ref6.op2,
        _namespace = _ref6.op3;

    var name = vm.constants.getString(_name);
    var reference = vm.stack.pop();
    var value = reference.value();
    var namespace = _namespace ? vm.constants.getString(_namespace) : null;
    var attribute = vm.elements().setDynamicAttribute(name, value, !!trusting, namespace);
    if (!isConst(reference)) {
        vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));
    }
});
var UpdateDynamicAttributeOpcode = function (_UpdatingOpcode2) {
    inherits(UpdateDynamicAttributeOpcode, _UpdatingOpcode2);

    function UpdateDynamicAttributeOpcode(reference, attribute) {
        classCallCheck(this, UpdateDynamicAttributeOpcode);

        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));

        _this2.reference = reference;
        _this2.attribute = attribute;
        _this2.type = 'patch-element';
        _this2.tag = reference.tag;
        _this2.lastRevision = _this2.tag.value();
        return _this2;
    }

    UpdateDynamicAttributeOpcode.prototype.evaluate = function evaluate(vm) {
        var attribute = this.attribute,
            reference = this.reference,
            tag = this.tag;

        if (!tag.validate(this.lastRevision)) {
            this.lastRevision = tag.value();
            attribute.update(reference.value(), vm.env);
        }
    };

    return UpdateDynamicAttributeOpcode;
}(UpdatingOpcode);

function resolveComponent(resolver, name, meta) {
    var definition = resolver.lookupComponent(name, meta);
    false && debugAssert(definition, 'Could not find a component named "' + name + '"');

    return definition;
}

var CurryComponentReference = function () {
    function CurryComponentReference(inner, resolver, meta, args) {
        classCallCheck(this, CurryComponentReference);

        this.inner = inner;
        this.resolver = resolver;
        this.meta = meta;
        this.args = args;
        this.tag = inner.tag;
        this.lastValue = null;
        this.lastDefinition = null;
    }

    CurryComponentReference.prototype.value = function value() {
        var inner = this.inner,
            lastValue = this.lastValue;

        var value = inner.value();
        if (value === lastValue) {
            return this.lastDefinition;
        }
        var definition = null;
        if (isCurriedComponentDefinition(value)) {
            definition = value;
        } else if (typeof value === 'string' && value) {
            var resolver = this.resolver,
                meta = this.meta;

            definition = resolveComponent(resolver, value, meta);
        }
        definition = this.curry(definition);
        this.lastValue = value;
        this.lastDefinition = definition;
        return definition;
    };

    CurryComponentReference.prototype.get = function get$$1() {
        return UNDEFINED_REFERENCE;
    };

    CurryComponentReference.prototype.curry = function curry$$1(definition) {
        var args = this.args;

        if (!args && isCurriedComponentDefinition(definition)) {
            return definition;
        } else if (!definition) {
            return null;
        } else {
            return new CurriedComponentDefinition(definition, args);
        }
    };

    return CurryComponentReference;
}();

function normalizeStringValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    return String(value);
}
function normalizeTrustedValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (isString(value)) {
        return value;
    }
    if (isSafeString(value)) {
        return value.toHTML();
    }
    if (isNode(value)) {
        return value;
    }
    return String(value);
}
function isEmpty(value) {
    return value === null || value === undefined || typeof value.toString !== 'function';
}
function isSafeString(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && typeof value.toHTML === 'function';
}
function isNode(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && typeof value.nodeType === 'number';
}
function isFragment(value) {
    return isNode(value) && value.nodeType === 11;
}
function isString(value) {
    return typeof value === 'string';
}

var ClassListReference = function () {
    function ClassListReference(list) {
        classCallCheck(this, ClassListReference);

        this.list = list;
        this.tag = combineTagged(list);
        this.list = list;
    }

    ClassListReference.prototype.value = function value() {
        var ret = [];
        var list = this.list;

        for (var i = 0; i < list.length; i++) {
            var value = normalizeStringValue(list[i].value());
            if (value) ret.push(value);
        }
        return ret.length === 0 ? null : ret.join(' ');
    };

    return ClassListReference;
}();

/**
 * Converts a ComponentCapabilities object into a 32-bit integer representation.
 */
function capabilityFlagsFrom(capabilities) {
    return 0 | (capabilities.dynamicLayout ? 1 /* DynamicLayout */ : 0) | (capabilities.dynamicTag ? 2 /* DynamicTag */ : 0) | (capabilities.prepareArgs ? 4 /* PrepareArgs */ : 0) | (capabilities.createArgs ? 8 /* CreateArgs */ : 0) | (capabilities.attributeHook ? 16 /* AttributeHook */ : 0) | (capabilities.elementHook ? 32 /* ElementHook */ : 0);
}
function hasCapability(capabilities, capability) {
    return !!(capabilities & capability);
}

var ARGS = new Arguments();
APPEND_OPCODES.add(57 /* IsComponent */, function (vm) {
    var stack = vm.stack;
    var ref = stack.pop();
    stack.push(IsCurriedComponentDefinitionReference.create(ref));
});
APPEND_OPCODES.add(58 /* CurryComponent */, function (vm, _ref) {
    var _meta = _ref.op1;

    var stack = vm.stack;
    var definition = stack.pop();
    var capturedArgs = stack.pop();
    var meta = vm.constants.getSerializable(_meta);
    var resolver = vm.constants.resolver;
    vm.loadValue(Register.v0, new CurryComponentReference(definition, resolver, meta, capturedArgs));
    // expectStackChange(vm.stack, -args.length - 1, 'CurryComponent');
});
APPEND_OPCODES.add(59 /* PushComponentDefinition */, function (vm, _ref2) {
    var handle = _ref2.op1;

    var definition = vm.constants.resolveHandle(handle);
    false && debugAssert(!!definition, 'Missing component for ' + handle);

    var manager = definition.manager;

    var capabilities = capabilityFlagsFrom(manager.getCapabilities(definition.state));
    var instance = {
        definition: definition,
        manager: manager,
        capabilities: capabilities,
        state: null,
        handle: null,
        table: null
    };
    vm.stack.push(instance);
});
APPEND_OPCODES.add(62 /* ResolveDynamicComponent */, function (vm, _ref3) {
    var _meta = _ref3.op1;

    var stack = vm.stack;
    var component = stack.pop().value();
    var meta = vm.constants.getSerializable(_meta);
    vm.loadValue(Register.t1, null); // Clear the temp register
    var definition = void 0;
    if (typeof component === 'string') {
        var resolver = vm.constants.resolver;

        var resolvedDefinition = resolveComponent(resolver, component, meta);
        definition = resolvedDefinition;
    } else if (isCurriedComponentDefinition(component)) {
        definition = component;
    } else {
        throw unreachable();
    }
    stack.push(definition);
});
APPEND_OPCODES.add(60 /* PushDynamicComponentInstance */, function (vm) {
    var stack = vm.stack;

    var definition = stack.pop();
    var capabilities = void 0,
        manager = void 0;
    if (isCurriedComponentDefinition(definition)) {
        manager = capabilities = null;
    } else {
        manager = definition.manager;
        capabilities = capabilityFlagsFrom(manager.getCapabilities(definition.state));
    }
    stack.push({ definition: definition, capabilities: capabilities, manager: manager, state: null, handle: null, table: null });
});
APPEND_OPCODES.add(61 /* PushCurriedComponent */, function (vm, _ref4) {
    var _meta = _ref4.op1;

    var stack = vm.stack;
    var component = stack.pop().value();
    var definition = void 0;
    if (isCurriedComponentDefinition(component)) {
        definition = component;
    } else {
        throw unreachable();
    }
    stack.push(definition);
});
APPEND_OPCODES.add(63 /* PushArgs */, function (vm, _ref5) {
    var _names = _ref5.op1,
        flags = _ref5.op2;

    var stack = vm.stack;
    var names = vm.constants.getStringArray(_names);
    var positionalCount = flags >> 4;
    var synthetic = flags & 8;
    var blockNames = [];
    if (flags & 4) blockNames.push('main');
    if (flags & 2) blockNames.push('else');
    if (flags & 1) blockNames.push('attrs');
    ARGS.setup(stack, names, blockNames, positionalCount, !!synthetic);
    stack.push(ARGS);
});
APPEND_OPCODES.add(66 /* CaptureArgs */, function (vm) {
    var stack = vm.stack;
    var args = stack.pop();
    var capturedArgs = args.capture();
    stack.push(capturedArgs);
});
APPEND_OPCODES.add(65 /* PrepareArgs */, function (vm, _ref6) {
    var _state = _ref6.op1;

    var stack = vm.stack;
    var instance = vm.fetchValue(_state);
    var args = stack.pop();
    var definition = instance.definition;

    if (isCurriedComponentDefinition(definition)) {
        false && debugAssert(!definition.manager, "If the component definition was curried, we don't yet have a manager");

        definition = resolveCurriedComponentDefinition(instance, definition, args);
    }
    var _definition = definition,
        manager = _definition.manager,
        state = _definition.state;

    var capabilities = instance.capabilities;
    if (hasCapability(capabilities, 4 /* PrepareArgs */) !== true) {
        stack.push(args);
        return;
    }
    var blocks = args.blocks.values;
    var blockNames = args.blocks.names;
    var preparedArgs = manager.prepareArgs(state, args);
    if (preparedArgs) {
        args.clear();
        for (var i = 0; i < blocks.length; i++) {
            stack.push(blocks[i]);
        }
        var positional = preparedArgs.positional,
            named = preparedArgs.named;

        var positionalCount = positional.length;
        for (var _i = 0; _i < positionalCount; _i++) {
            stack.push(positional[_i]);
        }
        var names = Object.keys(named);
        for (var _i2 = 0; _i2 < names.length; _i2++) {
            stack.push(named[names[_i2]]);
        }
        args.setup(stack, names, blockNames, positionalCount, true);
    }
    stack.push(args);
});
function resolveCurriedComponentDefinition(instance, definition, args) {
    var unwrappedDefinition = instance.definition = definition.unwrap(args);
    var manager = unwrappedDefinition.manager,
        state = unwrappedDefinition.state;

    false && debugAssert(instance.manager === null, "component instance manager should not be populated yet");
    false && debugAssert(instance.capabilities === null, "component instance manager should not be populated yet");

    instance.manager = manager;
    instance.capabilities = capabilityFlagsFrom(manager.getCapabilities(state));
    return unwrappedDefinition;
}
APPEND_OPCODES.add(67 /* CreateComponent */, function (vm, _ref7) {
    var flags = _ref7.op1,
        _state = _ref7.op2;

    var dynamicScope = vm.dynamicScope();
    var instance = vm.fetchValue(_state);
    var definition = instance.definition,
        manager = instance.manager;

    var capabilities = instance.capabilities = capabilityFlagsFrom(manager.getCapabilities(definition.state));
    var hasDefaultBlock = flags & 1;
    var args = null;
    if (hasCapability(capabilities, 8 /* CreateArgs */)) {
        args = vm.stack.peek();
    }
    var state = manager.create(vm.env, definition.state, args, dynamicScope, vm.getSelf(), !!hasDefaultBlock);
    // We want to reuse the `state` POJO here, because we know that the opcodes
    // only transition at exactly one place.
    instance.state = state;
    var tag = manager.getTag(state);
    if (!isConstTag(tag)) {
        vm.updateWith(new UpdateComponentOpcode(tag, state, manager, dynamicScope));
    }
});
APPEND_OPCODES.add(68 /* RegisterComponentDestructor */, function (vm, _ref8) {
    var _state = _ref8.op1;

    var _vm$fetchValue = vm.fetchValue(_state),
        manager = _vm$fetchValue.manager,
        state = _vm$fetchValue.state;

    var destructor = manager.getDestructor(state);
    if (destructor) vm.newDestroyable(destructor);
});
APPEND_OPCODES.add(75 /* BeginComponentTransaction */, function (vm) {
    vm.beginCacheGroup();
    vm.elements().pushSimpleBlock();
});
APPEND_OPCODES.add(69 /* PutComponentOperations */, function (vm) {
    vm.loadValue(Register.t0, new ComponentElementOperations());
});
APPEND_OPCODES.add(29 /* ComponentAttr */, function (vm, _ref9) {
    var _name = _ref9.op1,
        trusting = _ref9.op2,
        _namespace = _ref9.op3;

    var name = vm.constants.getString(_name);
    var reference = vm.stack.pop();
    var namespace = _namespace ? vm.constants.getString(_namespace) : null;
    vm.fetchValue(Register.t0).setAttribute(name, reference, !!trusting, namespace);
});
var ComponentElementOperations = function () {
    function ComponentElementOperations() {
        classCallCheck(this, ComponentElementOperations);

        this.attributes = dict();
        this.classes = [];
    }

    ComponentElementOperations.prototype.setAttribute = function setAttribute(name, value, trusting, namespace) {
        var deferred = { value: value, namespace: namespace, trusting: trusting };
        if (name === 'class') {
            this.classes.push(value);
        }
        this.attributes[name] = deferred;
    };

    ComponentElementOperations.prototype.flush = function flush(vm) {
        for (var name in this.attributes) {
            var attr = this.attributes[name];
            var reference = attr.value,
                namespace = attr.namespace,
                trusting = attr.trusting;

            if (name === 'class') {
                reference = new ClassListReference(this.classes);
            }
            var attribute = vm.elements().setDynamicAttribute(name, reference.value(), trusting, namespace);
            if (!isConst(reference)) {
                vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));
            }
        }
    };

    return ComponentElementOperations;
}();
APPEND_OPCODES.add(77 /* DidCreateElement */, function (vm, _ref10) {
    var _state = _ref10.op1;

    var _vm$fetchValue2 = vm.fetchValue(_state),
        definition = _vm$fetchValue2.definition,
        state = _vm$fetchValue2.state;

    var manager = definition.manager;

    var operations = vm.fetchValue(Register.t0);
    var action = 'DidCreateElementOpcode#evaluate';
    manager.didCreateElement(state, vm.elements().expectConstructing(action), operations);
});
APPEND_OPCODES.add(70 /* GetComponentSelf */, function (vm, _ref11) {
    var _state = _ref11.op1;

    var _vm$fetchValue3 = vm.fetchValue(_state),
        definition = _vm$fetchValue3.definition,
        state = _vm$fetchValue3.state;

    var manager = definition.manager;

    vm.stack.push(manager.getSelf(state));
});
APPEND_OPCODES.add(71 /* GetComponentTagName */, function (vm, _ref12) {
    var _state = _ref12.op1;

    var _vm$fetchValue4 = vm.fetchValue(_state),
        definition = _vm$fetchValue4.definition,
        state = _vm$fetchValue4.state;

    var manager = definition.manager;

    vm.stack.push(manager.getTagName(state));
});
// Dynamic Invocation Only
APPEND_OPCODES.add(72 /* GetComponentLayout */, function (vm, _ref13) {
    var _state = _ref13.op1;

    var instance = vm.fetchValue(_state);
    var manager = instance.manager,
        definition = instance.definition;
    var resolver = vm.constants.resolver,
        stack = vm.stack;
    var instanceState = instance.state,
        capabilities = instance.capabilities;
    var definitionState = definition.state;

    var invoke = void 0;
    if (hasStaticLayout(capabilities, manager)) {
        invoke = manager.getLayout(definitionState, resolver);
    } else if (hasDynamicLayout(capabilities, manager)) {
        invoke = manager.getDynamicLayout(instanceState, resolver);
    } else {
        throw unreachable();
    }
    stack.push(invoke.symbolTable);
    stack.push(invoke.handle);
});
function hasStaticLayout(capabilities, _manager) {
    return hasCapability(capabilities, 1 /* DynamicLayout */) === false;
}
function hasDynamicLayout(capabilities, _manager) {
    return hasCapability(capabilities, 1 /* DynamicLayout */) === true;
}
APPEND_OPCODES.add(56 /* Main */, function (vm, _ref14) {
    var register = _ref14.op1;

    var definition = vm.stack.pop();
    var invocation = vm.stack.pop();
    var manager = definition.manager;

    var capabilities = capabilityFlagsFrom(manager.getCapabilities(definition.state));
    var state = {
        definition: definition,
        manager: manager,
        capabilities: capabilities,
        state: null,
        handle: invocation.handle,
        table: invocation.symbolTable
    };
    vm.loadValue(register, state);
});
APPEND_OPCODES.add(73 /* PopulateLayout */, function (vm, _ref15) {
    var _state = _ref15.op1;
    var stack = vm.stack;

    var handle = stack.pop();
    var table = stack.pop();
    var state = vm.fetchValue(_state);
    state.handle = handle;
    state.table = table;
});
// Dynamic Invocation Only
APPEND_OPCODES.add(74 /* InvokeComponentLayout */, function (vm, _ref16) {
    var _state = _ref16.op1;
    var stack = vm.stack;

    var _vm$fetchValue5 = vm.fetchValue(_state),
        handle = _vm$fetchValue5.handle,
        _vm$fetchValue5$table = _vm$fetchValue5.table,
        symbols = _vm$fetchValue5$table.symbols,
        hasEval = _vm$fetchValue5$table.hasEval;

    {
        var self = stack.pop();
        var scope = vm.pushRootScope(symbols.length + 1, true);
        scope.bindSelf(self);
        var args = vm.stack.pop();
        var lookup = null;
        if (hasEval) {
            lookup = dict();
        }
        var callerNames = args.named.atNames;
        for (var i = callerNames.length - 1; i >= 0; i--) {
            var atName = callerNames[i];
            var symbol = symbols.indexOf(callerNames[i]);
            var value = args.named.get(atName, false);
            if (symbol !== -1) scope.bindSymbol(symbol + 1, value);
            if (hasEval) lookup[atName] = value;
        }
        var bindBlock = function bindBlock(symbolName, blockName) {
            var symbol = symbols.indexOf(symbolName);
            var block = blocks.get(blockName);
            if (symbol !== -1) {
                scope.bindBlock(symbol + 1, block);
            }
            if (lookup) lookup[symbolName] = block;
        };
        var blocks = args.blocks;
        bindBlock(ATTRS_BLOCK, 'attrs');
        bindBlock('&inverse', 'else');
        bindBlock('&default', 'main');
        if (lookup) scope.bindEvalScope(lookup);
        vm.call(handle);
    }
});
APPEND_OPCODES.add(78 /* DidRenderLayout */, function (vm, _ref17) {
    var _state = _ref17.op1;

    var _vm$fetchValue6 = vm.fetchValue(_state),
        manager = _vm$fetchValue6.manager,
        state = _vm$fetchValue6.state;

    var bounds = vm.elements().popBlock();
    var mgr = manager;
    mgr.didRenderLayout(state, bounds);
    vm.env.didCreate(state, manager);
    vm.updateWith(new DidUpdateLayoutOpcode(manager, state, bounds));
});
APPEND_OPCODES.add(76 /* CommitComponentTransaction */, function (vm) {
    vm.commitCacheGroup();
});
var UpdateComponentOpcode = function (_UpdatingOpcode) {
    inherits(UpdateComponentOpcode, _UpdatingOpcode);

    function UpdateComponentOpcode(tag, component, manager, dynamicScope) {
        classCallCheck(this, UpdateComponentOpcode);

        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.tag = tag;
        _this.component = component;
        _this.manager = manager;
        _this.dynamicScope = dynamicScope;
        _this.type = 'update-component';
        return _this;
    }

    UpdateComponentOpcode.prototype.evaluate = function evaluate(_vm) {
        var component = this.component,
            manager = this.manager,
            dynamicScope = this.dynamicScope;

        manager.update(component, dynamicScope);
    };

    return UpdateComponentOpcode;
}(UpdatingOpcode);
var DidUpdateLayoutOpcode = function (_UpdatingOpcode2) {
    inherits(DidUpdateLayoutOpcode, _UpdatingOpcode2);

    function DidUpdateLayoutOpcode(manager, component, bounds) {
        classCallCheck(this, DidUpdateLayoutOpcode);

        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));

        _this2.manager = manager;
        _this2.component = component;
        _this2.bounds = bounds;
        _this2.type = 'did-update-layout';
        _this2.tag = CONSTANT_TAG;
        return _this2;
    }

    DidUpdateLayoutOpcode.prototype.evaluate = function evaluate(vm) {
        var manager = this.manager,
            component = this.component,
            bounds = this.bounds;

        manager.didUpdateLayout(component, bounds);
        vm.env.didUpdate(component, manager);
    };

    return DidUpdateLayoutOpcode;
}(UpdatingOpcode);

/* tslint:disable */
function debugCallback(context, get$$1) {
    console.info('Use `context`, and `get(<path>)` to debug this template.');
    // for example...
    context === get$$1('this');
    debugger;
}
/* tslint:enable */
var callback = debugCallback;
// For testing purposes



var ScopeInspector = function () {
    function ScopeInspector(scope, symbols, evalInfo) {
        classCallCheck(this, ScopeInspector);

        this.scope = scope;
        this.locals = dict();
        for (var i = 0; i < evalInfo.length; i++) {
            var slot = evalInfo[i];
            var name = symbols[slot - 1];
            var ref = scope.getSymbol(slot);
            this.locals[name] = ref;
        }
    }

    ScopeInspector.prototype.get = function get$$1(path) {
        var scope = this.scope,
            locals = this.locals;

        var parts = path.split('.');

        var _path$split = path.split('.'),
            head = _path$split[0],
            tail = _path$split.slice(1);

        var evalScope = scope.getEvalScope();
        var ref = void 0;
        if (head === 'this') {
            ref = scope.getSelf();
        } else if (locals[head]) {
            ref = locals[head];
        } else if (head.indexOf('@') === 0 && evalScope[head]) {
            ref = evalScope[head];
        } else {
            ref = this.scope.getSelf();
            tail = parts;
        }
        return tail.reduce(function (r, part) {
            return r.get(part);
        }, ref);
    };

    return ScopeInspector;
}();

APPEND_OPCODES.add(81 /* Debugger */, function (vm, _ref) {
    var _symbols = _ref.op1,
        _evalInfo = _ref.op2;

    var symbols = vm.constants.getStringArray(_symbols);
    var evalInfo = vm.constants.getArray(_evalInfo);
    var inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
    callback(vm.getSelf().value(), function (path) {
        return inspector.get(path).value();
    });
});

APPEND_OPCODES.add(79 /* InvokePartial */, function (vm, _ref) {
    var _meta = _ref.op1,
        _symbols = _ref.op2,
        _evalInfo = _ref.op3;
    var constants = vm.constants,
        resolver = vm.constants.resolver,
        stack = vm.stack;

    var name = stack.pop().value();
    false && debugAssert(typeof name === 'string', 'Could not find a partial named "' + String(name) + '"');

    var meta = constants.getSerializable(_meta);
    var outerSymbols = constants.getStringArray(_symbols);
    var evalInfo = constants.getArray(_evalInfo);
    var handle = resolver.lookupPartial(name, meta);
    false && debugAssert(handle, 'Could not find a partial named "' + name + '"');

    var definition = resolver.resolve(handle);

    var _definition$getPartia = definition.getPartial(),
        symbolTable = _definition$getPartia.symbolTable,
        vmHandle = _definition$getPartia.handle;

    {
        var partialSymbols = symbolTable.symbols;
        var outerScope = vm.scope();
        var partialScope = vm.pushRootScope(partialSymbols.length, false);
        var evalScope = outerScope.getEvalScope();
        partialScope.bindCallerScope(outerScope.getCallerScope());
        partialScope.bindEvalScope(evalScope);
        partialScope.bindSelf(outerScope.getSelf());
        var locals = Object.create(outerScope.getPartialMap());
        for (var i = 0; i < evalInfo.length; i++) {
            var slot = evalInfo[i];
            var _name = outerSymbols[slot - 1];
            var ref = outerScope.getSymbol(slot);
            locals[_name] = ref;
        }
        if (evalScope) {
            for (var _i = 0; _i < partialSymbols.length; _i++) {
                var _name2 = partialSymbols[_i];
                var symbol = _i + 1;
                var value = evalScope[_name2];
                if (value !== undefined) partialScope.bind(symbol, value);
            }
        }
        partialScope.bindPartialMap(locals);
        vm.pushFrame(); // sp += 2
        vm.call(vmHandle);
    }
});

var IterablePresenceReference = function () {
    function IterablePresenceReference(artifacts) {
        classCallCheck(this, IterablePresenceReference);

        this.tag = artifacts.tag;
        this.artifacts = artifacts;
    }

    IterablePresenceReference.prototype.value = function value() {
        return !this.artifacts.isEmpty();
    };

    return IterablePresenceReference;
}();

APPEND_OPCODES.add(54 /* PutIterator */, function (vm) {
    var stack = vm.stack;
    var listRef = stack.pop();
    var key = stack.pop();
    var iterable = vm.env.iterableFor(listRef, key.value());
    var iterator = new ReferenceIterator(iterable);
    stack.push(iterator);
    stack.push(new IterablePresenceReference(iterator.artifacts));
});
APPEND_OPCODES.add(52 /* EnterList */, function (vm, _ref) {
    var relativeStart = _ref.op1;

    vm.enterList(relativeStart);
});
APPEND_OPCODES.add(53 /* ExitList */, function (vm) {
    vm.exitList();
});
APPEND_OPCODES.add(55 /* Iterate */, function (vm, _ref2) {
    var breaks = _ref2.op1;

    var stack = vm.stack;
    var item = stack.peek().next();
    if (item) {
        var tryOpcode = vm.iterate(item.memo, item.value);
        vm.enterItem(item.key, tryOpcode);
    } else {
        vm.goto(breaks);
    }
});

var Cursor = function Cursor(element, nextSibling) {
    classCallCheck(this, Cursor);

    this.element = element;
    this.nextSibling = nextSibling;
};
var ConcreteBounds = function () {
    function ConcreteBounds(parentNode, first, last) {
        classCallCheck(this, ConcreteBounds);

        this.parentNode = parentNode;
        this.first = first;
        this.last = last;
    }

    ConcreteBounds.prototype.parentElement = function parentElement() {
        return this.parentNode;
    };

    ConcreteBounds.prototype.firstNode = function firstNode() {
        return this.first;
    };

    ConcreteBounds.prototype.lastNode = function lastNode() {
        return this.last;
    };

    return ConcreteBounds;
}();
var SingleNodeBounds = function () {
    function SingleNodeBounds(parentNode, node) {
        classCallCheck(this, SingleNodeBounds);

        this.parentNode = parentNode;
        this.node = node;
    }

    SingleNodeBounds.prototype.parentElement = function parentElement() {
        return this.parentNode;
    };

    SingleNodeBounds.prototype.firstNode = function firstNode() {
        return this.node;
    };

    SingleNodeBounds.prototype.lastNode = function lastNode() {
        return this.node;
    };

    return SingleNodeBounds;
}();
function bounds(parent, first, last) {
    return new ConcreteBounds(parent, first, last);
}
function single(parent, node) {
    return new SingleNodeBounds(parent, node);
}
function move(bounds, reference) {
    var parent = bounds.parentElement();
    var first = bounds.firstNode();
    var last = bounds.lastNode();
    var node = first;
    while (node) {
        var next = node.nextSibling;
        parent.insertBefore(node, reference);
        if (node === last) return next;
        node = next;
    }
    return null;
}
function clear(bounds) {
    var parent = bounds.parentElement();
    var first = bounds.firstNode();
    var last = bounds.lastNode();
    var node = first;
    while (node) {
        var next = node.nextSibling;
        parent.removeChild(node);
        if (node === last) return next;
        node = next;
    }
    return null;
}

var SVG_NAMESPACE$1 = 'http://www.w3.org/2000/svg';
// Patch:    insertAdjacentHTML on SVG Fix
// Browsers: Safari, IE, Edge, Firefox ~33-34
// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
//           present but throws an exception on IE and Edge. Old versions of
//           Firefox create nodes in the incorrect namespace.
// Fix:      Since IE and Edge silently fail to create SVG nodes using
//           innerHTML, and because Firefox may create nodes in the incorrect
//           namespace using innerHTML on SVG elements, an HTML-string wrapping
//           approach is used. A pre/post SVG tag is added to the string, then
//           that whole string is added to a div. The created nodes are plucked
//           out and applied to the target location on DOM.
function applySVGInnerHTMLFix(document, DOMClass, svgNamespace) {
    if (!document) return DOMClass;
    if (!shouldApplyFix(document, svgNamespace)) {
        return DOMClass;
    }
    var div = document.createElement('div');
    return function (_DOMClass) {
        inherits(DOMChangesWithSVGInnerHTMLFix, _DOMClass);

        function DOMChangesWithSVGInnerHTMLFix() {
            classCallCheck(this, DOMChangesWithSVGInnerHTMLFix);
            return possibleConstructorReturn(this, _DOMClass.apply(this, arguments));
        }

        DOMChangesWithSVGInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore$$1(parent, nextSibling, html) {
            if (html === null || html === '') {
                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            if (parent.namespaceURI !== svgNamespace) {
                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            return fixSVG(parent, div, html, nextSibling);
        };

        return DOMChangesWithSVGInnerHTMLFix;
    }(DOMClass);
}
function fixSVG(parent, div, html, reference) {
    // IE, Edge: also do not correctly support using `innerHTML` on SVG
    // namespaced elements. So here a wrapper is used.
    var wrappedHtml = '<svg>' + html + '</svg>';
    div.innerHTML = wrappedHtml;

    var _moveNodesBefore = moveNodesBefore(div.firstChild, parent, reference),
        first = _moveNodesBefore[0],
        last = _moveNodesBefore[1];

    return new ConcreteBounds(parent, first, last);
}
function shouldApplyFix(document, svgNamespace) {
    var svg = document.createElementNS(svgNamespace, 'svg');
    try {
        svg['insertAdjacentHTML']('beforeend', '<circle></circle>');
    } catch (e) {
        // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG
        // Safari: Will throw, insertAdjacentHTML is not present on SVG
    } finally {
        // FF: Old versions will create a node in the wrong namespace
        if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE$1) {
            // The test worked as expected, no fix required
            return false;
        }
        return true;
    }
}

// Patch:    Adjacent text node merging fix
// Browsers: IE, Edge, Firefox w/o inspector open
// Reason:   These browsers will merge adjacent text nodes. For exmaple given
//           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers
//           with proper behavior will populate div.childNodes with two items.
//           These browsers will populate it with one merged node instead.
// Fix:      Add these nodes to a wrapper element, then iterate the childNodes
//           of that wrapper and move the nodes to their target location. Note
//           that potential SVG bugs will have been handled before this fix.
//           Note that this fix must only apply to the previous text node, as
//           the base implementation of `insertHTMLBefore` already handles
//           following text nodes correctly.
function applyTextNodeMergingFix(document, DOMClass) {
    if (!document) return DOMClass;
    if (!shouldApplyFix$1(document)) {
        return DOMClass;
    }
    return function (_DOMClass) {
        inherits(DOMChangesWithTextNodeMergingFix, _DOMClass);

        function DOMChangesWithTextNodeMergingFix(document) {
            classCallCheck(this, DOMChangesWithTextNodeMergingFix);

            var _this = possibleConstructorReturn(this, _DOMClass.call(this, document));

            _this.uselessComment = document.createComment('');
            return _this;
        }

        DOMChangesWithTextNodeMergingFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
            if (html === null) {
                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            var didSetUselessComment = false;
            var nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;
            if (nextPrevious && nextPrevious instanceof Text) {
                didSetUselessComment = true;
                parent.insertBefore(this.uselessComment, nextSibling);
            }
            var bounds = _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            if (didSetUselessComment) {
                parent.removeChild(this.uselessComment);
            }
            return bounds;
        };

        return DOMChangesWithTextNodeMergingFix;
    }(DOMClass);
}
function shouldApplyFix$1(document) {
    var mergingTextDiv = document.createElement('div');
    mergingTextDiv.innerHTML = 'first';
    mergingTextDiv.insertAdjacentHTML('beforeend', 'second');
    if (mergingTextDiv.childNodes.length === 2) {
        // It worked as expected, no fix required
        return false;
    }
    return true;
}

var SVG_NAMESPACE$$1 = 'http://www.w3.org/2000/svg';
// http://www.w3.org/TR/html/syntax.html#html-integration-point
var SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };
// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
// TODO: Adjust SVG attributes
// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
// TODO: Adjust SVG elements
// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
var BLACKLIST_TABLE = Object.create(null);
["b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "main", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"].forEach(function (tag) {
    return BLACKLIST_TABLE[tag] = 1;
});
var doc = typeof document === 'undefined' ? null : document;

function moveNodesBefore(source, target, nextSibling) {
    var first = source.firstChild;
    var last = null;
    var current = first;
    while (current) {
        last = current;
        current = current.nextSibling;
        target.insertBefore(last, nextSibling);
    }
    return [first, last];
}
var DOMOperations = function () {
    function DOMOperations(document) {
        classCallCheck(this, DOMOperations);

        this.document = document;
        this.setupUselessElement();
    }
    // split into seperate method so that NodeDOMTreeConstruction
    // can override it.


    DOMOperations.prototype.setupUselessElement = function setupUselessElement() {
        this.uselessElement = this.document.createElement('div');
    };

    DOMOperations.prototype.createElement = function createElement(tag, context) {
        var isElementInSVGNamespace = void 0,
            isHTMLIntegrationPoint = void 0;
        if (context) {
            isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE$$1 || tag === 'svg';
            isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];
        } else {
            isElementInSVGNamespace = tag === 'svg';
            isHTMLIntegrationPoint = false;
        }
        if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
            // FIXME: This does not properly handle <font> with color, face, or
            // size attributes, which is also disallowed by the spec. We should fix
            // this.
            if (BLACKLIST_TABLE[tag]) {
                throw new Error('Cannot create a ' + tag + ' inside an SVG context');
            }
            return this.document.createElementNS(SVG_NAMESPACE$$1, tag);
        } else {
            return this.document.createElement(tag);
        }
    };

    DOMOperations.prototype.insertBefore = function insertBefore(parent, node, reference) {
        parent.insertBefore(node, reference);
    };

    DOMOperations.prototype.insertHTMLBefore = function insertHTMLBefore(_parent, nextSibling, html) {
        return _insertHTMLBefore(this.uselessElement, _parent, nextSibling, html);
    };

    DOMOperations.prototype.createTextNode = function createTextNode(text) {
        return this.document.createTextNode(text);
    };

    DOMOperations.prototype.createComment = function createComment(data) {
        return this.document.createComment(data);
    };

    return DOMOperations;
}();
var DOM;
(function (DOM) {
    var TreeConstruction = function (_DOMOperations) {
        inherits(TreeConstruction, _DOMOperations);

        function TreeConstruction() {
            classCallCheck(this, TreeConstruction);
            return possibleConstructorReturn(this, _DOMOperations.apply(this, arguments));
        }

        TreeConstruction.prototype.createElementNS = function createElementNS(namespace, tag) {
            return this.document.createElementNS(namespace, tag);
        };

        TreeConstruction.prototype.setAttribute = function setAttribute(element, name, value) {
            var namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

            if (namespace) {
                element.setAttributeNS(namespace, name, value);
            } else {
                element.setAttribute(name, value);
            }
        };

        return TreeConstruction;
    }(DOMOperations);

    DOM.TreeConstruction = TreeConstruction;
    var appliedTreeContruction = TreeConstruction;
    appliedTreeContruction = applyTextNodeMergingFix(doc, appliedTreeContruction);
    appliedTreeContruction = applySVGInnerHTMLFix(doc, appliedTreeContruction, SVG_NAMESPACE$$1);
    DOM.DOMTreeConstruction = appliedTreeContruction;
})(DOM || (DOM = {}));
var DOMChanges = function (_DOMOperations2) {
    inherits(DOMChanges, _DOMOperations2);

    function DOMChanges(document) {
        classCallCheck(this, DOMChanges);

        var _this2 = possibleConstructorReturn(this, _DOMOperations2.call(this, document));

        _this2.document = document;
        _this2.namespace = null;
        return _this2;
    }

    DOMChanges.prototype.setAttribute = function setAttribute(element, name, value) {
        element.setAttribute(name, value);
    };

    DOMChanges.prototype.removeAttribute = function removeAttribute(element, name) {
        element.removeAttribute(name);
    };

    DOMChanges.prototype.insertAfter = function insertAfter(element, node, reference) {
        this.insertBefore(element, node, reference.nextSibling);
    };

    return DOMChanges;
}(DOMOperations);
function _insertHTMLBefore(useless, _parent, _nextSibling, html) {
    // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`
    // only exists on `HTMLElement` but not on `Element`. We actually work with the
    // newer version of the DOM API here (and monkey-patch this method in `./compat`
    // when we detect older browsers). This is a hack to work around this limitation.
    var parent = _parent;
    var nextSibling = _nextSibling;
    var prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
    var last = void 0;
    if (html === null || html === '') {
        return new ConcreteBounds(parent, null, null);
    }
    if (nextSibling === null) {
        parent.insertAdjacentHTML('beforeend', html);
        last = parent.lastChild;
    } else if (nextSibling instanceof HTMLElement) {
        nextSibling.insertAdjacentHTML('beforebegin', html);
        last = nextSibling.previousSibling;
    } else {
        // Non-element nodes do not support insertAdjacentHTML, so add an
        // element and call it on that element. Then remove the element.
        //
        // This also protects Edge, IE and Firefox w/o the inspector open
        // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
        parent.insertBefore(useless, nextSibling);
        useless.insertAdjacentHTML('beforebegin', html);
        last = useless.previousSibling;
        parent.removeChild(useless);
    }
    var first = prev ? prev.nextSibling : parent.firstChild;
    return new ConcreteBounds(parent, first, last);
}
var helper = DOMChanges;
helper = applyTextNodeMergingFix(doc, helper);
helper = applySVGInnerHTMLFix(doc, helper, SVG_NAMESPACE$$1);
var DOMChanges$1 = helper;
var DOMTreeConstruction = DOM.DOMTreeConstruction;

var badProtocols = ['javascript:', 'vbscript:'];
var badTags = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];
var badTagsForDataURI = ['EMBED'];
var badAttributes = ['href', 'src', 'background', 'action'];
var badAttributesForDataURI = ['src'];
function has(array, item) {
    return array.indexOf(item) !== -1;
}
function checkURI(tagName, attribute) {
    return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);
}
function checkDataURI(tagName, attribute) {
    if (tagName === null) return false;
    return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);
}
function requiresSanitization(tagName, attribute) {
    return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);
}
function sanitizeAttributeValue(env, element, attribute, value) {
    var tagName = null;
    if (value === null || value === undefined) {
        return value;
    }
    if (isSafeString(value)) {
        return value.toHTML();
    }
    if (!element) {
        tagName = null;
    } else {
        tagName = element.tagName.toUpperCase();
    }
    var str = normalizeStringValue(value);
    if (checkURI(tagName, attribute)) {
        var protocol = env.protocolForURL(str);
        if (has(badProtocols, protocol)) {
            return 'unsafe:' + str;
        }
    }
    if (checkDataURI(tagName, attribute)) {
        return 'unsafe:' + str;
    }
    return str;
}

/*
 * @method normalizeProperty
 * @param element {HTMLElement}
 * @param slotName {String}
 * @returns {Object} { name, type }
 */
function normalizeProperty(element, slotName) {
    var type = void 0,
        normalized = void 0;
    if (slotName in element) {
        normalized = slotName;
        type = 'prop';
    } else {
        var lower = slotName.toLowerCase();
        if (lower in element) {
            type = 'prop';
            normalized = lower;
        } else {
            type = 'attr';
            normalized = slotName;
        }
    }
    if (type === 'prop' && (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))) {
        type = 'attr';
    }
    return { normalized: normalized, type: type };
}

// properties that MUST be set as attributes, due to:
// * browser bug
// * strange spec outlier
var ATTR_OVERRIDES = {
    INPUT: {
        form: true,
        // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false
        // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false
        // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true
        autocorrect: true,
        // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true
        // Safari 9.1.3: 'list' in document.createElement('input') === false
        list: true
    },
    // element.form is actually a legitimate readOnly property, that is to be
    // mutated, but must be mutated by setAttribute...
    SELECT: { form: true },
    OPTION: { form: true },
    TEXTAREA: { form: true },
    LABEL: { form: true },
    FIELDSET: { form: true },
    LEGEND: { form: true },
    OBJECT: { form: true }
};
function preferAttr(tagName, propName) {
    var tag = ATTR_OVERRIDES[tagName.toUpperCase()];
    return tag && tag[propName.toLowerCase()] || false;
}

function defaultDynamicAttributes(element, attr) {
    var tagName = element.tagName,
        namespaceURI = element.namespaceURI;

    if (namespaceURI === SVG_NAMESPACE$$1) {
        return defaultDynamicAttribute(tagName, attr);
    }

    var _normalizeProperty = normalizeProperty(element, attr),
        type = _normalizeProperty.type,
        normalized = _normalizeProperty.normalized;

    if (type === 'attr') {
        return defaultDynamicAttribute(tagName, normalized);
    } else {
        return defaultDynamicProperty(tagName, normalized);
    }
}
function defaultDynamicAttribute(tagName, name) {
    if (requiresSanitization(tagName, name)) {
        return SafeDynamicAttribute;
    } else {
        return SimpleDynamicAttribute;
    }
}
function defaultDynamicProperty(tagName, name) {
    if (requiresSanitization(tagName, name)) {
        return SafeDynamicProperty;
    }
    if (isUserInputValue(tagName, name)) {
        return InputValueDynamicAttribute;
    }
    if (isOptionSelected(tagName, name)) {
        return OptionSelectedDynamicAttribute;
    }
    return DefaultDynamicProperty;
}
var DynamicAttribute = function DynamicAttribute(attribute) {
    classCallCheck(this, DynamicAttribute);

    this.attribute = attribute;
};
var SimpleDynamicAttribute = function (_DynamicAttribute) {
    inherits(SimpleDynamicAttribute, _DynamicAttribute);

    function SimpleDynamicAttribute() {
        classCallCheck(this, SimpleDynamicAttribute);
        return possibleConstructorReturn(this, _DynamicAttribute.apply(this, arguments));
    }

    SimpleDynamicAttribute.prototype.set = function set$$1(dom, value, _env) {
        var normalizedValue = normalizeValue(value);
        if (normalizedValue !== null) {
            var _attribute = this.attribute,
                name = _attribute.name,
                namespace = _attribute.namespace;

            dom.__setAttribute(name, normalizedValue, namespace);
        }
    };

    SimpleDynamicAttribute.prototype.update = function update(value, _env) {
        var normalizedValue = normalizeValue(value);
        var _attribute2 = this.attribute,
            element = _attribute2.element,
            name = _attribute2.name;

        if (normalizedValue === null) {
            element.removeAttribute(name);
        } else {
            element.setAttribute(name, normalizedValue);
        }
    };

    return SimpleDynamicAttribute;
}(DynamicAttribute);
var DefaultDynamicProperty = function (_DynamicAttribute2) {
    inherits(DefaultDynamicProperty, _DynamicAttribute2);

    function DefaultDynamicProperty() {
        classCallCheck(this, DefaultDynamicProperty);
        return possibleConstructorReturn(this, _DynamicAttribute2.apply(this, arguments));
    }

    DefaultDynamicProperty.prototype.set = function set$$1(dom, value, _env) {
        if (value !== null && value !== undefined) {
            var name = this.attribute.name;

            this.value = value;
            dom.__setProperty(name, value);
        }
    };

    DefaultDynamicProperty.prototype.update = function update(value, _env) {
        var _attribute3 = this.attribute,
            element = _attribute3.element,
            name = _attribute3.name;

        if (this.value !== value) {
            element[name] = this.value = value;
            if (value === null || value === undefined) {
                this.removeAttribute();
            }
        }
    };

    DefaultDynamicProperty.prototype.removeAttribute = function removeAttribute() {
        // TODO this sucks but to preserve properties first and to meet current
        // semantics we must do this.
        var _attribute4 = this.attribute,
            element = _attribute4.element,
            name = _attribute4.name,
            namespace = _attribute4.namespace;

        if (namespace) {
            element.removeAttributeNS(namespace, name);
        } else {
            element.removeAttribute(name);
        }
    };

    return DefaultDynamicProperty;
}(DynamicAttribute);
var SafeDynamicProperty = function (_DefaultDynamicProper) {
    inherits(SafeDynamicProperty, _DefaultDynamicProper);

    function SafeDynamicProperty() {
        classCallCheck(this, SafeDynamicProperty);
        return possibleConstructorReturn(this, _DefaultDynamicProper.apply(this, arguments));
    }

    SafeDynamicProperty.prototype.set = function set$$1(dom, value, env) {
        var _attribute5 = this.attribute,
            element = _attribute5.element,
            name = _attribute5.name;

        var sanitized = sanitizeAttributeValue(env, element, name, value);
        _DefaultDynamicProper.prototype.set.call(this, dom, sanitized, env);
    };

    SafeDynamicProperty.prototype.update = function update(value, env) {
        var _attribute6 = this.attribute,
            element = _attribute6.element,
            name = _attribute6.name;

        var sanitized = sanitizeAttributeValue(env, element, name, value);
        _DefaultDynamicProper.prototype.update.call(this, sanitized, env);
    };

    return SafeDynamicProperty;
}(DefaultDynamicProperty);
var SafeDynamicAttribute = function (_SimpleDynamicAttribu) {
    inherits(SafeDynamicAttribute, _SimpleDynamicAttribu);

    function SafeDynamicAttribute() {
        classCallCheck(this, SafeDynamicAttribute);
        return possibleConstructorReturn(this, _SimpleDynamicAttribu.apply(this, arguments));
    }

    SafeDynamicAttribute.prototype.set = function set$$1(dom, value, env) {
        var _attribute7 = this.attribute,
            element = _attribute7.element,
            name = _attribute7.name;

        var sanitized = sanitizeAttributeValue(env, element, name, value);
        _SimpleDynamicAttribu.prototype.set.call(this, dom, sanitized, env);
    };

    SafeDynamicAttribute.prototype.update = function update(value, env) {
        var _attribute8 = this.attribute,
            element = _attribute8.element,
            name = _attribute8.name;

        var sanitized = sanitizeAttributeValue(env, element, name, value);
        _SimpleDynamicAttribu.prototype.update.call(this, sanitized, env);
    };

    return SafeDynamicAttribute;
}(SimpleDynamicAttribute);
var InputValueDynamicAttribute = function (_DefaultDynamicProper2) {
    inherits(InputValueDynamicAttribute, _DefaultDynamicProper2);

    function InputValueDynamicAttribute() {
        classCallCheck(this, InputValueDynamicAttribute);
        return possibleConstructorReturn(this, _DefaultDynamicProper2.apply(this, arguments));
    }

    InputValueDynamicAttribute.prototype.set = function set$$1(dom, value) {
        dom.__setProperty('value', normalizeStringValue(value));
    };

    InputValueDynamicAttribute.prototype.update = function update(value) {
        var input = this.attribute.element;
        var currentValue = input.value;
        var normalizedValue = normalizeStringValue(value);
        if (currentValue !== normalizedValue) {
            input.value = normalizedValue;
        }
    };

    return InputValueDynamicAttribute;
}(DefaultDynamicProperty);
var OptionSelectedDynamicAttribute = function (_DefaultDynamicProper3) {
    inherits(OptionSelectedDynamicAttribute, _DefaultDynamicProper3);

    function OptionSelectedDynamicAttribute() {
        classCallCheck(this, OptionSelectedDynamicAttribute);
        return possibleConstructorReturn(this, _DefaultDynamicProper3.apply(this, arguments));
    }

    OptionSelectedDynamicAttribute.prototype.set = function set$$1(dom, value) {
        if (value !== null && value !== undefined && value !== false) {
            dom.__setProperty('selected', true);
        }
    };

    OptionSelectedDynamicAttribute.prototype.update = function update(value) {
        var option = this.attribute.element;
        if (value) {
            option.selected = true;
        } else {
            option.selected = false;
        }
    };

    return OptionSelectedDynamicAttribute;
}(DefaultDynamicProperty);
function isOptionSelected(tagName, attribute) {
    return tagName === 'OPTION' && attribute === 'selected';
}
function isUserInputValue(tagName, attribute) {
    return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';
}
function normalizeValue(value) {
    if (value === false || value === undefined || value === null || typeof value.toString === 'undefined') {
        return null;
    }
    if (value === true) {
        return '';
    }
    // onclick function etc in SSR
    if (typeof value === 'function') {
        return null;
    }
    return String(value);
}

var Scope = function () {
    function Scope(
    // the 0th slot is `self`
    slots, callerScope,
    // named arguments and blocks passed to a layout that uses eval
    evalScope,
    // locals in scope when the partial was invoked
    partialMap) {
        classCallCheck(this, Scope);

        this.slots = slots;
        this.callerScope = callerScope;
        this.evalScope = evalScope;
        this.partialMap = partialMap;
    }

    Scope.root = function root(self) {
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        var refs = new Array(size + 1);
        for (var i = 0; i <= size; i++) {
            refs[i] = UNDEFINED_REFERENCE;
        }
        return new Scope(refs, null, null, null).init({ self: self });
    };

    Scope.sized = function sized() {
        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        var refs = new Array(size + 1);
        for (var i = 0; i <= size; i++) {
            refs[i] = UNDEFINED_REFERENCE;
        }
        return new Scope(refs, null, null, null);
    };

    Scope.prototype.init = function init(_ref) {
        var self = _ref.self;

        this.slots[0] = self;
        return this;
    };

    Scope.prototype.getSelf = function getSelf() {
        return this.get(0);
    };

    Scope.prototype.getSymbol = function getSymbol(symbol) {
        return this.get(symbol);
    };

    Scope.prototype.getBlock = function getBlock(symbol) {
        return this.get(symbol);
    };

    Scope.prototype.getEvalScope = function getEvalScope() {
        return this.evalScope;
    };

    Scope.prototype.getPartialMap = function getPartialMap() {
        return this.partialMap;
    };

    Scope.prototype.bind = function bind(symbol, value) {
        this.set(symbol, value);
    };

    Scope.prototype.bindSelf = function bindSelf(self) {
        this.set(0, self);
    };

    Scope.prototype.bindSymbol = function bindSymbol(symbol, value) {
        this.set(symbol, value);
    };

    Scope.prototype.bindBlock = function bindBlock(symbol, value) {
        this.set(symbol, value);
    };

    Scope.prototype.bindEvalScope = function bindEvalScope(map) {
        this.evalScope = map;
    };

    Scope.prototype.bindPartialMap = function bindPartialMap(map) {
        this.partialMap = map;
    };

    Scope.prototype.bindCallerScope = function bindCallerScope(scope) {
        this.callerScope = scope;
    };

    Scope.prototype.getCallerScope = function getCallerScope() {
        return this.callerScope;
    };

    Scope.prototype.child = function child() {
        return new Scope(this.slots.slice(), this.callerScope, this.evalScope, this.partialMap);
    };

    Scope.prototype.get = function get$$1(index) {
        if (index >= this.slots.length) {
            throw new RangeError('BUG: cannot get $' + index + ' from scope; length=' + this.slots.length);
        }
        return this.slots[index];
    };

    Scope.prototype.set = function set$$1(index, value) {
        if (index >= this.slots.length) {
            throw new RangeError('BUG: cannot get $' + index + ' from scope; length=' + this.slots.length);
        }
        this.slots[index] = value;
    };

    return Scope;
}();

var Transaction = function () {
    function Transaction() {
        classCallCheck(this, Transaction);

        this.scheduledInstallManagers = [];
        this.scheduledInstallModifiers = [];
        this.scheduledUpdateModifierManagers = [];
        this.scheduledUpdateModifiers = [];
        this.createdComponents = [];
        this.createdManagers = [];
        this.updatedComponents = [];
        this.updatedManagers = [];
        this.destructors = [];
    }

    Transaction.prototype.didCreate = function didCreate(component, manager) {
        this.createdComponents.push(component);
        this.createdManagers.push(manager);
    };

    Transaction.prototype.didUpdate = function didUpdate(component, manager) {
        this.updatedComponents.push(component);
        this.updatedManagers.push(manager);
    };

    Transaction.prototype.scheduleInstallModifier = function scheduleInstallModifier(modifier, manager) {
        this.scheduledInstallManagers.push(manager);
        this.scheduledInstallModifiers.push(modifier);
    };

    Transaction.prototype.scheduleUpdateModifier = function scheduleUpdateModifier(modifier, manager) {
        this.scheduledUpdateModifierManagers.push(manager);
        this.scheduledUpdateModifiers.push(modifier);
    };

    Transaction.prototype.didDestroy = function didDestroy(d) {
        this.destructors.push(d);
    };

    Transaction.prototype.commit = function commit() {
        var createdComponents = this.createdComponents,
            createdManagers = this.createdManagers;

        for (var i = 0; i < createdComponents.length; i++) {
            var component = createdComponents[i];
            var manager = createdManagers[i];
            manager.didCreate(component);
        }
        var updatedComponents = this.updatedComponents,
            updatedManagers = this.updatedManagers;

        for (var _i = 0; _i < updatedComponents.length; _i++) {
            var _component = updatedComponents[_i];
            var _manager = updatedManagers[_i];
            _manager.didUpdate(_component);
        }
        var destructors = this.destructors;

        for (var _i2 = 0; _i2 < destructors.length; _i2++) {
            destructors[_i2].destroy();
        }
        var scheduledInstallManagers = this.scheduledInstallManagers,
            scheduledInstallModifiers = this.scheduledInstallModifiers;

        for (var _i3 = 0; _i3 < scheduledInstallManagers.length; _i3++) {
            var _manager2 = scheduledInstallManagers[_i3];
            var modifier = scheduledInstallModifiers[_i3];
            _manager2.install(modifier);
        }
        var scheduledUpdateModifierManagers = this.scheduledUpdateModifierManagers,
            scheduledUpdateModifiers = this.scheduledUpdateModifiers;

        for (var _i4 = 0; _i4 < scheduledUpdateModifierManagers.length; _i4++) {
            var _manager3 = scheduledUpdateModifierManagers[_i4];
            var _modifier = scheduledUpdateModifiers[_i4];
            _manager3.update(_modifier);
        }
    };

    return Transaction;
}();

var Environment = function () {
    function Environment(_ref2) {
        var appendOperations = _ref2.appendOperations,
            updateOperations = _ref2.updateOperations;
        classCallCheck(this, Environment);

        this._transaction = null;
        this.appendOperations = appendOperations;
        this.updateOperations = updateOperations;
    }

    Environment.prototype.toConditionalReference = function toConditionalReference(reference) {
        return new ConditionalReference$1(reference);
    };

    Environment.prototype.getAppendOperations = function getAppendOperations() {
        return this.appendOperations;
    };

    Environment.prototype.getDOM = function getDOM() {
        return this.updateOperations;
    };

    Environment.prototype.getIdentity = function getIdentity(object) {
        return ensureGuid(object) + '';
    };

    Environment.prototype.begin = function begin() {
        false && debugAssert(!this._transaction, 'A glimmer transaction was begun, but one already exists. You may have a nested transaction, possibly caused by an earlier runtime exception while rendering. Please check your console for the stack trace of any prior exceptions.');

        this._transaction = new Transaction();
    };

    Environment.prototype.didCreate = function didCreate(component, manager) {
        this.transaction.didCreate(component, manager);
    };

    Environment.prototype.didUpdate = function didUpdate(component, manager) {
        this.transaction.didUpdate(component, manager);
    };

    Environment.prototype.scheduleInstallModifier = function scheduleInstallModifier(modifier, manager) {
        this.transaction.scheduleInstallModifier(modifier, manager);
    };

    Environment.prototype.scheduleUpdateModifier = function scheduleUpdateModifier(modifier, manager) {
        this.transaction.scheduleUpdateModifier(modifier, manager);
    };

    Environment.prototype.didDestroy = function didDestroy(d) {
        this.transaction.didDestroy(d);
    };

    Environment.prototype.commit = function commit() {
        var transaction = this.transaction;
        this._transaction = null;
        transaction.commit();
    };

    Environment.prototype.attributeFor = function attributeFor(element, attr, _isTrusting) {
        var _namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        return defaultDynamicAttributes(element, attr);
    };

    createClass(Environment, [{
        key: 'transaction',
        get: function get$$1() {
            return this._transaction;
        }
    }]);
    return Environment;
}();
var DefaultEnvironment = function (_Environment) {
    inherits(DefaultEnvironment, _Environment);

    function DefaultEnvironment(options) {
        classCallCheck(this, DefaultEnvironment);

        if (!options) {
            var document = window.document;
            var appendOperations = new DOMTreeConstruction(document);
            var updateOperations = new DOMChanges(document);
            options = { appendOperations: appendOperations, updateOperations: updateOperations };
        }
        return possibleConstructorReturn(this, _Environment.call(this, options));
    }

    return DefaultEnvironment;
}(Environment);

var LowLevelVM$1 = function () {
    function LowLevelVM(stack, heap, program, externs) {
        var pc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;
        var ra = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;
        classCallCheck(this, LowLevelVM);

        this.stack = stack;
        this.heap = heap;
        this.program = program;
        this.externs = externs;
        this.pc = pc;
        this.ra = ra;
        this.currentOpSize = 0;
    }
    // Start a new frame and save $ra and $fp on the stack


    LowLevelVM.prototype.pushFrame = function pushFrame() {
        this.stack.pushSmi(this.ra);
        this.stack.pushSmi(this.stack.fp);
        this.stack.fp = this.stack.sp - 1;
    };
    // Restore $ra, $sp and $fp


    LowLevelVM.prototype.popFrame = function popFrame() {
        this.stack.sp = this.stack.fp - 1;
        this.ra = this.stack.getSmi(0);
        this.stack.fp = this.stack.getSmi(1);
    };
    // Jump to an address in `program`


    LowLevelVM.prototype.goto = function goto(offset) {
        var addr = this.pc + offset - this.currentOpSize;
        this.pc = addr;
    };
    // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)


    LowLevelVM.prototype.call = function call(handle) {
        this.ra = this.pc;
        this.pc = this.heap.getaddr(handle);
    };
    // Put a specific `program` address in $ra


    LowLevelVM.prototype.returnTo = function returnTo(offset) {
        var addr = this.pc + offset - this.currentOpSize;
        this.ra = addr;
    };
    // Return to the `program` address stored in $ra


    LowLevelVM.prototype.return = function _return() {
        this.pc = this.ra;
    };

    LowLevelVM.prototype.nextStatement = function nextStatement() {
        var pc = this.pc,
            program = this.program;

        if (pc === -1) {
            return null;
        }
        // We have to save off the current operations size so that
        // when we do a jump we can calculate the correct offset
        // to where we are going. We can't simply ask for the size
        // in a jump because we have have already incremented the
        // program counter to the next instruction prior to executing.

        var _program$opcode = this.program.opcode(pc),
            size = _program$opcode.size;

        var operationSize = this.currentOpSize = size;
        this.pc += operationSize;
        return program.opcode(pc);
    };

    LowLevelVM.prototype.evaluateOuter = function evaluateOuter(opcode, vm) {
        {
            this.evaluateInner(opcode, vm);
        }
    };

    LowLevelVM.prototype.evaluateInner = function evaluateInner(opcode, vm) {
        if (opcode.isMachine) {
            this.evaluateMachine(opcode);
        } else {
            this.evaluateSyscall(opcode, vm);
        }
    };

    LowLevelVM.prototype.evaluateMachine = function evaluateMachine(opcode) {
        switch (opcode.type) {
            case 47 /* PushFrame */:
                return this.pushFrame();
            case 48 /* PopFrame */:
                return this.popFrame();
            case 42 /* InvokeStatic */:
                return this.call(opcode.op1);
            case 41 /* InvokeVirtual */:
                return this.call(this.stack.popSmi());
            case 44 /* Jump */:
                return this.goto(opcode.op1);
            case 20 /* Return */:
                return this.return();
            case 21 /* ReturnTo */:
                return this.returnTo(opcode.op1);
        }
    };

    LowLevelVM.prototype.evaluateSyscall = function evaluateSyscall(opcode, vm) {
        APPEND_OPCODES.evaluate(vm, opcode, opcode.type);
    };

    return LowLevelVM;
}();

var DynamicContentBase = function () {
    function DynamicContentBase(trusting) {
        classCallCheck(this, DynamicContentBase);

        this.trusting = trusting;
    }

    DynamicContentBase.prototype.retry = function retry(env, value) {
        var bounds$$1 = this.bounds;

        var parentElement = bounds$$1.parentElement();
        var nextSibling = clear(bounds$$1);
        var stack = NewElementBuilder.forInitialRender(env, { element: parentElement, nextSibling: nextSibling });
        if (this.trusting) {
            return stack.__appendTrustingDynamicContent(value);
        } else {
            return stack.__appendCautiousDynamicContent(value);
        }
    };

    return DynamicContentBase;
}();

var DynamicContentWrapper = function () {
    function DynamicContentWrapper(inner) {
        classCallCheck(this, DynamicContentWrapper);

        this.inner = inner;
        this.bounds = inner.bounds;
    }

    DynamicContentWrapper.prototype.parentElement = function parentElement() {
        return this.bounds.parentElement();
    };

    DynamicContentWrapper.prototype.firstNode = function firstNode() {
        return this.bounds.firstNode();
    };

    DynamicContentWrapper.prototype.lastNode = function lastNode() {
        return this.bounds.lastNode();
    };

    DynamicContentWrapper.prototype.update = function update(env, value) {
        var inner = this.inner = this.inner.update(env, value);
        this.bounds = inner.bounds;
        return this;
    };

    return DynamicContentWrapper;
}();

var DynamicTextContent = function (_DynamicContentBase) {
    inherits(DynamicTextContent, _DynamicContentBase);

    function DynamicTextContent(bounds, lastValue, trusted) {
        classCallCheck(this, DynamicTextContent);

        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusted));

        _this.bounds = bounds;
        _this.lastValue = lastValue;
        return _this;
    }

    DynamicTextContent.prototype.update = function update(env, value) {
        var lastValue = this.lastValue;

        if (value === lastValue) return this;
        if (isNode(value) || isSafeString(value)) return this.retry(env, value);
        var normalized = void 0;
        if (isEmpty(value)) {
            normalized = '';
        } else if (isString(value)) {
            normalized = value;
        } else {
            normalized = String(value);
        }
        if (normalized !== lastValue) {
            var textNode = this.bounds.firstNode();
            textNode.nodeValue = this.lastValue = normalized;
        }
        return this;
    };

    return DynamicTextContent;
}(DynamicContentBase);

var DynamicNodeContent = function (_DynamicContentBase) {
    inherits(DynamicNodeContent, _DynamicContentBase);

    function DynamicNodeContent(bounds, lastValue, trusting) {
        classCallCheck(this, DynamicNodeContent);

        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusting));

        _this.bounds = bounds;
        _this.lastValue = lastValue;
        return _this;
    }

    DynamicNodeContent.prototype.update = function update(env, value) {
        var lastValue = this.lastValue;

        if (value === lastValue) return this;
        return this.retry(env, value);
    };

    return DynamicNodeContent;
}(DynamicContentBase);

var DynamicHTMLContent = function (_DynamicContentBase) {
    inherits(DynamicHTMLContent, _DynamicContentBase);

    function DynamicHTMLContent(bounds, lastValue, trusted) {
        classCallCheck(this, DynamicHTMLContent);

        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusted));

        _this.bounds = bounds;
        _this.lastValue = lastValue;
        return _this;
    }

    DynamicHTMLContent.prototype.update = function update(env, value) {
        var lastValue = this.lastValue;

        if (value === lastValue) return this;
        if (isSafeString(value) && value.toHTML() === lastValue.toHTML()) {
            this.lastValue = value;
            return this;
        }
        return this.retry(env, value);
    };

    return DynamicHTMLContent;
}(DynamicContentBase);

var DynamicTrustedHTMLContent = function (_DynamicContentBase2) {
    inherits(DynamicTrustedHTMLContent, _DynamicContentBase2);

    function DynamicTrustedHTMLContent(bounds, lastValue, trusted) {
        classCallCheck(this, DynamicTrustedHTMLContent);

        var _this2 = possibleConstructorReturn(this, _DynamicContentBase2.call(this, trusted));

        _this2.bounds = bounds;
        _this2.lastValue = lastValue;
        return _this2;
    }

    DynamicTrustedHTMLContent.prototype.update = function update(env, value) {
        var lastValue = this.lastValue;

        if (value === lastValue) return this;
        var newValue = normalizeTrustedValue(value);
        if (newValue === lastValue) return this;
        return this.retry(env, value);
    };

    return DynamicTrustedHTMLContent;
}(DynamicContentBase);

var First = function () {
    function First(node) {
        classCallCheck(this, First);

        this.node = node;
    }

    First.prototype.firstNode = function firstNode() {
        return this.node;
    };

    return First;
}();

var Last = function () {
    function Last(node) {
        classCallCheck(this, Last);

        this.node = node;
    }

    Last.prototype.lastNode = function lastNode() {
        return this.node;
    };

    return Last;
}();


var NewElementBuilder = function () {
    function NewElementBuilder(env, parentNode, nextSibling) {
        classCallCheck(this, NewElementBuilder);

        this.constructing = null;
        this.operations = null;
        this.cursorStack = new Stack();
        this.blockStack = new Stack();
        this.pushElement(parentNode, nextSibling);
        this.env = env;
        this.dom = env.getAppendOperations();
        this.updateOperations = env.getDOM();
    }

    NewElementBuilder.forInitialRender = function forInitialRender(env, cursor) {
        var builder = new this(env, cursor.element, cursor.nextSibling);
        builder.pushSimpleBlock();
        return builder;
    };

    NewElementBuilder.resume = function resume(env, tracker, nextSibling) {
        var parentNode = tracker.parentElement();
        var stack = new this(env, parentNode, nextSibling);
        stack.pushSimpleBlock();
        stack.pushBlockTracker(tracker);
        return stack;
    };

    NewElementBuilder.prototype.expectConstructing = function expectConstructing(method) {
        return this.constructing;
    };

    NewElementBuilder.prototype.block = function block() {
        return this.blockStack.current;
    };

    NewElementBuilder.prototype.popElement = function popElement() {
        this.cursorStack.pop();
        this.cursorStack.current;
    };

    NewElementBuilder.prototype.pushSimpleBlock = function pushSimpleBlock() {
        return this.pushBlockTracker(new SimpleBlockTracker(this.element));
    };

    NewElementBuilder.prototype.pushUpdatableBlock = function pushUpdatableBlock() {
        return this.pushBlockTracker(new UpdatableBlockTracker(this.element));
    };

    NewElementBuilder.prototype.pushBlockList = function pushBlockList(list) {
        return this.pushBlockTracker(new BlockListTracker(this.element, list));
    };

    NewElementBuilder.prototype.pushBlockTracker = function pushBlockTracker(tracker) {
        var isRemote = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var current = this.blockStack.current;
        if (current !== null) {
            current.newDestroyable(tracker);
            if (!isRemote) {
                current.didAppendBounds(tracker);
            }
        }
        this.__openBlock();
        this.blockStack.push(tracker);
        return tracker;
    };

    NewElementBuilder.prototype.popBlock = function popBlock() {
        this.block().finalize(this);
        this.__closeBlock();
        return this.blockStack.pop();
    };

    NewElementBuilder.prototype.__openBlock = function __openBlock() {};

    NewElementBuilder.prototype.__closeBlock = function __closeBlock() {};
    // todo return seems unused


    NewElementBuilder.prototype.openElement = function openElement(tag) {
        var element = this.__openElement(tag);
        this.constructing = element;
        return element;
    };

    NewElementBuilder.prototype.__openElement = function __openElement(tag) {
        return this.dom.createElement(tag, this.element);
    };

    NewElementBuilder.prototype.flushElement = function flushElement() {
        var parent = this.element;
        var element = this.constructing;
        this.__flushElement(parent, element);
        this.constructing = null;
        this.operations = null;
        this.pushElement(element, null);
        this.didOpenElement(element);
    };

    NewElementBuilder.prototype.__flushElement = function __flushElement(parent, constructing) {
        this.dom.insertBefore(parent, constructing, this.nextSibling);
    };

    NewElementBuilder.prototype.closeElement = function closeElement() {
        this.willCloseElement();
        this.popElement();
    };

    NewElementBuilder.prototype.pushRemoteElement = function pushRemoteElement(element, guid) {
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this.__pushRemoteElement(element, guid, nextSibling);
    };

    NewElementBuilder.prototype.__pushRemoteElement = function __pushRemoteElement(element, _guid, nextSibling) {
        this.pushElement(element, nextSibling);
        var tracker = new RemoteBlockTracker(element);
        this.pushBlockTracker(tracker, true);
    };

    NewElementBuilder.prototype.popRemoteElement = function popRemoteElement() {
        this.popBlock();
        this.popElement();
    };

    NewElementBuilder.prototype.pushElement = function pushElement(element, nextSibling) {
        this.cursorStack.push(new Cursor(element, nextSibling));
    };

    NewElementBuilder.prototype.didAddDestroyable = function didAddDestroyable(d) {
        this.block().newDestroyable(d);
    };

    NewElementBuilder.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {
        this.block().didAppendBounds(bounds$$1);
        return bounds$$1;
    };

    NewElementBuilder.prototype.didAppendNode = function didAppendNode(node) {
        this.block().didAppendNode(node);
        return node;
    };

    NewElementBuilder.prototype.didOpenElement = function didOpenElement(element) {
        this.block().openElement(element);
        return element;
    };

    NewElementBuilder.prototype.willCloseElement = function willCloseElement() {
        this.block().closeElement();
    };

    NewElementBuilder.prototype.appendText = function appendText(string) {
        return this.didAppendNode(this.__appendText(string));
    };

    NewElementBuilder.prototype.__appendText = function __appendText(text) {
        var dom = this.dom,
            element = this.element,
            nextSibling = this.nextSibling;

        var node = dom.createTextNode(text);
        dom.insertBefore(element, node, nextSibling);
        return node;
    };

    NewElementBuilder.prototype.__appendNode = function __appendNode(node) {
        this.dom.insertBefore(this.element, node, this.nextSibling);
        return node;
    };

    NewElementBuilder.prototype.__appendFragment = function __appendFragment(fragment) {
        var first = fragment.firstChild;
        if (first) {
            var ret = bounds(this.element, first, fragment.lastChild);
            this.dom.insertBefore(this.element, fragment, this.nextSibling);
            return ret;
        } else {
            return single(this.element, this.__appendComment(''));
        }
    };

    NewElementBuilder.prototype.__appendHTML = function __appendHTML(html) {
        return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);
    };

    NewElementBuilder.prototype.appendTrustingDynamicContent = function appendTrustingDynamicContent(value) {
        var wrapper = new DynamicContentWrapper(this.__appendTrustingDynamicContent(value));
        this.didAppendBounds(wrapper);
        return wrapper;
    };

    NewElementBuilder.prototype.__appendTrustingDynamicContent = function __appendTrustingDynamicContent(value) {
        if (isString(value)) {
            return this.trustedContent(value);
        } else if (isEmpty(value)) {
            return this.trustedContent('');
        } else if (isSafeString(value)) {
            return this.trustedContent(value.toHTML());
        }
        if (isFragment(value)) {
            var _bounds2 = this.__appendFragment(value);
            return new DynamicNodeContent(_bounds2, value, true);
        } else if (isNode(value)) {
            var node = this.__appendNode(value);
            return new DynamicNodeContent(single(this.element, node), node, true);
        }
        return this.trustedContent(String(value));
    };

    NewElementBuilder.prototype.appendCautiousDynamicContent = function appendCautiousDynamicContent(value) {
        var wrapper = new DynamicContentWrapper(this.__appendCautiousDynamicContent(value));
        this.didAppendBounds(wrapper.bounds);
        return wrapper;
    };

    NewElementBuilder.prototype.__appendCautiousDynamicContent = function __appendCautiousDynamicContent(value) {
        if (isString(value)) {
            return this.untrustedContent(value);
        } else if (isEmpty(value)) {
            return this.untrustedContent('');
        } else if (isFragment(value)) {
            var _bounds3 = this.__appendFragment(value);
            return new DynamicNodeContent(_bounds3, value, false);
        } else if (isNode(value)) {
            var node = this.__appendNode(value);
            return new DynamicNodeContent(single(this.element, node), node, false);
        } else if (isSafeString(value)) {
            var normalized = value.toHTML();
            var _bounds4 = this.__appendHTML(normalized);
            // let bounds = this.dom.insertHTMLBefore(this.element, this.nextSibling, normalized);
            return new DynamicHTMLContent(_bounds4, value, false);
        }
        return this.untrustedContent(String(value));
    };

    NewElementBuilder.prototype.trustedContent = function trustedContent(value) {
        var bounds$$1 = this.__appendHTML(value);
        return new DynamicTrustedHTMLContent(bounds$$1, value, true);
    };

    NewElementBuilder.prototype.untrustedContent = function untrustedContent(value) {
        var textNode = this.__appendText(value);
        var bounds$$1 = single(this.element, textNode);
        return new DynamicTextContent(bounds$$1, value, false);
    };

    NewElementBuilder.prototype.appendComment = function appendComment(string) {
        return this.didAppendNode(this.__appendComment(string));
    };

    NewElementBuilder.prototype.__appendComment = function __appendComment(string) {
        var dom = this.dom,
            element = this.element,
            nextSibling = this.nextSibling;

        var node = dom.createComment(string);
        dom.insertBefore(element, node, nextSibling);
        return node;
    };

    NewElementBuilder.prototype.__setAttribute = function __setAttribute(name, value, namespace) {
        this.dom.setAttribute(this.constructing, name, value, namespace);
    };

    NewElementBuilder.prototype.__setProperty = function __setProperty(name, value) {
        this.constructing[name] = value;
    };

    NewElementBuilder.prototype.setStaticAttribute = function setStaticAttribute(name, value, namespace) {
        this.__setAttribute(name, value, namespace);
    };

    NewElementBuilder.prototype.setDynamicAttribute = function setDynamicAttribute(name, value, trusting, namespace) {
        var element = this.constructing;
        var DynamicAttribute = this.env.attributeFor(element, name, trusting, namespace);
        var attribute = new DynamicAttribute({ element: element, name: name, namespace: namespace || null });
        attribute.set(this, value, this.env);
        return attribute;
    };

    createClass(NewElementBuilder, [{
        key: 'element',
        get: function get$$1() {
            return this.cursorStack.current.element;
        }
    }, {
        key: 'nextSibling',
        get: function get$$1() {
            return this.cursorStack.current.nextSibling;
        }
    }]);
    return NewElementBuilder;
}();
var SimpleBlockTracker = function () {
    function SimpleBlockTracker(parent) {
        classCallCheck(this, SimpleBlockTracker);

        this.parent = parent;
        this.first = null;
        this.last = null;
        this.destroyables = null;
        this.nesting = 0;
    }

    SimpleBlockTracker.prototype.destroy = function destroy() {
        var destroyables = this.destroyables;

        if (destroyables && destroyables.length) {
            for (var i = 0; i < destroyables.length; i++) {
                destroyables[i].destroy();
            }
        }
    };

    SimpleBlockTracker.prototype.parentElement = function parentElement() {
        return this.parent;
    };

    SimpleBlockTracker.prototype.firstNode = function firstNode() {
        return this.first && this.first.firstNode();
    };

    SimpleBlockTracker.prototype.lastNode = function lastNode() {
        return this.last && this.last.lastNode();
    };

    SimpleBlockTracker.prototype.openElement = function openElement(element) {
        this.didAppendNode(element);
        this.nesting++;
    };

    SimpleBlockTracker.prototype.closeElement = function closeElement() {
        this.nesting--;
    };

    SimpleBlockTracker.prototype.didAppendNode = function didAppendNode(node) {
        if (this.nesting !== 0) return;
        if (!this.first) {
            this.first = new First(node);
        }
        this.last = new Last(node);
    };

    SimpleBlockTracker.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {
        if (this.nesting !== 0) return;
        if (!this.first) {
            this.first = bounds$$1;
        }
        this.last = bounds$$1;
    };

    SimpleBlockTracker.prototype.newDestroyable = function newDestroyable(d) {
        this.destroyables = this.destroyables || [];
        this.destroyables.push(d);
    };

    SimpleBlockTracker.prototype.finalize = function finalize(stack) {
        if (!this.first) {
            stack.appendComment('');
        }
    };

    return SimpleBlockTracker;
}();
var RemoteBlockTracker = function (_SimpleBlockTracker) {
    inherits(RemoteBlockTracker, _SimpleBlockTracker);

    function RemoteBlockTracker() {
        classCallCheck(this, RemoteBlockTracker);
        return possibleConstructorReturn(this, _SimpleBlockTracker.apply(this, arguments));
    }

    RemoteBlockTracker.prototype.destroy = function destroy() {
        _SimpleBlockTracker.prototype.destroy.call(this);
        clear(this);
    };

    return RemoteBlockTracker;
}(SimpleBlockTracker);
var UpdatableBlockTracker = function (_SimpleBlockTracker2) {
    inherits(UpdatableBlockTracker, _SimpleBlockTracker2);

    function UpdatableBlockTracker() {
        classCallCheck(this, UpdatableBlockTracker);
        return possibleConstructorReturn(this, _SimpleBlockTracker2.apply(this, arguments));
    }

    UpdatableBlockTracker.prototype.reset = function reset(env) {
        var destroyables = this.destroyables;

        if (destroyables && destroyables.length) {
            for (var i = 0; i < destroyables.length; i++) {
                env.didDestroy(destroyables[i]);
            }
        }
        var nextSibling = clear(this);
        this.first = null;
        this.last = null;
        this.destroyables = null;
        this.nesting = 0;
        return nextSibling;
    };

    return UpdatableBlockTracker;
}(SimpleBlockTracker);

var BlockListTracker = function () {
    function BlockListTracker(parent, boundList) {
        classCallCheck(this, BlockListTracker);

        this.parent = parent;
        this.boundList = boundList;
        this.parent = parent;
        this.boundList = boundList;
    }

    BlockListTracker.prototype.destroy = function destroy() {
        this.boundList.forEachNode(function (node) {
            return node.destroy();
        });
    };

    BlockListTracker.prototype.parentElement = function parentElement() {
        return this.parent;
    };

    BlockListTracker.prototype.firstNode = function firstNode() {
        var head = this.boundList.head();
        return head && head.firstNode();
    };

    BlockListTracker.prototype.lastNode = function lastNode() {
        var tail = this.boundList.tail();
        return tail && tail.lastNode();
    };

    BlockListTracker.prototype.openElement = function openElement(_element) {
        false && debugAssert(false, 'Cannot openElement directly inside a block list');
    };

    BlockListTracker.prototype.closeElement = function closeElement() {
        false && debugAssert(false, 'Cannot closeElement directly inside a block list');
    };

    BlockListTracker.prototype.didAppendNode = function didAppendNode(_node) {
        false && debugAssert(false, 'Cannot create a new node directly inside a block list');
    };

    BlockListTracker.prototype.didAppendBounds = function didAppendBounds(_bounds) {};

    BlockListTracker.prototype.newDestroyable = function newDestroyable(_d) {};

    BlockListTracker.prototype.finalize = function finalize(_stack) {};

    return BlockListTracker;
}();

function clientBuilder(env, cursor) {
    return NewElementBuilder.forInitialRender(env, cursor);
}

var Stack$1 = function () {
    function Stack() {
        var vec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        classCallCheck(this, Stack);

        this.vec = vec;
    }

    Stack.prototype.clone = function clone() {
        return new Stack(this.vec.slice());
    };

    Stack.prototype.sliceFrom = function sliceFrom(start) {
        return new Stack(this.vec.slice(start));
    };

    Stack.prototype.slice = function slice(start, end) {
        return new Stack(this.vec.slice(start, end));
    };

    Stack.prototype.copy = function copy(from, to) {
        this.vec[to] = this.vec[from];
    };
    // TODO: how to model u64 argument?


    Stack.prototype.writeRaw = function writeRaw(pos, value) {
        // TODO: Grow?
        this.vec[pos] = value;
    };

    Stack.prototype.writeSmi = function writeSmi(pos, value) {
        this.vec[pos] = encodeSmi$1(value);
    };
    // TODO: partially decoded enum?


    Stack.prototype.getRaw = function getRaw(pos) {
        return this.vec[pos];
    };

    Stack.prototype.getSmi = function getSmi(pos) {
        return decodeSmi$1(this.vec[pos]);
    };

    Stack.prototype.reset = function reset() {
        this.vec.length = 0;
    };

    Stack.prototype.len = function len() {
        return this.vec.length;
    };

    return Stack;
}();
function decodeSmi$1(smi) {
    switch (smi & 7) {
        case 0 /* NUMBER */:
            return smi >> 3;
        case 4 /* NEGATIVE */:
            return -(smi >> 3);
        default:
            throw new Error('unreachable');
    }
}
function encodeSmi$1(primitive) {
    if (primitive < 0) {
        return Math.abs(primitive) << 3 | 4 /* NEGATIVE */;
    } else {
        return primitive << 3 | 0 /* NUMBER */;
    }
}

var HI = 0x80000000;
var MASK = 0x7FFFFFFF;
var InnerStack = function () {
    function InnerStack() {
        var inner = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Stack$1();
        var js = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        classCallCheck(this, InnerStack);

        this.inner = inner;
        this.js = js;
    }

    InnerStack.prototype.slice = function slice(start, end) {
        var inner = void 0;
        if (typeof start === 'number' && typeof end === 'number') {
            inner = this.inner.slice(start, end);
        } else if (typeof start === 'number' && end === undefined) {
            inner = this.inner.sliceFrom(start);
        } else {
            inner = this.inner.clone();
        }
        return new InnerStack(inner, this.js.slice(start, end));
    };

    InnerStack.prototype.sliceInner = function sliceInner(start, end) {
        var out = [];
        for (var i = start; i < end; i++) {
            out.push(this.get(i));
        }
        return out;
    };

    InnerStack.prototype.copy = function copy(from, to) {
        this.inner.copy(from, to);
    };

    InnerStack.prototype.write = function write(pos, value) {
        if (isImmediate(value)) {
            this.inner.writeRaw(pos, encodeImmediate(value));
        } else {
            var idx = this.js.length;
            this.js.push(value);
            this.inner.writeRaw(pos, idx | HI);
        }
    };

    InnerStack.prototype.writeSmi = function writeSmi(pos, value) {
        this.inner.writeSmi(pos, value);
    };

    InnerStack.prototype.writeImmediate = function writeImmediate(pos, value) {
        this.inner.writeRaw(pos, value);
    };

    InnerStack.prototype.get = function get$$1(pos) {
        var value = this.inner.getRaw(pos);
        if (value & HI) {
            return this.js[value & MASK];
        } else {
            return decodeImmediate(value);
        }
    };

    InnerStack.prototype.getSmi = function getSmi(pos) {
        return this.inner.getSmi(pos);
    };

    InnerStack.prototype.reset = function reset() {
        this.inner.reset();
    };

    createClass(InnerStack, [{
        key: 'length',
        get: function get$$1() {
            return this.inner.len();
        }
    }]);
    return InnerStack;
}();

var EvaluationStack = function () {
    function EvaluationStack(stack, fp, sp) {
        classCallCheck(this, EvaluationStack);

        this.stack = stack;
        this.fp = fp;
        this.sp = sp;
        
    }

    EvaluationStack.empty = function empty() {
        return new this(new InnerStack(), 0, -1);
    };

    EvaluationStack.restore = function restore(snapshot) {
        var stack = new InnerStack();
        for (var i = 0; i < snapshot.length; i++) {
            stack.write(i, snapshot[i]);
        }
        return new this(stack, 0, snapshot.length - 1);
    };

    EvaluationStack.prototype.push = function push(value) {
        this.stack.write(++this.sp, value);
    };

    EvaluationStack.prototype.pushSmi = function pushSmi(value) {
        this.stack.writeSmi(++this.sp, value);
    };

    EvaluationStack.prototype.pushImmediate = function pushImmediate(value) {
        this.stack.writeImmediate(++this.sp, encodeImmediate(value));
    };

    EvaluationStack.prototype.pushEncodedImmediate = function pushEncodedImmediate(value) {
        this.stack.writeImmediate(++this.sp, value);
    };

    EvaluationStack.prototype.pushNull = function pushNull() {
        this.stack.writeImmediate(++this.sp, 19 /* Null */);
    };

    EvaluationStack.prototype.dup = function dup() {
        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.sp;

        this.stack.copy(position, ++this.sp);
    };

    EvaluationStack.prototype.copy = function copy(from, to) {
        this.stack.copy(from, to);
    };

    EvaluationStack.prototype.pop = function pop() {
        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        var top = this.stack.get(this.sp);
        this.sp -= n;
        return top;
    };

    EvaluationStack.prototype.popSmi = function popSmi() {
        return this.stack.getSmi(this.sp--);
    };

    EvaluationStack.prototype.peek = function peek() {
        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        return this.stack.get(this.sp - offset);
    };

    EvaluationStack.prototype.peekSmi = function peekSmi() {
        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        return this.stack.getSmi(this.sp - offset);
    };

    EvaluationStack.prototype.get = function get$$1(offset) {
        var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.fp;

        return this.stack.get(base + offset);
    };

    EvaluationStack.prototype.getSmi = function getSmi(offset) {
        var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.fp;

        return this.stack.getSmi(base + offset);
    };

    EvaluationStack.prototype.set = function set$$1(value, offset) {
        var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.fp;

        this.stack.write(base + offset, value);
    };

    EvaluationStack.prototype.slice = function slice(start, end) {
        return this.stack.slice(start, end);
    };

    EvaluationStack.prototype.sliceArray = function sliceArray(start, end) {
        return this.stack.sliceInner(start, end);
    };

    EvaluationStack.prototype.capture = function capture(items) {
        var end = this.sp + 1;
        var start = end - items;
        return this.stack.sliceInner(start, end);
    };

    EvaluationStack.prototype.reset = function reset() {
        this.stack.reset();
    };

    EvaluationStack.prototype.toArray = function toArray$$1() {
        return this.stack.sliceInner(this.fp, this.sp + 1);
    };

    return EvaluationStack;
}();

function isImmediate(value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    if (value === null || value === undefined) return true;
    switch (type) {
        case 'boolean':
        case 'undefined':
            return true;
        case 'number':
            // not an integer
            if (value % 1 !== 0) return false;
            var abs = Math.abs(value);
            // too big
            if (abs & HI) return false;
            return true;
        default:
            return false;
    }
}
function encodeSmi(primitive) {
    if (primitive < 0) {
        return Math.abs(primitive) << 3 | 4 /* NEGATIVE */;
    } else {
        return primitive << 3 | 0 /* NUMBER */;
    }
}
function encodeImmediate(primitive) {
    switch (typeof primitive === 'undefined' ? 'undefined' : _typeof(primitive)) {
        case 'number':
            return encodeSmi(primitive);
        case 'boolean':
            return primitive ? 11 /* True */ : 3 /* False */;
        case 'object':
            // assume null
            return 19 /* Null */;
        case 'undefined':
            return 27 /* Undef */;
        default:
            throw unreachable();
    }
}
function decodeSmi(smi) {
    switch (smi & 7) {
        case 0 /* NUMBER */:
            return smi >> 3;
        case 4 /* NEGATIVE */:
            return -(smi >> 3);
        default:
            throw unreachable();
    }
}
function decodeImmediate(immediate) {
    switch (immediate) {
        case 3 /* False */:
            return false;
        case 11 /* True */:
            return true;
        case 19 /* Null */:
            return null;
        case 27 /* Undef */:
            return undefined;
        default:
            return decodeSmi(immediate);
    }
}

var UpdatingVM = function () {
    function UpdatingVM(env, program, _ref) {
        var _ref$alwaysRevalidate = _ref.alwaysRevalidate,
            alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;
        classCallCheck(this, UpdatingVM);

        this.frameStack = new Stack();
        this.env = env;
        this.constants = program.constants;
        this.dom = env.getDOM();
        this.alwaysRevalidate = alwaysRevalidate;
    }

    UpdatingVM.prototype.execute = function execute(opcodes, handler) {
        var frameStack = this.frameStack;

        this.try(opcodes, handler);
        while (true) {
            if (frameStack.isEmpty()) break;
            var opcode = this.frame.nextStatement();
            if (opcode === null) {
                this.frameStack.pop();
                continue;
            }
            opcode.evaluate(this);
        }
    };

    UpdatingVM.prototype.goto = function goto(op) {
        this.frame.goto(op);
    };

    UpdatingVM.prototype.try = function _try(ops, handler) {
        this.frameStack.push(new UpdatingVMFrame(ops, handler));
    };

    UpdatingVM.prototype.throw = function _throw() {
        this.frame.handleException();
        this.frameStack.pop();
    };

    createClass(UpdatingVM, [{
        key: 'frame',
        get: function get$$1() {
            return this.frameStack.current;
        }
    }]);
    return UpdatingVM;
}();

var BlockOpcode = function (_UpdatingOpcode) {
    inherits(BlockOpcode, _UpdatingOpcode);

    function BlockOpcode(start, state, bounds$$1, children) {
        classCallCheck(this, BlockOpcode);

        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.start = start;
        _this.state = state;
        _this.type = "block";
        _this.next = null;
        _this.prev = null;
        _this.children = children;
        _this.bounds = bounds$$1;
        return _this;
    }

    BlockOpcode.prototype.parentElement = function parentElement() {
        return this.bounds.parentElement();
    };

    BlockOpcode.prototype.firstNode = function firstNode() {
        return this.bounds.firstNode();
    };

    BlockOpcode.prototype.lastNode = function lastNode() {
        return this.bounds.lastNode();
    };

    BlockOpcode.prototype.evaluate = function evaluate(vm) {
        vm.try(this.children, null);
    };

    BlockOpcode.prototype.destroy = function destroy() {
        this.bounds.destroy();
    };

    BlockOpcode.prototype.didDestroy = function didDestroy() {
        this.state.env.didDestroy(this.bounds);
    };

    return BlockOpcode;
}(UpdatingOpcode);
var TryOpcode = function (_BlockOpcode) {
    inherits(TryOpcode, _BlockOpcode);

    function TryOpcode(start, state, bounds$$1, children) {
        classCallCheck(this, TryOpcode);

        var _this2 = possibleConstructorReturn(this, _BlockOpcode.call(this, start, state, bounds$$1, children));

        _this2.type = "try";
        _this2.tag = _this2._tag = UpdatableTag.create(CONSTANT_TAG);
        return _this2;
    }

    TryOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
        this._tag.inner.update(combineSlice(this.children));
    };

    TryOpcode.prototype.evaluate = function evaluate(vm) {
        vm.try(this.children, this);
    };

    TryOpcode.prototype.handleException = function handleException() {
        var _this3 = this;

        var state = this.state,
            bounds$$1 = this.bounds,
            children = this.children,
            start = this.start,
            prev = this.prev,
            next = this.next;

        children.clear();
        var elementStack = NewElementBuilder.resume(state.env, bounds$$1, bounds$$1.reset(state.env));
        var vm = VM.resume(state, elementStack);
        var updating = new LinkedList();
        vm.execute(start, function (vm) {
            vm.stack = EvaluationStack.restore(state.stack);
            vm.updatingOpcodeStack.push(updating);
            vm.updateWith(_this3);
            vm.updatingOpcodeStack.push(children);
        });
        this.prev = prev;
        this.next = next;
    };

    return TryOpcode;
}(BlockOpcode);

var ListRevalidationDelegate = function () {
    function ListRevalidationDelegate(opcode, marker) {
        classCallCheck(this, ListRevalidationDelegate);

        this.opcode = opcode;
        this.marker = marker;
        this.didInsert = false;
        this.didDelete = false;
        this.map = opcode.map;
        this.updating = opcode['children'];
    }

    ListRevalidationDelegate.prototype.insert = function insert(key, item, memo, before) {
        var map$$1 = this.map,
            opcode = this.opcode,
            updating = this.updating;

        var nextSibling = null;
        var reference = null;
        if (before) {
            reference = map$$1[before];
            nextSibling = reference['bounds'].firstNode();
        } else {
            nextSibling = this.marker;
        }
        var vm = opcode.vmForInsertion(nextSibling);
        var tryOpcode = null;
        var start = opcode.start;

        vm.execute(start, function (vm) {
            map$$1[key] = tryOpcode = vm.iterate(memo, item);
            vm.updatingOpcodeStack.push(new LinkedList());
            vm.updateWith(tryOpcode);
            vm.updatingOpcodeStack.push(tryOpcode.children);
        });
        updating.insertBefore(tryOpcode, reference);
        this.didInsert = true;
    };

    ListRevalidationDelegate.prototype.retain = function retain(_key, _item, _memo) {};

    ListRevalidationDelegate.prototype.move = function move$$1(key, _item, _memo, before) {
        var map$$1 = this.map,
            updating = this.updating;

        var entry = map$$1[key];
        var reference = map$$1[before] || null;
        if (before) {
            move(entry, reference.firstNode());
        } else {
            move(entry, this.marker);
        }
        updating.remove(entry);
        updating.insertBefore(entry, reference);
    };

    ListRevalidationDelegate.prototype.delete = function _delete(key) {
        var map$$1 = this.map;

        var opcode = map$$1[key];
        opcode.didDestroy();
        clear(opcode);
        this.updating.remove(opcode);
        delete map$$1[key];
        this.didDelete = true;
    };

    ListRevalidationDelegate.prototype.done = function done() {
        this.opcode.didInitializeChildren(this.didInsert || this.didDelete);
    };

    return ListRevalidationDelegate;
}();

var ListBlockOpcode = function (_BlockOpcode2) {
    inherits(ListBlockOpcode, _BlockOpcode2);

    function ListBlockOpcode(start, state, bounds$$1, children, artifacts) {
        classCallCheck(this, ListBlockOpcode);

        var _this4 = possibleConstructorReturn(this, _BlockOpcode2.call(this, start, state, bounds$$1, children));

        _this4.type = "list-block";
        _this4.map = dict();
        _this4.lastIterated = INITIAL;
        _this4.artifacts = artifacts;
        var _tag = _this4._tag = UpdatableTag.create(CONSTANT_TAG);
        _this4.tag = combine([artifacts.tag, _tag]);
        return _this4;
    }

    ListBlockOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
        var listDidChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this.lastIterated = this.artifacts.tag.value();
        if (listDidChange) {
            this._tag.inner.update(combineSlice(this.children));
        }
    };

    ListBlockOpcode.prototype.evaluate = function evaluate(vm) {
        var artifacts = this.artifacts,
            lastIterated = this.lastIterated;

        if (!artifacts.tag.validate(lastIterated)) {
            var bounds$$1 = this.bounds;
            var dom = vm.dom;

            var marker = dom.createComment('');
            dom.insertAfter(bounds$$1.parentElement(), marker, bounds$$1.lastNode());
            var target = new ListRevalidationDelegate(this, marker);
            var synchronizer = new IteratorSynchronizer({ target: target, artifacts: artifacts });
            synchronizer.sync();
            this.parentElement().removeChild(marker);
        }
        // Run now-updated updating opcodes
        _BlockOpcode2.prototype.evaluate.call(this, vm);
    };

    ListBlockOpcode.prototype.vmForInsertion = function vmForInsertion(nextSibling) {
        var bounds$$1 = this.bounds,
            state = this.state;

        var elementStack = NewElementBuilder.forInitialRender(state.env, { element: bounds$$1.parentElement(), nextSibling: nextSibling });
        return VM.resume(state, elementStack);
    };

    return ListBlockOpcode;
}(BlockOpcode);

var UpdatingVMFrame = function () {
    function UpdatingVMFrame(ops, exceptionHandler) {
        classCallCheck(this, UpdatingVMFrame);

        this.ops = ops;
        this.exceptionHandler = exceptionHandler;
        this.current = ops.head();
    }

    UpdatingVMFrame.prototype.goto = function goto(op) {
        this.current = op;
    };

    UpdatingVMFrame.prototype.nextStatement = function nextStatement() {
        var current = this.current,
            ops = this.ops;

        if (current) this.current = ops.nextNode(current);
        return current;
    };

    UpdatingVMFrame.prototype.handleException = function handleException() {
        if (this.exceptionHandler) {
            this.exceptionHandler.handleException();
        }
    };

    return UpdatingVMFrame;
}();

var RenderResult = function () {
    function RenderResult(env, program, updating, bounds$$1) {
        classCallCheck(this, RenderResult);

        this.env = env;
        this.program = program;
        this.updating = updating;
        this.bounds = bounds$$1;
    }

    RenderResult.prototype.rerender = function rerender() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { alwaysRevalidate: false },
            _ref$alwaysRevalidate = _ref.alwaysRevalidate,
            alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;

        var env = this.env,
            program = this.program,
            updating = this.updating;

        var vm = new UpdatingVM(env, program, { alwaysRevalidate: alwaysRevalidate });
        vm.execute(updating, this);
    };

    RenderResult.prototype.parentElement = function parentElement() {
        return this.bounds.parentElement();
    };

    RenderResult.prototype.firstNode = function firstNode() {
        return this.bounds.firstNode();
    };

    RenderResult.prototype.lastNode = function lastNode() {
        return this.bounds.lastNode();
    };

    RenderResult.prototype.handleException = function handleException() {
        throw "this should never happen";
    };

    RenderResult.prototype.destroy = function destroy() {
        this.bounds.destroy();
        clear(this.bounds);
    };

    return RenderResult;
}();

var VM = function () {
    function VM(program, env, scope, dynamicScope, elementStack) {
        var _this = this;

        classCallCheck(this, VM);

        this.program = program;
        this.env = env;
        this.elementStack = elementStack;
        this.dynamicScopeStack = new Stack();
        this.scopeStack = new Stack();
        this.updatingOpcodeStack = new Stack();
        this.cacheGroups = new Stack();
        this.listBlockStack = new Stack();
        this.s0 = null;
        this.s1 = null;
        this.t0 = null;
        this.t1 = null;
        this.v0 = null;
        this.env = env;
        this.heap = program.heap;
        this.constants = program.constants;
        this.elementStack = elementStack;
        this.scopeStack.push(scope);
        this.dynamicScopeStack.push(dynamicScope);
        this.inner = new LowLevelVM$1(EvaluationStack.empty(), this.heap, program, {
            debugBefore: function debugBefore(opcode) {
                return APPEND_OPCODES.debugBefore(_this, opcode, opcode.type);
            },
            debugAfter: function debugAfter(opcode, state) {
                APPEND_OPCODES.debugAfter(_this, opcode, opcode.type, state);
            }
        });
    }

    // Fetch a value from a register onto the stack
    VM.prototype.fetch = function fetch(register) {
        this.stack.push(this[Register[register]]);
    };
    // Load a value from the stack into a register


    VM.prototype.load = function load(register) {
        this[Register[register]] = this.stack.pop();
    };
    // Fetch a value from a register


    VM.prototype.fetchValue = function fetchValue(register) {
        return this[Register[register]];
    };
    // Load a value into a register


    VM.prototype.loadValue = function loadValue(register, value) {
        this[Register[register]] = value;
    };
    /**
     * Migrated to Inner
     */
    // Start a new frame and save $ra and $fp on the stack


    VM.prototype.pushFrame = function pushFrame() {
        this.inner.pushFrame();
    };
    // Restore $ra, $sp and $fp


    VM.prototype.popFrame = function popFrame() {
        this.inner.popFrame();
    };
    // Jump to an address in `program`


    VM.prototype.goto = function goto(offset) {
        this.inner.goto(offset);
    };
    // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)


    VM.prototype.call = function call(handle) {
        this.inner.call(handle);
    };
    // Put a specific `program` address in $ra


    VM.prototype.returnTo = function returnTo(offset) {
        this.inner.returnTo(offset);
    };
    // Return to the `program` address stored in $ra


    VM.prototype.return = function _return() {
        this.inner.return();
    };
    /**
     * End of migrated.
     */


    VM.initial = function initial(program, env, self, args, dynamicScope, elementStack, handle) {
        var scopeSize = program.heap.scopesizeof(handle);
        var scope = Scope.root(self, scopeSize);
        if (args) {}
        var vm = new VM(program, env, scope, dynamicScope, elementStack);
        vm.pc = vm.heap.getaddr(handle);
        vm.updatingOpcodeStack.push(new LinkedList());
        return vm;
    };

    VM.empty = function empty(program, env, elementStack) {
        var dynamicScope = {
            get: function get$$1() {
                return UNDEFINED_REFERENCE;
            },
            set: function set$$1() {
                return UNDEFINED_REFERENCE;
            },
            child: function child() {
                return dynamicScope;
            }
        };
        var vm = new VM(program, env, Scope.root(UNDEFINED_REFERENCE, 0), dynamicScope, elementStack);
        vm.updatingOpcodeStack.push(new LinkedList());
        return vm;
    };

    VM.resume = function resume(_ref, stack) {
        var program = _ref.program,
            env = _ref.env,
            scope = _ref.scope,
            dynamicScope = _ref.dynamicScope;

        return new VM(program, env, scope, dynamicScope, stack);
    };

    VM.prototype.capture = function capture(args) {
        return {
            env: this.env,
            program: this.program,
            dynamicScope: this.dynamicScope(),
            scope: this.scope(),
            stack: this.stack.capture(args)
        };
    };

    VM.prototype.beginCacheGroup = function beginCacheGroup() {
        this.cacheGroups.push(this.updating().tail());
    };

    VM.prototype.commitCacheGroup = function commitCacheGroup() {
        //        JumpIfNotModified(END)
        //        (head)
        //        (....)
        //        (tail)
        //        DidModify
        // END:   Noop
        var END = new LabelOpcode("END");
        var opcodes = this.updating();
        var marker = this.cacheGroups.pop();
        var head = marker ? opcodes.nextNode(marker) : opcodes.head();
        var tail = opcodes.tail();
        var tag = combineSlice(new ListSlice(head, tail));
        var guard = new JumpIfNotModifiedOpcode(tag, END);
        opcodes.insertBefore(guard, head);
        opcodes.append(new DidModifyOpcode(guard));
        opcodes.append(END);
    };

    VM.prototype.enter = function enter(args) {
        var updating = new LinkedList();
        var state = this.capture(args);
        var tracker = this.elements().pushUpdatableBlock();
        var tryOpcode = new TryOpcode(this.heap.gethandle(this.pc), state, tracker, updating);
        this.didEnter(tryOpcode);
    };

    VM.prototype.iterate = function iterate(memo, value) {
        var stack = this.stack;
        stack.push(value);
        stack.push(memo);
        var state = this.capture(2);
        var tracker = this.elements().pushUpdatableBlock();
        // let ip = this.ip;
        // this.ip = end + 4;
        // this.frames.push(ip);
        return new TryOpcode(this.heap.gethandle(this.pc), state, tracker, new LinkedList());
    };

    VM.prototype.enterItem = function enterItem(key, opcode) {
        this.listBlock().map[key] = opcode;
        this.didEnter(opcode);
    };

    VM.prototype.enterList = function enterList(relativeStart) {
        var updating = new LinkedList();
        var state = this.capture(0);
        var tracker = this.elements().pushBlockList(updating);
        var artifacts = this.stack.peek().artifacts;
        var addr = this.pc + relativeStart - this.currentOpSize;
        var start = this.heap.gethandle(addr);
        var opcode = new ListBlockOpcode(start, state, tracker, updating, artifacts);
        this.listBlockStack.push(opcode);
        this.didEnter(opcode);
    };

    VM.prototype.didEnter = function didEnter(opcode) {
        this.updateWith(opcode);
        this.updatingOpcodeStack.push(opcode.children);
    };

    VM.prototype.exit = function exit() {
        this.elements().popBlock();
        this.updatingOpcodeStack.pop();
        var parent = this.updating().tail();
        parent.didInitializeChildren();
    };

    VM.prototype.exitList = function exitList() {
        this.exit();
        this.listBlockStack.pop();
    };

    VM.prototype.updateWith = function updateWith(opcode) {
        this.updating().append(opcode);
    };

    VM.prototype.listBlock = function listBlock() {
        return this.listBlockStack.current;
    };

    VM.prototype.updating = function updating() {
        return this.updatingOpcodeStack.current;
    };

    VM.prototype.elements = function elements() {
        return this.elementStack;
    };

    VM.prototype.scope = function scope() {
        return this.scopeStack.current;
    };

    VM.prototype.dynamicScope = function dynamicScope() {
        return this.dynamicScopeStack.current;
    };

    VM.prototype.pushChildScope = function pushChildScope() {
        this.scopeStack.push(this.scope().child());
    };

    VM.prototype.pushDynamicScope = function pushDynamicScope() {
        var child = this.dynamicScope().child();
        this.dynamicScopeStack.push(child);
        return child;
    };

    VM.prototype.pushRootScope = function pushRootScope(size, bindCaller) {
        var scope = Scope.sized(size);
        if (bindCaller) scope.bindCallerScope(this.scope());
        this.scopeStack.push(scope);
        return scope;
    };

    VM.prototype.pushScope = function pushScope(scope) {
        this.scopeStack.push(scope);
    };

    VM.prototype.popScope = function popScope() {
        this.scopeStack.pop();
    };

    VM.prototype.popDynamicScope = function popDynamicScope() {
        this.dynamicScopeStack.pop();
    };

    VM.prototype.newDestroyable = function newDestroyable(d) {
        this.elements().didAddDestroyable(d);
    };
    /// SCOPE HELPERS


    VM.prototype.getSelf = function getSelf() {
        return this.scope().getSelf();
    };

    VM.prototype.referenceForSymbol = function referenceForSymbol(symbol) {
        return this.scope().getSymbol(symbol);
    };
    /// EXECUTION


    VM.prototype.execute = function execute(start, initialize) {
        this.pc = this.heap.getaddr(start);
        if (initialize) initialize(this);
        var result = void 0;
        while (true) {
            result = this.next();
            if (result.done) break;
        }
        return result.value;
    };

    VM.prototype.next = function next() {
        var env = this.env,
            program = this.program,
            updatingOpcodeStack = this.updatingOpcodeStack,
            elementStack = this.elementStack;

        var opcode = this.inner.nextStatement();
        var result = void 0;
        if (opcode !== null) {
            this.inner.evaluateOuter(opcode, this);
            result = { done: false, value: null };
        } else {
            // Unload the stack
            this.stack.reset();
            result = {
                done: true,
                value: new RenderResult(env, program, updatingOpcodeStack.pop(), elementStack.popBlock())
            };
        }
        return result;
    };

    VM.prototype.bindDynamicScope = function bindDynamicScope(names) {
        var scope = this.dynamicScope();
        for (var i = names.length - 1; i >= 0; i--) {
            var name = this.constants.getString(names[i]);
            scope.set(name, this.stack.pop());
        }
    };

    createClass(VM, [{
        key: 'stack',
        get: function get$$1() {
            return this.inner.stack;
        },
        set: function set$$1(value) {
            this.inner.stack = value;
        }
        /* Registers */

    }, {
        key: 'currentOpSize',
        set: function set$$1(value) {
            this.inner.currentOpSize = value;
        },
        get: function get$$1() {
            return this.inner.currentOpSize;
        }
    }, {
        key: 'pc',
        get: function get$$1() {
            return this.inner.pc;
        },
        set: function set$$1(value) {
            false && debugAssert(typeof value === 'number' && value >= -1, 'invalid pc: ' + value);

            this.inner.pc = value;
        }
    }, {
        key: 'ra',
        get: function get$$1() {
            return this.inner.ra;
        },
        set: function set$$1(value) {
            this.inner.ra = value;
        }
    }, {
        key: 'fp',
        get: function get$$1() {
            return this.stack.fp;
        },
        set: function set$$1(fp) {
            this.stack.fp = fp;
        }
    }, {
        key: 'sp',
        get: function get$$1() {
            return this.stack.sp;
        },
        set: function set$$1(sp) {
            this.stack.sp = sp;
        }
    }]);
    return VM;
}();

var TemplateIterator = function () {
    function TemplateIterator(vm) {
        classCallCheck(this, TemplateIterator);

        this.vm = vm;
    }

    TemplateIterator.prototype.next = function next() {
        return this.vm.next();
    };

    return TemplateIterator;
}();
var clientId = 0;
function templateFactory(_ref) {
    var templateId = _ref.id,
        meta = _ref.meta,
        block = _ref.block;

    var parsedBlock = void 0;
    var id = templateId || 'client-' + clientId++;
    var create = function create(options, envMeta) {
        var newMeta = envMeta ? assign({}, envMeta, meta) : meta;
        if (!parsedBlock) {
            parsedBlock = JSON.parse(block);
        }
        return new ScannableTemplate(options, { id: id, block: parsedBlock, referrer: newMeta });
    };
    return { id: id, meta: meta, create: create };
}
var ScannableTemplate = function () {
    function ScannableTemplate(options, parsedLayout) {
        classCallCheck(this, ScannableTemplate);

        this.options = options;
        this.parsedLayout = parsedLayout;
        this.layout = null;
        this.partial = null;
        var block = parsedLayout.block;

        this.symbols = block.symbols;
        this.hasEval = block.hasEval;
        this.statements = block.statements;
        this.referrer = parsedLayout.referrer;
        this.id = parsedLayout.id || 'client-' + clientId++;
    }

    ScannableTemplate.prototype.renderLayout = function renderLayout(options) {
        var env = options.env,
            self = options.self,
            dynamicScope = options.dynamicScope,
            _options$args = options.args,
            args = _options$args === undefined ? EMPTY_ARGS : _options$args,
            builder = options.builder;

        var layout = this.asLayout();
        var handle = layout.compile();
        var vm = VM.initial(this.options.program, env, self, args, dynamicScope, builder, handle);
        return new TemplateIterator(vm);
    };

    ScannableTemplate.prototype.asLayout = function asLayout() {
        if (this.layout) return this.layout;
        return this.layout = compilable(this.parsedLayout, this.options, false);
    };

    ScannableTemplate.prototype.asPartial = function asPartial() {
        if (this.partial) return this.partial;
        return this.partial = compilable(this.parsedLayout, this.options, true);
    };

    return ScannableTemplate;
}();
function compilable(layout, options, asPartial) {
    var block = layout.block,
        referrer = layout.referrer;
    var hasEval = block.hasEval,
        symbols = block.symbols;

    var compileOptions = assign({}, options, { asPartial: asPartial, referrer: referrer });
    return new CompilableTemplate(block.statements, layout, compileOptions, { referrer: referrer, hasEval: hasEval, symbols: symbols });
}

/** @internal */

/** @internal */

var RehydratingCursor = function (_Cursor) {
    inherits(RehydratingCursor, _Cursor);

    function RehydratingCursor(element, nextSibling, startingBlockDepth) {
        classCallCheck(this, RehydratingCursor);

        var _this = possibleConstructorReturn(this, _Cursor.call(this, element, nextSibling));

        _this.startingBlockDepth = startingBlockDepth;
        _this.candidate = null;
        _this.injectedOmittedNode = false;
        _this.openBlockDepth = startingBlockDepth - 1;
        return _this;
    }

    return RehydratingCursor;
}(Cursor);
var RehydrateBuilder = function (_NewElementBuilder) {
    inherits(RehydrateBuilder, _NewElementBuilder);

    // private candidate: Option<Simple.Node> = null;
    function RehydrateBuilder(env, parentNode, nextSibling) {
        classCallCheck(this, RehydrateBuilder);

        var _this2 = possibleConstructorReturn(this, _NewElementBuilder.call(this, env, parentNode, nextSibling));

        _this2.unmatchedAttributes = null;
        _this2.blockDepth = 0;
        if (nextSibling) throw new Error("Rehydration with nextSibling not supported");
        _this2.candidate = _this2.currentCursor.element.firstChild;
        false && debugAssert(_this2.candidate && isComment(_this2.candidate) && _this2.candidate.nodeValue === '%+b:0%', 'Must have opening comment <!--%+b:0%--> for rehydration.');
        return _this2;
    }

    RehydrateBuilder.prototype.pushElement = function pushElement(element, nextSibling) {
        var _blockDepth = this.blockDepth,
            blockDepth = _blockDepth === undefined ? 0 : _blockDepth;

        var cursor = new RehydratingCursor(element, nextSibling, blockDepth);
        var currentCursor = this.currentCursor;
        if (currentCursor) {
            if (currentCursor.candidate) {
                /**
                 * <div>   <---------------  currentCursor.element
                 *   <!--%+b:1%-->
                 *   <div> <---------------  currentCursor.candidate -> cursor.element
                 *     <!--%+b:2%--> <-  currentCursor.candidate.firstChild -> cursor.candidate
                 *     Foo
                 *     <!--%-b:2%-->
                 *   </div>
                 *   <!--%-b:1%-->  <--  becomes currentCursor.candidate
                 */
                // where to rehydrate from if we are in rehydration mode
                cursor.candidate = element.firstChild;
                // where to continue when we pop
                currentCursor.candidate = element.nextSibling;
            }
        }
        this.cursorStack.push(cursor);
    };

    RehydrateBuilder.prototype.clearMismatch = function clearMismatch(candidate) {
        var current = candidate;
        var currentCursor = this.currentCursor;
        if (currentCursor !== null) {
            var openBlockDepth = currentCursor.openBlockDepth;
            if (openBlockDepth >= currentCursor.startingBlockDepth) {
                while (current && !(isComment(current) && getCloseBlockDepth(current) === openBlockDepth)) {
                    current = this.remove(current);
                }
                false && debugAssert(current !== null, 'should have found closing block');
            } else {
                while (current !== null) {
                    current = this.remove(current);
                }
            }
            // current cursor parentNode should be openCandidate if element
            // or openCandidate.parentNode if comment
            currentCursor.nextSibling = current;
            // disable rehydration until we popElement or closeBlock for openBlockDepth
            currentCursor.candidate = null;
        }
    };

    RehydrateBuilder.prototype.__openBlock = function __openBlock() {
        var currentCursor = this.currentCursor;

        if (currentCursor === null) return;
        var blockDepth = this.blockDepth;
        this.blockDepth++;
        var candidate = currentCursor.candidate;

        if (candidate === null) return;
        if (isComment(candidate) && getOpenBlockDepth(candidate) === blockDepth) {
            currentCursor.candidate = this.remove(candidate);
            currentCursor.openBlockDepth = blockDepth;
        } else {
            this.clearMismatch(candidate);
        }
    };

    RehydrateBuilder.prototype.__closeBlock = function __closeBlock() {
        var currentCursor = this.currentCursor;

        if (currentCursor === null) return;
        // openBlock is the last rehydrated open block
        var openBlockDepth = currentCursor.openBlockDepth;
        // this currently is the expected next open block depth
        this.blockDepth--;
        var candidate = currentCursor.candidate;
        // rehydrating

        if (candidate !== null) {
            false && debugAssert(openBlockDepth === this.blockDepth, 'when rehydrating, openBlockDepth should match this.blockDepth here');

            if (isComment(candidate) && getCloseBlockDepth(candidate) === openBlockDepth) {
                currentCursor.candidate = this.remove(candidate);
                currentCursor.openBlockDepth--;
            } else {
                this.clearMismatch(candidate);
            }
            // if the openBlockDepth matches the blockDepth we just closed to
            // then restore rehydration
        }
        if (currentCursor.openBlockDepth === this.blockDepth) {
            false && debugAssert(currentCursor.nextSibling !== null && isComment(currentCursor.nextSibling) && getCloseBlockDepth(currentCursor.nextSibling) === openBlockDepth, "expected close block to match rehydrated open block");

            currentCursor.candidate = this.remove(currentCursor.nextSibling);
            currentCursor.openBlockDepth--;
        }
    };

    RehydrateBuilder.prototype.__appendNode = function __appendNode(node) {
        var candidate = this.candidate;
        // This code path is only used when inserting precisely one node. It needs more
        // comparison logic, but we can probably lean on the cases where this code path
        // is actually used.

        if (candidate) {
            return candidate;
        } else {
            return _NewElementBuilder.prototype.__appendNode.call(this, node);
        }
    };

    RehydrateBuilder.prototype.__appendHTML = function __appendHTML(html) {
        var candidateBounds = this.markerBounds();
        if (candidateBounds) {
            var first = candidateBounds.firstNode();
            var last = candidateBounds.lastNode();
            var newBounds = bounds(this.element, first.nextSibling, last.previousSibling);
            this.remove(first);
            this.remove(last);
            return newBounds;
        } else {
            return _NewElementBuilder.prototype.__appendHTML.call(this, html);
        }
    };

    RehydrateBuilder.prototype.remove = function remove(node) {
        var element = node.parentNode;
        var next = node.nextSibling;
        element.removeChild(node);
        return next;
    };

    RehydrateBuilder.prototype.markerBounds = function markerBounds() {
        var _candidate = this.candidate;
        if (_candidate && isMarker(_candidate)) {
            var first = _candidate;
            var last = first.nextSibling;
            while (last && !isMarker(last)) {
                last = last.nextSibling;
            }
            return bounds(this.element, first, last);
        } else {
            return null;
        }
    };

    RehydrateBuilder.prototype.__appendText = function __appendText(string) {
        var candidate = this.candidate;

        if (candidate) {
            if (isTextNode(candidate)) {
                if (candidate.nodeValue !== string) {
                    candidate.nodeValue = string;
                }
                this.candidate = candidate.nextSibling;
                return candidate;
            } else if (candidate && (isSeparator(candidate) || isEmpty$1(candidate))) {
                this.candidate = candidate.nextSibling;
                this.remove(candidate);
                return this.__appendText(string);
            } else if (isEmpty$1(candidate)) {
                var next = this.remove(candidate);
                this.candidate = next;
                var text = this.dom.createTextNode(string);
                this.dom.insertBefore(this.element, text, next);
                return text;
            } else {
                this.clearMismatch(candidate);
                return _NewElementBuilder.prototype.__appendText.call(this, string);
            }
        } else {
            return _NewElementBuilder.prototype.__appendText.call(this, string);
        }
    };

    RehydrateBuilder.prototype.__appendComment = function __appendComment(string) {
        var _candidate = this.candidate;
        if (_candidate && isComment(_candidate)) {
            if (_candidate.nodeValue !== string) {
                _candidate.nodeValue = string;
            }
            this.candidate = _candidate.nextSibling;
            return _candidate;
        } else if (_candidate) {
            this.clearMismatch(_candidate);
        }
        return _NewElementBuilder.prototype.__appendComment.call(this, string);
    };

    RehydrateBuilder.prototype.__openElement = function __openElement(tag) {
        var _candidate = this.candidate;
        if (_candidate && isElement(_candidate) && isSameNodeType(_candidate, tag)) {
            this.unmatchedAttributes = [].slice.call(_candidate.attributes);
            return _candidate;
        } else if (_candidate) {
            if (isElement(_candidate) && _candidate.tagName === 'TBODY') {
                this.pushElement(_candidate, null);
                this.currentCursor.injectedOmittedNode = true;
                return this.__openElement(tag);
            }
            this.clearMismatch(_candidate);
        }
        return _NewElementBuilder.prototype.__openElement.call(this, tag);
    };

    RehydrateBuilder.prototype.__setAttribute = function __setAttribute(name, value, namespace) {
        var unmatched = this.unmatchedAttributes;
        if (unmatched) {
            var attr = findByName(unmatched, name);
            if (attr) {
                if (attr.value !== value) {
                    attr.value = value;
                }
                unmatched.splice(unmatched.indexOf(attr), 1);
                return;
            }
        }
        return _NewElementBuilder.prototype.__setAttribute.call(this, name, value, namespace);
    };

    RehydrateBuilder.prototype.__setProperty = function __setProperty(name, value) {
        var unmatched = this.unmatchedAttributes;
        if (unmatched) {
            var attr = findByName(unmatched, name);
            if (attr) {
                if (attr.value !== value) {
                    attr.value = value;
                }
                unmatched.splice(unmatched.indexOf(attr), 1);
                return;
            }
        }
        return _NewElementBuilder.prototype.__setProperty.call(this, name, value);
    };

    RehydrateBuilder.prototype.__flushElement = function __flushElement(parent, constructing) {
        var unmatched = this.unmatchedAttributes;

        if (unmatched) {
            for (var i = 0; i < unmatched.length; i++) {
                this.constructing.removeAttribute(unmatched[i].name);
            }
            this.unmatchedAttributes = null;
        } else {
            _NewElementBuilder.prototype.__flushElement.call(this, parent, constructing);
        }
    };

    RehydrateBuilder.prototype.appendCautiousDynamicContent = function appendCautiousDynamicContent(value) {
        var content = _NewElementBuilder.prototype.appendCautiousDynamicContent.call(this, value);
        content.update(this.env, value);
        return content;
    };

    RehydrateBuilder.prototype.willCloseElement = function willCloseElement() {
        var candidate = this.candidate,
            currentCursor = this.currentCursor;

        if (candidate !== null) {
            this.clearMismatch(candidate);
        }
        if (currentCursor && currentCursor.injectedOmittedNode) {
            this.popElement();
        }
        _NewElementBuilder.prototype.willCloseElement.call(this);
    };

    RehydrateBuilder.prototype.getMarker = function getMarker(element, guid) {
        var marker = element.querySelector("script[glmr=\"" + guid + "\"]");
        if (marker) {
            return marker;
        }
        throw new Error('Cannot find serialized cursor for `in-element`');
    };

    RehydrateBuilder.prototype.__pushRemoteElement = function __pushRemoteElement(element, cursorId) {
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var marker = this.getMarker(element, cursorId);
        if (marker.parentNode === element) {
            var currentCursor = this.currentCursor;
            var candidate = currentCursor.candidate;
            this.pushElement(element, nextSibling);
            currentCursor.candidate = candidate;
            this.candidate = this.remove(marker);
            var tracker = new RemoteBlockTracker(element);
            this.pushBlockTracker(tracker, true);
        }
    };

    RehydrateBuilder.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {
        _NewElementBuilder.prototype.didAppendBounds.call(this, bounds$$1);
        if (this.candidate) {
            var last = bounds$$1.lastNode();
            this.candidate = last && last.nextSibling;
        }
        return bounds$$1;
    };

    createClass(RehydrateBuilder, [{
        key: "currentCursor",
        get: function get$$1() {
            return this.cursorStack.current;
        }
    }, {
        key: "candidate",
        get: function get$$1() {
            if (this.currentCursor) {
                return this.currentCursor.candidate;
            }
            return null;
        },
        set: function set$$1(node) {
            this.currentCursor.candidate = node;
        }
    }]);
    return RehydrateBuilder;
}(NewElementBuilder);
function isTextNode(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
function getOpenBlockDepth(node) {
    var boundsDepth = node.nodeValue.match(/^%\+b:(\d+)%$/);
    if (boundsDepth && boundsDepth[1]) {
        return Number(boundsDepth[1]);
    } else {
        return null;
    }
}
function getCloseBlockDepth(node) {
    var boundsDepth = node.nodeValue.match(/^%\-b:(\d+)%$/);
    if (boundsDepth && boundsDepth[1]) {
        return Number(boundsDepth[1]);
    } else {
        return null;
    }
}
function isElement(node) {
    return node.nodeType === 1;
}
function isMarker(node) {
    return node.nodeType === 8 && node.nodeValue === '%glmr%';
}
function isSeparator(node) {
    return node.nodeType === 8 && node.nodeValue === '%|%';
}
function isEmpty$1(node) {
    return node.nodeType === 8 && node.nodeValue === '% %';
}
function isSameNodeType(candidate, tag) {
    if (candidate.namespaceURI === SVG_NAMESPACE$$1) {
        return candidate.tagName === tag;
    }
    return candidate.tagName === tag.toUpperCase();
}
function findByName(array, name) {
    for (var i = 0; i < array.length; i++) {
        var attr = array[i];
        if (attr.name === name) return attr;
    }
    return undefined;
}
function rehydrationBuilder(env, cursor) {
    return RehydrateBuilder.forInitialRender(env, cursor);
}

/**
 * The base PathReference.
 */
var ComponentPathReference = function () {
    function ComponentPathReference() {
        classCallCheck(this, ComponentPathReference);
    }

    ComponentPathReference.prototype.get = function get$$1(key) {
        return PropertyReference.create(this, key);
    };

    return ComponentPathReference;
}();
var CachedReference$1 = function (_ComponentPathReferen) {
    inherits(CachedReference$$1, _ComponentPathReferen);

    function CachedReference$$1() {
        classCallCheck(this, CachedReference$$1);

        var _this = possibleConstructorReturn(this, _ComponentPathReferen.apply(this, arguments));

        _this._lastRevision = null;
        _this._lastValue = null;
        return _this;
    }

    CachedReference$$1.prototype.value = function value() {
        var tag = this.tag,
            _lastRevision = this._lastRevision,
            _lastValue = this._lastValue;

        if (!_lastRevision || !tag.validate(_lastRevision)) {
            _lastValue = this._lastValue = this.compute();
            this._lastRevision = tag.value();
        }
        return _lastValue;
    };

    return CachedReference$$1;
}(ComponentPathReference);
var RootReference = function (_ConstReference) {
    inherits(RootReference, _ConstReference);

    function RootReference() {
        classCallCheck(this, RootReference);

        var _this2 = possibleConstructorReturn(this, _ConstReference.apply(this, arguments));

        _this2.children = dict();
        return _this2;
    }

    RootReference.prototype.get = function get$$1(propertyKey) {
        var ref = this.children[propertyKey];
        if (!ref) {
            ref = this.children[propertyKey] = new RootPropertyReference(this.inner, propertyKey);
        }
        return ref;
    };

    return RootReference;
}(ConstReference);
var PropertyReference = function (_CachedReference) {
    inherits(PropertyReference, _CachedReference);

    function PropertyReference() {
        classCallCheck(this, PropertyReference);
        return possibleConstructorReturn(this, _CachedReference.apply(this, arguments));
    }

    PropertyReference.create = function create(parentReference, propertyKey) {
        if (isConst(parentReference)) {
            return new RootPropertyReference(parentReference.value(), propertyKey);
        } else {
            return new NestedPropertyReference(parentReference, propertyKey);
        }
    };

    PropertyReference.prototype.get = function get$$1(key) {
        return new NestedPropertyReference(this, key);
    };

    return PropertyReference;
}(CachedReference$1);
var RootPropertyReference = function (_PropertyReference) {
    inherits(RootPropertyReference, _PropertyReference);

    function RootPropertyReference(parentValue, propertyKey) {
        classCallCheck(this, RootPropertyReference);

        var _this4 = possibleConstructorReturn(this, _PropertyReference.call(this));

        _this4._parentValue = parentValue;
        _this4._propertyKey = propertyKey;
        _this4.tag = tagForProperty(parentValue, propertyKey);
        return _this4;
    }

    RootPropertyReference.prototype.compute = function compute() {
        return this._parentValue[this._propertyKey];
    };

    return RootPropertyReference;
}(PropertyReference);
var NestedPropertyReference = function (_PropertyReference2) {
    inherits(NestedPropertyReference, _PropertyReference2);

    function NestedPropertyReference(parentReference, propertyKey) {
        classCallCheck(this, NestedPropertyReference);

        var _this5 = possibleConstructorReturn(this, _PropertyReference2.call(this));

        var parentReferenceTag = parentReference.tag;
        var parentObjectTag = UpdatableTag.create(CONSTANT_TAG);
        _this5._parentReference = parentReference;
        _this5._parentObjectTag = parentObjectTag;
        _this5._propertyKey = propertyKey;
        _this5.tag = combine([parentReferenceTag, parentObjectTag]);
        return _this5;
    }

    NestedPropertyReference.prototype.compute = function compute() {
        var _parentReference = this._parentReference,
            _parentObjectTag = this._parentObjectTag,
            _propertyKey = this._propertyKey;

        var parentValue = _parentReference.value();
        _parentObjectTag.inner.update(tagForProperty(parentValue, _propertyKey));
        if (typeof parentValue === "string" && _propertyKey === "length") {
            return parentValue.length;
        }
        if ((typeof parentValue === "undefined" ? "undefined" : _typeof(parentValue)) === "object" && parentValue) {
            return parentValue[_propertyKey];
        } else {
            return undefined;
        }
    };

    return NestedPropertyReference;
}(PropertyReference);
var UpdatableReference = function (_ComponentPathReferen2) {
    inherits(UpdatableReference, _ComponentPathReferen2);

    function UpdatableReference(value) {
        classCallCheck(this, UpdatableReference);

        var _this6 = possibleConstructorReturn(this, _ComponentPathReferen2.call(this));

        _this6.tag = DirtyableTag.create();
        _this6._value = value;
        return _this6;
    }

    UpdatableReference.prototype.value = function value() {
        return this._value;
    };

    UpdatableReference.prototype.update = function update(value) {
        var _value = this._value;

        if (value !== _value) {
            this.tag.inner.dirty();
            this._value = value;
        }
    };

    return UpdatableReference;
}(ComponentPathReference);
var ConditionalReference$$1 = function (_GlimmerConditionalRe) {
    inherits(ConditionalReference$$1, _GlimmerConditionalRe);

    function ConditionalReference$$1() {
        classCallCheck(this, ConditionalReference$$1);
        return possibleConstructorReturn(this, _GlimmerConditionalRe.apply(this, arguments));
    }

    ConditionalReference$$1.create = function create(reference) {
        if (isConst(reference)) {
            var value = reference.value();
            return PrimitiveReference.create(value);
        }
        return new ConditionalReference$$1(reference);
    };

    return ConditionalReference$$1;
}(ConditionalReference$1);
var TemplateOnlyComponentDebugReference = function (_ConstReference2) {
    inherits(TemplateOnlyComponentDebugReference, _ConstReference2);

    function TemplateOnlyComponentDebugReference(name) {
        classCallCheck(this, TemplateOnlyComponentDebugReference);

        var _this8 = possibleConstructorReturn(this, _ConstReference2.call(this, undefined));

        _this8.name = name;
        return _this8;
    }

    TemplateOnlyComponentDebugReference.prototype.get = function get$$1(propertyKey) {
        throw new Error("You tried to reference {{" + propertyKey + "}} from the " + this.name + " template, which doesn't have an associated component class. Template-only components can only access args passed to them. Did you mean {{@" + propertyKey + "}}?");
    };

    return TemplateOnlyComponentDebugReference;
}(ConstReference);

var ComponentStateBucket = function () {
    function ComponentStateBucket(definition, args, owner) {
        classCallCheck(this, ComponentStateBucket);

        var componentFactory = definition.ComponentClass;
        var name = definition.name;
        this.args = args;
        var injections = {
            debugName: name,
            args: this.namedArgsSnapshot()
        };
        setOwner(injections, owner);
        if (componentFactory) {
            this.component = componentFactory.create(injections);
        }
    }

    ComponentStateBucket.prototype.namedArgsSnapshot = function namedArgsSnapshot() {
        return Object.freeze(this.args.named.value());
    };

    createClass(ComponentStateBucket, [{
        key: 'tag',
        get: function get$$1() {
            return this.args.tag;
        }
    }]);
    return ComponentStateBucket;
}();
var EMPTY_SELF = new RootReference(null);
/**
 * For performance reasons, we want to avoid instantiating component buckets for
 * components that don't have an associated component class that we would need
 * instantiate and invoke lifecycle hooks on.
 *
 * In development mode, however, we need to track some state about the component
 * in order to produce more useful error messages. This
 * TemplateOnlyComponentDebugBucket is only created in development mode to hold
 * that state.
 */
var TemplateOnlyComponentDebugBucket = function TemplateOnlyComponentDebugBucket(definition) {
    classCallCheck(this, TemplateOnlyComponentDebugBucket);

    this.definition = definition;
};

var ComponentManager = function () {
    ComponentManager.create = function create(options) {
        return new ComponentManager(options);
    };

    function ComponentManager(options) {
        classCallCheck(this, ComponentManager);

        this.env = options.env;
    }

    ComponentManager.prototype.prepareArgs = function prepareArgs(state, args) {
        return null;
    };

    ComponentManager.prototype.getCapabilities = function getCapabilities(state) {
        return state.capabilities;
    };

    ComponentManager.prototype.getLayout = function getLayout(_ref, resolver) {
        var name = _ref.name,
            handle = _ref.handle,
            symbolTable = _ref.symbolTable;

        if (handle && symbolTable) {
            return {
                handle: handle,
                symbolTable: symbolTable
            };
        }
        return resolver.compileTemplate(name, handle);
    };

    ComponentManager.prototype.create = function create(_env, definition, args, _dynamicScope, _caller, _hasDefaultBlock) {
        // In development mode, if a component is template-only, save off state
        // needed for error messages. This will get stripped in production mode and
        // no bucket will be instantiated.
        if (false && !definition.ComponentClass) {
            return new TemplateOnlyComponentDebugBucket(definition);
        }
        // Only create a state bucket if the component is actually stateful. We can
        // skip this for template-only components, which are pure functions.
        if (definition.ComponentClass) {
            var owner = getOwner(this.env);
            return new ComponentStateBucket(definition, args.capture(), owner);
        }
    };

    ComponentManager.prototype.getSelf = function getSelf(bucket) {
        if (false && bucket instanceof TemplateOnlyComponentDebugBucket) {
            return new TemplateOnlyComponentDebugReference(bucket.definition.name);
        }
        if (bucket) {
            return new RootReference(bucket.component);
        }
        return EMPTY_SELF;
    };

    ComponentManager.prototype.didCreateElement = function didCreateElement(bucket, element) {};

    ComponentManager.prototype.didRenderLayout = function didRenderLayout(bucket, bounds) {
        if (false && bucket instanceof TemplateOnlyComponentDebugBucket) {
            return;
        }
        if (!bucket) {
            return;
        }
        bucket.component.bounds = new Bounds(bounds);
    };

    ComponentManager.prototype.didCreate = function didCreate(bucket) {
        if (false && bucket instanceof TemplateOnlyComponentDebugBucket) {
            return;
        }
        if (!bucket) {
            return;
        }
        bucket.component.didInsertElement();
    };

    ComponentManager.prototype.getTag = function getTag(bucket) {
        if (false && bucket instanceof TemplateOnlyComponentDebugBucket) {
            return CONSTANT_TAG;
        }
        if (!bucket) {
            return CONSTANT_TAG;
        }
        return bucket.tag;
    };

    ComponentManager.prototype.update = function update(bucket, scope) {
        if (false && bucket instanceof TemplateOnlyComponentDebugBucket) {
            return;
        }
        if (!bucket) {
            return;
        }
        bucket.component.args = bucket.namedArgsSnapshot();
    };

    ComponentManager.prototype.didUpdateLayout = function didUpdateLayout() {};

    ComponentManager.prototype.didUpdate = function didUpdate(bucket) {
        if (false && bucket instanceof TemplateOnlyComponentDebugBucket) {
            return;
        }
        if (!bucket) {
            return;
        }
        bucket.component.didUpdate();
    };

    ComponentManager.prototype.getDestructor = function getDestructor(bucket) {
        if (false && bucket instanceof TemplateOnlyComponentDebugBucket) {
            return NOOP_DESTROYABLE;
        }
        if (!bucket) {
            return NOOP_DESTROYABLE;
        }
        return bucket.component;
    };

    return ComponentManager;
}();

var NOOP_DESTROYABLE = {
    destroy: function destroy() {}
};

function isTypeSpecifier(specifier) {
    return specifier.indexOf(':') === -1;
}
/**
 * A repository of application objects, indexed by type and name.
 *
 * {@link Initializer | Initializers} can add or override objects in the system
 * before the application boots, customizing runtime behavior.
 *
 * @internal
 */

var ApplicationRegistry = function () {
    function ApplicationRegistry(registry, resolver) {
        classCallCheck(this, ApplicationRegistry);

        this._registry = registry;
        this._resolver = resolver;
    }

    ApplicationRegistry.prototype.register = function register(specifier, factory, options) {
        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
        this._registry.register(normalizedSpecifier, factory, options);
    };

    ApplicationRegistry.prototype.registration = function registration(specifier) {
        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
        return this._registry.registration(normalizedSpecifier);
    };

    ApplicationRegistry.prototype.unregister = function unregister(specifier) {
        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
        this._registry.unregister(normalizedSpecifier);
    };

    ApplicationRegistry.prototype.registerOption = function registerOption(specifier, option, value) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        this._registry.registerOption(normalizedSpecifier, option, value);
    };

    ApplicationRegistry.prototype.registeredOption = function registeredOption(specifier, option) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        return this._registry.registeredOption(normalizedSpecifier, option);
    };

    ApplicationRegistry.prototype.registeredOptions = function registeredOptions(specifier) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        return this._registry.registeredOptions(normalizedSpecifier);
    };

    ApplicationRegistry.prototype.unregisterOption = function unregisterOption(specifier, option) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        this._registry.unregisterOption(normalizedSpecifier, option);
    };

    ApplicationRegistry.prototype.registerInjection = function registerInjection(specifier, property, injection) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        var normalizedInjection = this._toAbsoluteSpecifier(injection);
        this._registry.registerInjection(normalizedSpecifier, property, normalizedInjection);
    };

    ApplicationRegistry.prototype.registeredInjections = function registeredInjections(specifier) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        return this._registry.registeredInjections(normalizedSpecifier);
    };

    ApplicationRegistry.prototype._toAbsoluteSpecifier = function _toAbsoluteSpecifier(specifier, referrer) {
        return this._resolver.identify(specifier, referrer);
    };

    ApplicationRegistry.prototype._toAbsoluteOrTypeSpecifier = function _toAbsoluteOrTypeSpecifier(specifier) {
        if (isTypeSpecifier(specifier)) {
            return specifier;
        } else {
            return this._toAbsoluteSpecifier(specifier);
        }
    };

    return ApplicationRegistry;
}();

var DynamicScope = function () {
    function DynamicScope() {
        var bucket = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        classCallCheck(this, DynamicScope);

        if (bucket) {
            this.bucket = assign({}, bucket);
        } else {
            this.bucket = {};
        }
    }

    DynamicScope.prototype.get = function get$$1(key) {
        return this.bucket[key];
    };

    DynamicScope.prototype.set = function set$$1(key, reference) {
        return this.bucket[key] = reference;
    };

    DynamicScope.prototype.child = function child() {
        return new DynamicScope(this.bucket);
    };

    return DynamicScope;
}();

var ArrayIterator = function () {
    function ArrayIterator(array, keyFor) {
        classCallCheck(this, ArrayIterator);

        this.position = 0;
        this.array = array;
        this.keyFor = keyFor;
    }

    ArrayIterator.prototype.isEmpty = function isEmpty() {
        return this.array.length === 0;
    };

    ArrayIterator.prototype.next = function next() {
        var position = this.position,
            array = this.array,
            keyFor = this.keyFor;

        if (position >= array.length) return null;
        var value = array[position];
        var key = keyFor(value, position);
        var memo = position;
        this.position++;
        return { key: key, value: value, memo: memo };
    };

    return ArrayIterator;
}();

var ObjectKeysIterator = function () {
    function ObjectKeysIterator(keys, values, keyFor) {
        classCallCheck(this, ObjectKeysIterator);

        this.position = 0;
        this.keys = keys;
        this.values = values;
        this.keyFor = keyFor;
    }

    ObjectKeysIterator.prototype.isEmpty = function isEmpty() {
        return this.keys.length === 0;
    };

    ObjectKeysIterator.prototype.next = function next() {
        var position = this.position,
            keys = this.keys,
            values = this.values,
            keyFor = this.keyFor;

        if (position >= keys.length) return null;
        var value = values[position];
        var memo = keys[position];
        var key = keyFor(value, memo);
        this.position++;
        return { key: key, value: value, memo: memo };
    };

    return ObjectKeysIterator;
}();

var EmptyIterator = function () {
    function EmptyIterator() {
        classCallCheck(this, EmptyIterator);
    }

    EmptyIterator.prototype.isEmpty = function isEmpty() {
        return true;
    };

    EmptyIterator.prototype.next = function next() {
        throw new Error("Cannot call next() on an empty iterator");
    };

    return EmptyIterator;
}();

var EMPTY_ITERATOR = new EmptyIterator();
/** @internal */

var Iterable = function () {
    function Iterable(ref, keyFor) {
        classCallCheck(this, Iterable);

        this.tag = ref.tag;
        this.ref = ref;
        this.keyFor = keyFor;
    }

    Iterable.prototype.iterate = function iterate() {
        var ref = this.ref,
            keyFor = this.keyFor;

        var iterable = ref.value();
        if (Array.isArray(iterable)) {
            return iterable.length > 0 ? new ArrayIterator(iterable, keyFor) : EMPTY_ITERATOR;
        } else if (iterable === undefined || iterable === null) {
            return EMPTY_ITERATOR;
        } else if (iterable.forEach !== undefined) {
            var array = [];
            iterable.forEach(function (item) {
                array.push(item);
            });
            return array.length > 0 ? new ArrayIterator(array, keyFor) : EMPTY_ITERATOR;
        } else if ((typeof iterable === "undefined" ? "undefined" : _typeof(iterable)) === 'object') {
            var keys = Object.keys(iterable);
            return keys.length > 0 ? new ObjectKeysIterator(keys, keys.map(function (key) {
                return iterable[key];
            }), keyFor) : EMPTY_ITERATOR;
        } else {
            throw new Error("Don't know how to {{#each " + iterable + "}}");
        }
    };

    Iterable.prototype.valueReferenceFor = function valueReferenceFor(item) {
        return new UpdatableReference(item.value);
    };

    Iterable.prototype.updateValueReference = function updateValueReference(reference, item) {
        reference.update(item.value);
    };

    Iterable.prototype.memoReferenceFor = function memoReferenceFor(item) {
        return new UpdatableReference(item.memo);
    };

    Iterable.prototype.updateMemoReference = function updateMemoReference(reference, item) {
        reference.update(item.memo);
    };

    return Iterable;
}();

/** @internal */

var Environment$1 = function (_GlimmerEnvironment) {
    inherits(Environment$$1, _GlimmerEnvironment);

    Environment$$1.create = function create() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        options.document = options.document || self.document;
        options.appendOperations = options.appendOperations || new DOMTreeConstruction(options.document);
        return new Environment$$1(options);
    };

    function Environment$$1(options) {
        classCallCheck(this, Environment$$1);

        var _this = possibleConstructorReturn(this, _GlimmerEnvironment.call(this, { appendOperations: options.appendOperations, updateOperations: new DOMChanges$1(options.document || document) }));

        setOwner(_this, getOwner(options));
        // TODO - required for `protocolForURL` - seek alternative approach
        // e.g. see `installPlatformSpecificProtocolForURL` in Ember
        _this.uselessAnchor = options.document.createElement('a');
        return _this;
    }

    Environment$$1.prototype.protocolForURL = function protocolForURL(url) {
        // TODO - investigate alternative approaches
        // e.g. see `installPlatformSpecificProtocolForURL` in Ember
        this.uselessAnchor.href = url;
        return this.uselessAnchor.protocol;
    };

    Environment$$1.prototype.iterableFor = function iterableFor(ref, keyPath) {
        var keyFor = void 0;
        if (!keyPath) {
            throw new Error('Must specify a key for #each');
        }
        switch (keyPath) {
            case '@index':
                keyFor = function keyFor(_, index) {
                    return String(index);
                };
                break;
            case '@primitive':
                keyFor = function keyFor(item) {
                    return String(item);
                };
                break;
            default:
                keyFor = function keyFor(item) {
                    return item[keyPath];
                };
                break;
        }
        return new Iterable(ref, keyFor);
    };

    return Environment$$1;
}(Environment);

var DEFAULT_DOCUMENT = (typeof document === 'undefined' ? 'undefined' : _typeof(document)) === 'object' ? document : null;
/**
 * The central control point for starting and running Glimmer components.
 *
 * @public
 */

var Application = function () {
    function Application(options) {
        classCallCheck(this, Application);

        this._roots = [];
        this._rootsIndex = 0;
        this._initializers = [];
        this._initialized = false;
        this._rendering = false;
        this._rendered = false;
        this._scheduled = false;
        this._notifiers = [];
        this.rootName = options.rootName;
        this.resolver = options.resolver;
        debugAssert(options.loader, 'Must provide a Loader for preparing templates and other metadata required for a Glimmer Application.');
        debugAssert(options.renderer, 'Must provide a Renderer to render the templates produced by the Loader.');
        debugAssert(options.builder, 'Must provide a Builder that is responsible to building DOM.');
        this.document = options.document || DEFAULT_DOCUMENT;
        this.loader = options.loader;
        this.renderer = options.renderer;
        this.builder = options.builder;
    }
    /**
     * Renders a component by name into the provided element, and optionally
     * adjacent to the provided nextSibling element.
     *
     * ## Examples
     *
     * ```js
     * app.renderComponent('MyComponent', document.body, document.getElementById('my-footer'));
     * ```
     */


    Application.prototype.renderComponent = function renderComponent(component, parent) {
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var roots = this._roots,
            self = this._self;

        roots.push({ id: this._rootsIndex++, component: component, parent: parent, nextSibling: nextSibling });
        // If we've already rendered, need to invalidate the root reference and
        // schedule a re-render for the new component to appear in DOM.
        if (self) {
            self.update({ roots: roots });
            this.scheduleRerender();
        }
    };
    /**
     * Initializes the application and renders any components that have been
     * registered via [renderComponent].
     *
     * @public
     */


    Application.prototype.boot = function () {
        var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            this.initialize();
                            this.env = this.lookup('environment:/' + this.rootName + '/main/main');
                            _context.next = 4;
                            return this._render();

                        case 4:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, this);
        }));

        function boot() {
            return _ref.apply(this, arguments);
        }

        return boot;
    }();
    /**
     * Schedules all components to revalidate and potentially update the DOM to
     * reflect any changes to underlying component state.
     *
     * Generally speaking, you  should avoid calling `scheduleRerender()`
     * manually. Instead, use tracked properties on components and models, which
     * invoke this method for you automatically when appropriate.
     */


    Application.prototype.scheduleRerender = function scheduleRerender() {
        var _this = this;

        if (this._scheduled || !this._rendered) return;
        this._rendering = true;
        this._scheduled = true;
        setTimeout(function () {
            _this._scheduled = false;
            _this._rerender();
            _this._rendering = false;
        }, 0);
    };
    /** @internal */


    Application.prototype.initialize = function initialize() {
        this.initRegistry();
        this.initContainer();
    };
    /** @internal */


    Application.prototype.registerInitializer = function registerInitializer(initializer) {
        this._initializers.push(initializer);
    };
    /**
     * Initializes the registry, which maps names to objects in the system. Addons
     * and subclasses can customize the behavior of a Glimmer application by
     * overriding objects in the registry.
     *
     * @internal
     */


    Application.prototype.initRegistry = function initRegistry() {
        var registry = this._registry = new Registry();
        // Create ApplicationRegistry as a proxy to the underlying registry
        // that will only be available during `initialize`.
        var appRegistry = new ApplicationRegistry(this._registry, this.resolver);
        registry.register('environment:/' + this.rootName + '/main/main', Environment$1);
        registry.registerOption('helper', 'instantiate', false);
        registry.registerOption('template', 'instantiate', false);
        registry.register('document:/' + this.rootName + '/main/main', this.document);
        registry.registerOption('document', 'instantiate', false);
        registry.registerInjection('environment', 'document', 'document:/' + this.rootName + '/main/main');
        registry.registerInjection('component-manager', 'env', 'environment:/' + this.rootName + '/main/main');
        var initializers = this._initializers;
        for (var i = 0; i < initializers.length; i++) {
            initializers[i].initialize(appRegistry);
        }
        this._initialized = true;
    };
    /**
     * Initializes the container, which stores instances of objects that come from
     * the registry.
     *
     * @internal
     */


    Application.prototype.initContainer = function initContainer() {
        var _this2 = this;

        this._container = new Container(this._registry, this.resolver);
        // Inject `this` (the app) as the "owner" of every object instantiated
        // by its container.
        this._container.defaultInjections = function (specifier) {
            var hash = {};
            setOwner(hash, _this2);
            return hash;
        };
    };
    /** @internal */


    Application.prototype._render = function () {
        var _ref2 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
            var env, self, dynamicScope, builder, templateIterator;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            env = this.env;
                            // Create the template context for the root `main` template, which just
                            // contains the array of component roots. Any property references in that
                            // template will be looked up from this object.

                            self = this._self = new UpdatableReference({ roots: this._roots });
                            // Create an empty root scope.

                            dynamicScope = new DynamicScope();
                            builder = this.builder.getBuilder(env);
                            _context2.next = 6;
                            return this.loader.getTemplateIterator(this, env, builder, dynamicScope, self);

                        case 6:
                            templateIterator = _context2.sent;
                            _context2.prev = 7;

                            // Begin a new transaction. The transaction stores things like component
                            // lifecycle events so they can be flushed once rendering has completed.
                            env.begin();
                            _context2.next = 11;
                            return this.renderer.render(templateIterator);

                        case 11:
                            // Finally, commit the transaction and flush component lifecycle hooks.
                            env.commit();
                            this._didRender();
                            _context2.next = 19;
                            break;

                        case 15:
                            _context2.prev = 15;
                            _context2.t0 = _context2['catch'](7);

                            this._didError(_context2.t0);
                            throw _context2.t0;

                        case 19:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, _callee2, this, [[7, 15]]);
        }));

        function _render() {
            return _ref2.apply(this, arguments);
        }

        return _render;
    }();
    /**
     * Ensures the DOM is up-to-date by performing a revalidation on the root
     * template's render result. This method should not be called directly;
     * instead, any mutations in the program that could cause side-effects should
     * call `scheduleRerender()`, which ensures that DOM updates only happen once
     * at the end of the browser's event loop.
     *
     * @internal
     */


    Application.prototype._rerender = function () {
        var _ref3 = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
            var env;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                    switch (_context3.prev = _context3.next) {
                        case 0:
                            env = this.env;
                            _context3.prev = 1;

                            env.begin();
                            _context3.next = 5;
                            return this.renderer.rerender();

                        case 5:
                            env.commit();
                            this._didRender();
                            _context3.next = 13;
                            break;

                        case 9:
                            _context3.prev = 9;
                            _context3.t0 = _context3['catch'](1);

                            this._didError(_context3.t0);
                            throw _context3.t0;

                        case 13:
                        case 'end':
                            return _context3.stop();
                    }
                }
            }, _callee3, this, [[1, 9]]);
        }));

        function _rerender() {
            return _ref3.apply(this, arguments);
        }

        return _rerender;
    }();

    Application.prototype._didRender = function _didRender() {
        this._rendered = true;
        var notifiers = this._notifiers;
        this._notifiers = [];
        notifiers.forEach(function (n) {
            return n[0]();
        });
    };

    Application.prototype._didError = function _didError(err) {
        var notifiers = this._notifiers;
        this._notifiers = [];
        notifiers.forEach(function (n) {
            return n[1](err);
        });
    };
    /**
     * Owner interface implementation
     *
     * @internal
     */


    Application.prototype.identify = function identify(specifier, referrer) {
        return this.resolver.identify(specifier, referrer);
    };
    /** @internal */


    Application.prototype.factoryFor = function factoryFor(specifier, referrer) {
        return this._container.factoryFor(this.identify(specifier, referrer));
    };
    /** @internal */


    Application.prototype.lookup = function lookup(specifier, referrer) {
        return this._container.lookup(this.identify(specifier, referrer));
    };

    return Application;
}();

var TypedRegistry = function () {
    function TypedRegistry() {
        classCallCheck(this, TypedRegistry);

        this.byName = dict();
        this.byHandle = dict();
    }

    TypedRegistry.prototype.hasName = function hasName(name) {
        return name in this.byName;
    };

    TypedRegistry.prototype.getHandle = function getHandle(name) {
        return this.byName[name];
    };

    TypedRegistry.prototype.hasHandle = function hasHandle(name) {
        return name in this.byHandle;
    };

    TypedRegistry.prototype.getByHandle = function getByHandle(handle) {
        return this.byHandle[handle];
    };

    TypedRegistry.prototype.register = function register(handle, name, value) {
        this.byHandle[handle] = value;
        this.byName[name] = handle;
    };

    return TypedRegistry;
}();

var HelperReference = function () {
    function HelperReference(helper, args) {
        classCallCheck(this, HelperReference);

        this.helper = helper;
        this.tag = args.tag;
        this.args = args.capture();
    }

    HelperReference.prototype.value = function value() {
        var helper = this.helper,
            args = this.args;

        return helper(args.positional.value(), args.named.value());
    };

    HelperReference.prototype.get = function get$$1() {
        return new RootReference(this);
    };

    return HelperReference;
}();

/** @public */

var RuntimeResolver = function () {
    function RuntimeResolver(owner) {
        classCallCheck(this, RuntimeResolver);

        this.owner = owner;
        this.handleLookup = [];
        this.cache = {
            component: new TypedRegistry(),
            template: new TypedRegistry(),
            compiledTemplate: new TypedRegistry(),
            helper: new TypedRegistry(),
            manager: new TypedRegistry(),
            modifier: new TypedRegistry()
        };
    }

    RuntimeResolver.prototype.setCompileOptions = function setCompileOptions(compileOptions) {
        this.templateOptions = compileOptions;
    };

    RuntimeResolver.prototype.lookup = function lookup(type, name, referrer) {
        if (this.cache[type].hasName(name)) {
            return this.cache[type].getHandle(name);
        } else {
            return null;
        }
    };

    RuntimeResolver.prototype.register = function register(type, name, value) {
        var registry = this.cache[type];
        var handle = this.handleLookup.length;
        this.handleLookup.push(registry);
        this.cache[type].register(handle, name, value);
        return handle;
    };

    RuntimeResolver.prototype.lookupModifier = function lookupModifier(name, meta) {
        var handle = this.lookup('modifier', name);
        if (handle === null) {
            throw new Error("Modifier for " + name + " not found.");
        }
        return handle;
    };

    RuntimeResolver.prototype.compileTemplate = function compileTemplate(name, layout) {
        if (!this.cache.compiledTemplate.hasName(name)) {
            var serializedTemplate = this.resolve(layout);
            var block = serializedTemplate.block,
                meta = serializedTemplate.meta,
                id = serializedTemplate.id;

            var parsedBlock = JSON.parse(block);
            var template = new ScannableTemplate(this.templateOptions, { id: id, block: parsedBlock, referrer: meta }).asLayout();
            var invocation = {
                handle: template.compile(),
                symbolTable: template.symbolTable
            };
            this.register('compiledTemplate', name, invocation);
            return invocation;
        }
        var handle = this.lookup('compiledTemplate', name);
        return this.resolve(handle);
    };

    RuntimeResolver.prototype.registerHelper = function registerHelper(name, helper) {
        var glimmerHelper = function glimmerHelper(_vm, args) {
            return new HelperReference(helper, args);
        };
        return this.register('helper', name, glimmerHelper);
    };

    RuntimeResolver.prototype.registerInternalHelper = function registerInternalHelper(name, helper) {
        this.register('helper', name, helper);
    };

    RuntimeResolver.prototype.registerComponent = function registerComponent(name, resolvedSpecifier, Component, template) {
        var templateEntry = this.registerTemplate(resolvedSpecifier, template);
        var manager = this.managerFor(templateEntry.meta.managerId);
        var definition = new ComponentDefinition(name, manager, Component, templateEntry.handle);
        return this.register('component', name, definition);
    };

    RuntimeResolver.prototype.lookupComponentHandle = function lookupComponentHandle(name, referrer) {
        if (!this.cache.component.hasName(name)) {
            this.lookupComponent(name, referrer);
        }
        return this.lookup('component', name, referrer);
    };

    RuntimeResolver.prototype.managerFor = function managerFor() {
        var managerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';

        var manager = void 0;
        if (!this.cache.manager.hasName(managerId)) {
            var rootName = this.owner.rootName;

            manager = this.owner.lookup("component-manager:/" + rootName + "/component-managers/" + managerId);
            if (!manager) {
                throw new Error("No component manager found for ID " + managerId + ".");
            }
            this.register('manager', managerId, manager);
            return manager;
        } else {
            var handle = this.cache.manager.getHandle(managerId);
            return this.cache.manager.getByHandle(handle);
        }
    };

    RuntimeResolver.prototype.registerTemplate = function registerTemplate(resolvedSpecifier, template) {
        return {
            name: resolvedSpecifier,
            handle: this.register('template', resolvedSpecifier, template),
            meta: template.meta
        };
    };

    RuntimeResolver.prototype.lookupComponent = function lookupComponent(name, meta) {
        var handle = void 0;
        if (!this.cache.component.hasName(name)) {
            var specifier = expect(this.identifyComponent(name, meta), "Could not find the component '" + name + "'");
            var template = this.owner.lookup('template', specifier);
            var componentSpecifier = this.owner.identify('component', specifier);
            var componentFactory = null;
            if (componentSpecifier !== undefined) {
                componentFactory = this.owner.factoryFor(componentSpecifier);
            }
            handle = this.registerComponent(name, specifier, componentFactory, template);
        } else {
            handle = this.lookup('component', name, meta);
        }
        return this.resolve(handle);
    };

    RuntimeResolver.prototype.lookupHelper = function lookupHelper(name, meta) {
        if (!this.cache.helper.hasName(name)) {
            var owner = this.owner;
            var relSpecifier = "helper:" + name;
            var referrer = meta.specifier;
            var specifier = owner.identify(relSpecifier, referrer);
            if (specifier === undefined) {
                return null;
            }
            var helper = this.owner.lookup(specifier, meta.specifier);
            return this.registerHelper(name, helper);
        }
        return this.lookup('helper', name, meta);
    };

    RuntimeResolver.prototype.lookupPartial = function lookupPartial(name, meta) {
        throw new Error("Partials are not available in Glimmer applications.");
    };

    RuntimeResolver.prototype.resolve = function resolve(handle) {
        var registry = this.handleLookup[handle];
        return registry.getByHandle(handle);
    };

    RuntimeResolver.prototype.identifyComponent = function identifyComponent(name, meta) {
        var owner = this.owner;
        var relSpecifier = "template:" + name;
        var referrer = meta.specifier;
        var specifier = owner.identify(relSpecifier, referrer);
        if (specifier === undefined && owner.identify("component:" + name, referrer)) {
            throw new Error("The component '" + name + "' is missing a template. All components must have a template. Make sure there is a template.hbs in the component directory.");
        }
        return specifier;
    };

    return RuntimeResolver;
}();

var UNRESOLVED = {};
var WELL_KNOWN_EMPTY_ARRAY_POSITION = 0;
var WELL_KNOW_EMPTY_ARRAY = Object.freeze([]);

var WriteOnlyConstants = function () {
    function WriteOnlyConstants() {
        classCallCheck(this, WriteOnlyConstants);

        // `0` means NULL
        this.strings = [];
        this.arrays = [WELL_KNOW_EMPTY_ARRAY];
        this.tables = [];
        this.handles = [];
        this.resolved = [];
        this.floats = [];
        this.negatives = [];
    }

    WriteOnlyConstants.prototype.float = function float(_float) {
        var index = this.floats.indexOf(_float);
        if (index > -1) {
            return index;
        }
        return this.floats.push(_float) - 1;
    };

    WriteOnlyConstants.prototype.negative = function negative(_negative) {
        return this.negatives.push(_negative) - 1;
    };

    WriteOnlyConstants.prototype.string = function string(value) {
        var index = this.strings.indexOf(value);
        if (index > -1) {
            return index;
        }
        return this.strings.push(value) - 1;
    };

    WriteOnlyConstants.prototype.stringArray = function stringArray(strings) {
        var _strings = new Array(strings.length);
        for (var i = 0; i < strings.length; i++) {
            _strings[i] = this.string(strings[i]);
        }
        return this.array(_strings);
    };

    WriteOnlyConstants.prototype.array = function array(values) {
        if (values.length === 0) {
            return WELL_KNOWN_EMPTY_ARRAY_POSITION;
        }
        var index = this.arrays.indexOf(values);
        if (index > -1) {
            return index;
        }
        return this.arrays.push(values) - 1;
    };

    WriteOnlyConstants.prototype.handle = function handle(_handle) {
        var index = this.handles.indexOf(_handle);
        if (index > -1) {
            return index;
        }
        this.resolved.push(UNRESOLVED);
        return this.handles.push(_handle) - 1;
    };

    WriteOnlyConstants.prototype.serializable = function serializable(value) {
        var str = JSON.stringify(value);
        var index = this.strings.indexOf(str);
        if (index > -1) {
            return index;
        }
        return this.strings.push(str) - 1;
    };

    WriteOnlyConstants.prototype.toPool = function toPool() {
        return {
            strings: this.strings,
            arrays: this.arrays,
            handles: this.handles,
            floats: this.floats,
            negatives: this.negatives
        };
    };

    return WriteOnlyConstants;
}();


var Constants = function (_WriteOnlyConstants) {
    inherits(Constants, _WriteOnlyConstants);

    function Constants(resolver, pool) {
        classCallCheck(this, Constants);

        var _this = possibleConstructorReturn(this, _WriteOnlyConstants.call(this));

        _this.resolver = resolver;
        if (pool) {
            _this.strings = pool.strings;
            _this.arrays = pool.arrays;
            _this.handles = pool.handles;
            _this.floats = pool.floats;
            _this.negatives = pool.negatives;
            _this.resolved = _this.handles.map(function () {
                return UNRESOLVED;
            });
        }
        return _this;
    }
    // `0` means NULL


    Constants.prototype.getFloat = function getFloat(value) {
        return this.floats[value];
    };

    Constants.prototype.getNegative = function getNegative(value) {
        return this.negatives[value];
    };

    Constants.prototype.getString = function getString(value) {
        return this.strings[value];
    };

    Constants.prototype.getStringArray = function getStringArray(value) {
        var names = this.getArray(value);
        var _names = new Array(names.length);
        for (var i = 0; i < names.length; i++) {
            var n = names[i];
            _names[i] = this.getString(n);
        }
        return _names;
    };

    Constants.prototype.getArray = function getArray(value) {
        return this.arrays[value];
    };

    Constants.prototype.resolveHandle = function resolveHandle(index) {
        var resolved = this.resolved[index];
        if (resolved === UNRESOLVED) {
            var handle = this.handles[index];
            resolved = this.resolved[index] = this.resolver.resolve(handle);
        }
        return resolved;
    };

    Constants.prototype.getSerializable = function getSerializable(s) {
        return JSON.parse(this.strings[s]);
    };

    return Constants;
}(WriteOnlyConstants);

var LazyConstants = function (_Constants) {
    inherits(LazyConstants, _Constants);

    function LazyConstants() {
        classCallCheck(this, LazyConstants);

        var _this2 = possibleConstructorReturn(this, _Constants.apply(this, arguments));

        _this2.others = [];
        _this2.serializables = [];
        return _this2;
    }

    LazyConstants.prototype.serializable = function serializable(value) {
        var index = this.serializables.indexOf(value);
        if (index > -1) {
            return index;
        }
        return this.serializables.push(value) - 1;
    };

    LazyConstants.prototype.getSerializable = function getSerializable(s) {
        return this.serializables[s];
    };

    LazyConstants.prototype.getOther = function getOther(value) {
        return this.others[value - 1];
    };

    LazyConstants.prototype.other = function other(_other) {
        return this.others.push(_other);
    };

    return LazyConstants;
}(Constants);

var Opcode = function () {
    function Opcode(heap) {
        classCallCheck(this, Opcode);

        this.heap = heap;
        this.offset = 0;
    }

    createClass(Opcode, [{
        key: "size",
        get: function get$$1() {
            var rawType = this.heap.getbyaddr(this.offset);
            return ((rawType & 768 /* OPERAND_LEN_MASK */) >> 8 /* ARG_SHIFT */) + 1;
        }
    }, {
        key: "isMachine",
        get: function get$$1() {
            var rawType = this.heap.getbyaddr(this.offset);
            return rawType & 1024 /* MACHINE_MASK */;
        }
    }, {
        key: "type",
        get: function get$$1() {
            return this.heap.getbyaddr(this.offset) & 255 /* TYPE_MASK */;
        }
    }, {
        key: "op1",
        get: function get$$1() {
            return this.heap.getbyaddr(this.offset + 1);
        }
    }, {
        key: "op2",
        get: function get$$1() {
            return this.heap.getbyaddr(this.offset + 2);
        }
    }, {
        key: "op3",
        get: function get$$1() {
            return this.heap.getbyaddr(this.offset + 3);
        }
    }]);
    return Opcode;
}();

function encodeTableInfo(size, scopeSize, state) {
    return size | scopeSize << 16 | state << 30;
}
function changeState(info, newState) {
    return info | newState << 30;
}
/**
 * The Heap is responsible for dynamically allocating
 * memory in which we read/write the VM's instructions
 * from/to. When we malloc we pass out a VMHandle, which
 * is used as an indirect way of accessing the memory during
 * execution of the VM. Internally we track the different
 * regions of the memory in an int array known as the table.
 *
 * The table 32-bit aligned and has the following layout:
 *
 * | ... | hp (u32) |       info (u32)          |
 * | ... |  Handle  | Size | Scope Size | State |
 * | ... | 32-bits  | 16b  |    14b     |  2b   |
 *
 * With this information we effectively have the ability to
 * control when we want to free memory. That being said you
 * can not free during execution as raw address are only
 * valid during the execution. This means you cannot close
 * over them as you will have a bad memory access exception.
 */
var Heap = function () {
    function Heap(serializedHeap) {
        classCallCheck(this, Heap);

        this.placeholders = [];
        this.offset = 0;
        this.handle = 0;
        if (serializedHeap) {
            var buffer = serializedHeap.buffer,
                table = serializedHeap.table,
                handle = serializedHeap.handle;

            this.heap = new Uint16Array(buffer);
            this.table = table;
            this.offset = this.heap.length;
            this.handle = handle;
        } else {
            this.heap = new Uint16Array(0x100000);
            this.table = [];
        }
    }

    Heap.prototype.push = function push(item) {
        this.heap[this.offset++] = item;
    };

    Heap.prototype.getbyaddr = function getbyaddr(address) {
        return this.heap[address];
    };

    Heap.prototype.setbyaddr = function setbyaddr(address, value) {
        this.heap[address] = value;
    };

    Heap.prototype.malloc = function malloc() {
        this.table.push(this.offset, 0);
        var handle = this.handle;
        this.handle += 2 /* ENTRY_SIZE */;
        return handle;
    };

    Heap.prototype.finishMalloc = function finishMalloc(handle, scopeSize) {
        var start = this.table[handle];
        var finish = this.offset;
        var instructionSize = finish - start;
        var info = encodeTableInfo(instructionSize, scopeSize, 0 /* Allocated */);
        this.table[handle + 1 /* INFO_OFFSET */] = info;
    };

    Heap.prototype.size = function size() {
        return this.offset;
    };
    // It is illegal to close over this address, as compaction
    // may move it. However, it is legal to use this address
    // multiple times between compactions.


    Heap.prototype.getaddr = function getaddr(handle) {
        return this.table[handle];
    };

    Heap.prototype.gethandle = function gethandle(address) {
        this.table.push(address, encodeTableInfo(0, 0, 3 /* Pointer */));
        var handle = this.handle;
        this.handle += 2 /* ENTRY_SIZE */;
        return handle;
    };

    Heap.prototype.sizeof = function sizeof(handle) {
        return -1;
    };

    Heap.prototype.scopesizeof = function scopesizeof(handle) {
        var info = this.table[handle + 1 /* INFO_OFFSET */];
        return (info & 1073676288 /* SCOPE_MASK */) >> 16;
    };

    Heap.prototype.free = function free(handle) {
        var info = this.table[handle + 1 /* INFO_OFFSET */];
        this.table[handle + 1 /* INFO_OFFSET */] = changeState(info, 1 /* Freed */);
    };
    /**
     * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
     * reachable memory to the bottom of the heap and freeable
     * memory to the top of the heap. When we have shifted all
     * the reachable memory to the top of the heap, we move the
     * offset to the next free position.
     */


    Heap.prototype.compact = function compact() {
        var compactedSize = 0;
        var table = this.table,
            length = this.table.length,
            heap = this.heap;

        for (var i = 0; i < length; i += 2 /* ENTRY_SIZE */) {
            var offset = table[i];
            var info = table[i + 1 /* INFO_OFFSET */];
            var size = info & 65535;
            var state = info & 3221225472 /* STATE_MASK */ >> 30;
            if (state === 2 /* Purged */) {
                    continue;
                } else if (state === 1 /* Freed */) {
                    // transition to "already freed" aka "purged"
                    // a good improvement would be to reuse
                    // these slots
                    table[i + 1 /* INFO_OFFSET */] = changeState(info, 2 /* Purged */);
                    compactedSize += size;
                } else if (state === 0 /* Allocated */) {
                    for (var j = offset; j <= i + size; j++) {
                        heap[j - compactedSize] = heap[j];
                    }
                    table[i] = offset - compactedSize;
                } else if (state === 3 /* Pointer */) {
                    table[i] = offset - compactedSize;
                }
        }
        this.offset = this.offset - compactedSize;
    };

    Heap.prototype.pushPlaceholder = function pushPlaceholder(valueFunc) {
        var address = this.offset++;
        this.heap[address] = 65535 /* MAX_SIZE */;
        this.placeholders.push([address, valueFunc]);
    };

    Heap.prototype.patchPlaceholders = function patchPlaceholders() {
        var placeholders = this.placeholders;

        for (var i = 0; i < placeholders.length; i++) {
            var _placeholders$i = placeholders[i],
                address = _placeholders$i[0],
                getValue = _placeholders$i[1];

            false && debugAssert(this.getbyaddr(address) === 65535 /* MAX_SIZE */, 'expected to find a placeholder value at ' + address);

            this.setbyaddr(address, getValue());
        }
    };

    Heap.prototype.capture = function capture() {
        this.patchPlaceholders();
        // Only called in eager mode
        var buffer = slice(this.heap, 0, this.offset);
        return {
            handle: this.handle,
            table: this.table,
            buffer: buffer
        };
    };

    return Heap;
}();
var WriteOnlyProgram = function () {
    function WriteOnlyProgram() {
        var constants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new WriteOnlyConstants();
        var heap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Heap();
        classCallCheck(this, WriteOnlyProgram);

        this.constants = constants;
        this.heap = heap;
        this._opcode = new Opcode(this.heap);
    }

    WriteOnlyProgram.prototype.opcode = function opcode(offset) {
        this._opcode.offset = offset;
        return this._opcode;
    };

    return WriteOnlyProgram;
}();

var Program = function (_WriteOnlyProgram) {
    inherits(Program, _WriteOnlyProgram);

    function Program() {
        classCallCheck(this, Program);
        return possibleConstructorReturn(this, _WriteOnlyProgram.apply(this, arguments));
    }

    return Program;
}(WriteOnlyProgram);
function slice(arr, start, end) {
    if (arr instanceof Uint16Array) {
        if (arr.slice !== undefined) {
            return arr.slice(start, end).buffer;
        }
        var ret = new Uint16Array(end);
        for (; start < end; start++) {
            ret[start] = arr[start];
        }
        return ret.buffer;
    }
    return null;
}

var mainTemplate = { "id": "j7SGa6Pm", "block": "{\"symbols\":[\"root\"],\"statements\":[[4,\"each\",[[22,[\"roots\"]]],[[\"key\"],[\"id\"]],{\"statements\":[[4,\"in-element\",[[21,1,[\"parent\"]]],[[\"guid\",\"nextSibling\"],[\"%cursor:0%\",[21,1,[\"nextSibling\"]]]],{\"statements\":[[1,[26,\"component\",[[21,1,[\"component\"]]],null],false]],\"parameters\":[]},null]],\"parameters\":[1]},null]],\"hasEval\":false}", "meta": { "specifier": "template:/-application/application/src/templates/main" } };

/** @internal */
function buildAction(vm, _args) {
    var componentRef = vm.getSelf();
    var args = _args.capture();
    var actionFunc = args.positional.at(0).value();
    if (typeof actionFunc !== 'function') {
        throwNoActionError(actionFunc, args.positional.at(0));
    }
    return new UpdatableReference(function action() {
        var curriedArgs = args.positional.value();
        // Consume the action function that was already captured above.
        curriedArgs.shift();
        curriedArgs.push.apply(curriedArgs, arguments);
        // Invoke the function with the component as the context, the curried
        // arguments passed to `{{action}}`, and the arguments the bound function
        // was invoked with.
        actionFunc.apply(componentRef && componentRef.value(), curriedArgs);
    });
}
function throwNoActionError(actionFunc, actionFuncReference) {
    var referenceInfo = debugInfoForReference(actionFuncReference);
    throw new Error('You tried to create an action with the {{action}} helper, but the first argument ' + referenceInfo + 'was ' + (typeof actionFunc === 'undefined' ? 'undefined' : _typeof(actionFunc)) + ' instead of a function.');
}
/** @internal */
function debugInfoForReference(reference) {
    var message = '';
    var parent = void 0;
    var property = void 0;
    if (reference === null || reference === undefined) {
        return message;
    }
    if ('parent' in reference && 'property' in reference) {
        parent = reference['parent'].value();
        property = reference['property'];
    } else if ('_parentValue' in reference && '_propertyKey' in reference) {
        parent = reference['_parentValue'];
        property = reference['_propertyKey'];
    }
    if (property !== undefined) {
        message += '(\'' + property + '\' on ' + debugName(parent) + ') ';
    }
    return message;
}
function debugName(obj) {
    var objType = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
    if (obj === null || obj === undefined) {
        return objType;
    } else if (objType === 'number' || objType === 'boolean') {
        return obj.toString();
    } else {
        if (obj['debugName']) {
            return obj['debugName'];
        }
        try {
            return JSON.stringify(obj);
        } catch (e) {}
        return obj.toString();
    }
}

/** @internal */
function ifHelper(params) {
    return params[0] ? params[1] : params[2];
}

var CompileTimeLookup = function () {
    function CompileTimeLookup(resolver) {
        classCallCheck(this, CompileTimeLookup);

        this.resolver = resolver;
    }

    CompileTimeLookup.prototype.getComponentDefinition = function getComponentDefinition(handle) {
        var spec = this.resolver.resolve(handle);
        debugAssert(!!spec, 'Couldn\'t find a template for ' + handle);
        return spec;
    };

    CompileTimeLookup.prototype.getCapabilities = function getCapabilities(handle) {
        var definition = this.getComponentDefinition(handle);
        var manager = definition.manager,
            state = definition.state;

        return manager.getCapabilities(state);
    };

    CompileTimeLookup.prototype.getLayout = function getLayout(handle) {
        var definition = this.getComponentDefinition(handle);
        var manager = definition.manager;

        var invocation = manager.getLayout(definition, this.resolver);
        return {
            compile: function compile() {
                return invocation.handle;
            },

            symbolTable: invocation.symbolTable
        };
    };

    CompileTimeLookup.prototype.lookupHelper = function lookupHelper(name, referrer) {
        return this.resolver.lookupHelper(name, referrer);
    };

    CompileTimeLookup.prototype.lookupModifier = function lookupModifier(name, referrer) {
        return this.resolver.lookupModifier(name, referrer);
    };

    CompileTimeLookup.prototype.lookupComponentDefinition = function lookupComponentDefinition(name, referrer) {
        return this.resolver.lookupComponentHandle(name, referrer);
    };

    CompileTimeLookup.prototype.lookupPartial = function lookupPartial(name, referrer) {
        return this.resolver.lookupPartial(name, referrer);
    };

    return CompileTimeLookup;
}();

/**
 * The RuntimeCompilerLoader is used by Glimmer.js applications that perform the
 * final template compilation step client-side. It configures the compiler to
 * resolve templates, helpers and other objects from the runtime registry, and
 * enables just-in-time compilation of templates as they are encountered.
 *
 * @public
 */

var RuntimeCompilerLoader = function () {
    function RuntimeCompilerLoader(resolver) {
        classCallCheck(this, RuntimeCompilerLoader);

        this.resolver = resolver;
    }

    RuntimeCompilerLoader.prototype.getTemplateIterator = function () {
        var _ref = asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(app, env, builder, dynamicScope, self) {
            var resolver, program, macros, lookup, compileOptions, mainLayout;
            return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            resolver = new RuntimeResolver(app);
                            program = new Program(new LazyConstants(resolver));
                            macros = new Macros();
                            lookup = new CompileTimeLookup(resolver);
                            compileOptions = {
                                program: program,
                                macros: macros,
                                resolver: lookup,
                                Builder: LazyOpcodeBuilder
                            };

                            resolver.setCompileOptions(compileOptions);
                            resolver.registerTemplate('main', mainTemplate);
                            resolver.registerInternalHelper('action', buildAction);
                            resolver.registerHelper('if', ifHelper);
                            mainLayout = templateFactory(mainTemplate).create(compileOptions);
                            return _context.abrupt('return', Promise.resolve(mainLayout.renderLayout({
                                env: env,
                                builder: builder,
                                dynamicScope: dynamicScope,
                                self: self
                            })));

                        case 11:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, this);
        }));

        function getTemplateIterator(_x, _x2, _x3, _x4, _x5) {
            return _ref.apply(this, arguments);
        }

        return getTemplateIterator;
    }();

    return RuntimeCompilerLoader;
}();

/**
 * A {@link Builder} that creates DOM elements when templates render.
 *
 * Use a DOMBuilder for Glimmer.js applications that do not use server-side
 * rendering. If you are using server-side rendering, the
 * {@link RehydratingBuilder} can be used to rehydrate existing DOM instead of
 * replacing it.
 *
 * @public
 */

var DOMBuilder = function () {
    function DOMBuilder(_ref) {
        var element = _ref.element,
            _ref$nextSibling = _ref.nextSibling,
            nextSibling = _ref$nextSibling === undefined ? null : _ref$nextSibling;
        classCallCheck(this, DOMBuilder);

        this.cursor = { element: element, nextSibling: nextSibling };
    }

    DOMBuilder.prototype.getBuilder = function getBuilder(env) {
        return clientBuilder(env, this.cursor);
    };

    return DOMBuilder;
}();

/**
 * A {@link Builder} that re-uses existing DOM provided via server-side rendering.
 *
 * The RehydratingBuilder attempts to use the DOM produced by SSR-generated HTML
 * during template rendering. This allows components to "rehydrate" existing DOM
 * elements, making initial render faster and preventing the browser from having
 * to perform additional layout and paint operations.
 *
 * @public
 */

var RehydratingBuilder = function (_DOMBuilder) {
    inherits(RehydratingBuilder, _DOMBuilder);

    function RehydratingBuilder() {
        classCallCheck(this, RehydratingBuilder);
        return possibleConstructorReturn(this, _DOMBuilder.apply(this, arguments));
    }

    RehydratingBuilder.prototype.getBuilder = function getBuilder(env) {
        return rehydrationBuilder(env, this.cursor);
    };

    return RehydratingBuilder;
}(DOMBuilder);

/**
 * Performs a synchronous initial render of templates.
 *
 * @remarks
 *
 * The SyncRenderer will render a template as fast as possible, continuing to
 * work until the template has been completely rendered.
 *
 * While this delivers the fastest absolute rendering performance, large
 * templates may cause the main thread to be consumed for long periods of time,
 * leading to user-noticeable performance degradation, or jank.
 *
 * See also: {@link AsyncRenderer}
 *
 * @public
 */
var SyncRenderer = function () {
    function SyncRenderer() {
        classCallCheck(this, SyncRenderer);
    }

    SyncRenderer.prototype.render = function render(iterator) {
        // Iterate the template iterator, executing the compiled template program
        // until there are no more instructions left to execute.
        var result = void 0;
        do {
            result = iterator.next();
        } while (!result.done);
        this.result = result.value;
    };

    SyncRenderer.prototype.rerender = function rerender() {
        if (!this.result) {
            throw new Error('Cannot re-render before initial render has completed');
        }
        this.result.rerender();
    };

    return SyncRenderer;
}();

// TODO - use symbol

function isSpecifierStringAbsolute$1(specifier) {
    var split = specifier.split(':');
    var type = split[0];
    var path = split[1];
    return !!(type && path && path.indexOf('/') === 0 && path.split('/').length > 3);
}
function isSpecifierObjectAbsolute$1(specifier) {
    return specifier.rootName !== undefined && specifier.collection !== undefined && specifier.name !== undefined && specifier.type !== undefined;
}
function serializeSpecifier$1(specifier) {
    var type = specifier.type;
    var path = serializeSpecifierPath$1(specifier);
    if (path) {
        return type + ':' + path;
    } else {
        return type;
    }
}
function serializeSpecifierPath$1(specifier) {
    var path = [];
    if (specifier.rootName) {
        path.push(specifier.rootName);
    }
    if (specifier.collection) {
        path.push(specifier.collection);
    }
    if (specifier.namespace) {
        path.push(specifier.namespace);
    }
    if (specifier.name) {
        path.push(specifier.name);
    }
    if (path.length > 0) {
        var fullPath = path.join('/');
        if (isSpecifierObjectAbsolute$1(specifier)) {
            fullPath = '/' + fullPath;
        }
        return fullPath;
    }
}
function deserializeSpecifier$1(specifier) {
    var obj = {};
    if (specifier.indexOf(':') > -1) {
        var split = specifier.split(':');
        var type = split[0];
        var path = split[1];
        obj.type = type;
        var pathSegments = void 0;
        if (path.indexOf('/') === 0) {
            pathSegments = path.substr(1).split('/');
            if (path.substr(1).startsWith('@')) {
                obj.rootName = pathSegments.shift() + '/' + pathSegments.shift();
            } else {
                obj.rootName = pathSegments.shift();
            }
            obj.collection = pathSegments.shift();
        } else {
            pathSegments = path.split('/');
        }
        if (pathSegments.length > 0) {
            obj.name = pathSegments.pop();
            if (pathSegments.length > 0) {
                obj.namespace = pathSegments.join('/');
            }
        }
    } else {
        obj.type = specifier;
    }
    return obj;
}

function assert$1(description, test) {
    if (!test) {
        throw new Error('Assertion Failed: ' + description);
    }
}

function detectLocalResolutionCollection(specifier) {
    var namespace = specifier.namespace,
        collection = specifier.collection;
    // Look for the local-most private collection contained in the namespace
    // (which will appear closest to the end of the string)

    var startPos = namespace.lastIndexOf('/-');
    if (startPos > -1) {
        startPos += 2;
        var endPos = namespace.indexOf('/', startPos);
        collection = namespace.slice(startPos, endPos > -1 ? endPos : undefined);
    }
    return collection;
}

var Resolver = function () {
    function Resolver(config, registry) {
        classCallCheck(this, Resolver);

        this.config = config;
        this.registry = registry;
    }

    Resolver.prototype.identify = function identify(specifier, referrer) {
        if (isSpecifierStringAbsolute$1(specifier)) {
            return specifier;
        }
        var s = deserializeSpecifier$1(specifier);
        var result = void 0;
        if (referrer) {
            var r = deserializeSpecifier$1(referrer);
            if (isSpecifierObjectAbsolute$1(r)) {
                assert$1('Specifier must not include a rootName, collection, or namespace when combined with an absolute referrer', s.rootName === undefined && s.collection === undefined && s.namespace === undefined);
                s.rootName = r.rootName;
                s.collection = r.collection;
                var definitiveCollection = this._definitiveCollection(s.type);
                if (!s.name) {
                    /*
                     * For specifiers without a name use the referrer's name and
                     * do not fallback to any other resolution rules.
                     */
                    s.namespace = r.namespace;
                    s.name = r.name;
                    return this._serializeAndVerify(s);
                }
                s.namespace = r.namespace ? r.namespace + '/' + r.name : r.name;
                if (detectLocalResolutionCollection(s) === definitiveCollection) {
                    /*
                     * For specifiers with a name, try local resolution. Based on
                     * the referrer.
                     */
                    if (result = this._serializeAndVerify(s)) {
                        return result;
                    }
                }
                // Look for a private collection in the referrer's namespace
                if (definitiveCollection) {
                    s.namespace += '/-' + definitiveCollection;
                    if (result = this._serializeAndVerify(s)) {
                        return result;
                    }
                }
                // Because local and private resolution has failed, clear all but `name` and `type`
                // to proceed with top-level resolution
                s.rootName = s.collection = s.namespace = undefined;
            } else {
                assert$1('Referrer must either be "absolute" or include a `type` to determine the associated type', r.type);
                // Look in the definitive collection for the associated type
                s.collection = this._definitiveCollection(r.type);
                if (!s.namespace) {
                    s.namespace = r.rootName;
                }
                assert$1('\'' + r.type + '\' does not have a definitive collection', s.collection);
            }
        }
        // If the collection is unspecified, use the definitive collection for the `type`
        if (!s.collection) {
            s.collection = this._definitiveCollection(s.type);
            assert$1('\'' + s.type + '\' does not have a definitive collection', s.collection);
        }
        if (!s.rootName) {
            // If the root name is unspecified, try the app's `rootName` first
            s.rootName = this.config.app.rootName || 'app';
            if (result = this._serializeAndVerify(s)) {
                return result;
            }
            // Then look for an addon with a matching `rootName`
            if (s.namespace) {
                s.rootName = s.namespace;
                s.namespace = undefined;
            } else {
                s.rootName = s.name;
                s.name = 'main';
            }
        }
        if (result = this._serializeAndVerify(s)) {
            return result;
        }
    };

    Resolver.prototype.retrieve = function retrieve(specifier) {
        return this.registry.get(specifier);
    };

    Resolver.prototype.resolve = function resolve(specifier, referrer) {
        var id = this.identify(specifier, referrer);
        if (id) {
            return this.retrieve(id);
        }
    };

    Resolver.prototype._definitiveCollection = function _definitiveCollection(type) {
        var typeDef = this.config.types[type];
        assert$1('\'' + type + '\' is not a recognized type', typeDef);
        return typeDef.definitiveCollection;
    };

    Resolver.prototype._serializeAndVerify = function _serializeAndVerify(specifier) {
        var serialized = serializeSpecifier$1(specifier);
        if (this.registry.has(serialized)) {
            return serialized;
        }
    };

    return Resolver;
}();

var BasicRegistry = function () {
    function BasicRegistry() {
        var entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        classCallCheck(this, BasicRegistry);

        this._entries = entries;
    }

    BasicRegistry.prototype.has = function has(specifier) {
        return specifier in this._entries;
    };

    BasicRegistry.prototype.get = function get$$1(specifier) {
        return this._entries[specifier];
    };

    return BasicRegistry;
}();

(function (self) {
  'use strict';

  if (self.fetch) {
    return;
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && function () {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    }(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

    var isDataView = function isDataView(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj);
    };

    var isArrayBufferView = ArrayBuffer.isView || function (obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name');
    }
    return name.toLowerCase();
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value;
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function next() {
        var value = items.shift();
        return { done: value === undefined, value: value };
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function () {
        return iterator;
      };
    }

    return iterator;
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function (value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function (header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function (name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function (name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ',' + value : value;
  };

  Headers.prototype['delete'] = function (name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function (name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
  };

  Headers.prototype.has = function (name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };

  Headers.prototype.set = function (name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function (callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  };

  Headers.prototype.values = function () {
    var items = [];
    this.forEach(function (value) {
      items.push(value);
    });
    return iteratorFor(items);
  };

  Headers.prototype.entries = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'));
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function (resolve, reject) {
      reader.onload = function () {
        resolve(reader.result);
      };
      reader.onerror = function () {
        reject(reader.error);
      };
    });
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise;
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('');
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0);
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer;
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function (body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type');
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob');
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };

      this.arrayBuffer = function () {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
        } else {
          return this.blob().then(readBlobAsArrayBuffer);
        }
      };
    }

    this.text = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text');
      } else {
        return Promise.resolve(this._bodyText);
      }
    };

    if (support.formData) {
      this.formData = function () {
        return this.text().then(decode);
      };
    }

    this.json = function () {
      return this.text().then(JSON.parse);
    };

    return this;
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read');
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests');
    }
    this._initBody(body);
  }

  Request.prototype.clone = function () {
    return new Request(this, { body: this._bodyInit });
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function (bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers;
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function () {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    });
  };

  Response.error = function () {
    var response = new Response(null, { status: 0, statusText: '' });
    response.type = 'error';
    return response;
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function (url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code');
    }

    return new Response(null, { status: status, headers: { location: url } });
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function (input, init) {
    return new Promise(function (resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function () {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    });
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : undefined);

function t(params, options) {
    if (options === void 0) {
        options = {};
    }
    var key = typeof params === 'string' ? params : params[0];
    if (options._pluralize) {
        key = options._pluralize === 1 ? key + ".one" : key + ".other";
    }
    var translation = window.appleTranslations[key];
    if (!translation) {
        return "**" + key + "**";
    }
    return Object.keys(options).reduce(function (finalTranslation, key) {
        if (key === 'store') return finalTranslation;
        return finalTranslation.replace("@@" + key + "@@", options[key]);
    }, translation);
}

/*
 *  src/reflect.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PRIVATE METHODS/IVARS ************************************
 */
var _nonOverrideableFunctions = { setDelegate: true };

/**
 ************************************ PSEUDO-PRIVATE METHODS/IVARS ************************************
 * These functions need to be accessible for ease of testing, but should not be used by clients
 */
function _utResetNonOverridableFunctions() {
    _nonOverrideableFunctions = { setDelegate: true };
}

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Simple shallow clone which just copies over top-level keys and values (without "hasOwnProperty" checks).
 * Useful for using a passed-in map without having that parameter data be corrupted by the function it's passed to.
 * @param source
 * @returns {object} will never return null... worst case will return an empty object.
 */
function shallowClone(source) {
    var dest = {};
    var sourceHasGetterAndSetterMethods = hasGetterAndSetterMethods(source);
    var aGetter;
    var aSetter;

    for (var key in source) {
        aGetter = null;
        aSetter = null;

        if (sourceHasGetterAndSetterMethods) {
            // Be careful to copy aGetter and setter methods properly, per: http://ejohn.org/blog/javascript-getters-and-setters/
            aGetter = source.__lookupGetter__(key);
            aSetter = source.__lookupSetter__(key);
        }

        if (aGetter || aSetter) {
            if (aGetter) {
                dest.__defineGetter__(key, aGetter);
            }
            if (aSetter) {
                dest.__defineSetter__(key, aSetter);
            }
        } else {
            dest[key] = source[key];
        }
    }
    return dest;
}

/**
 * Returns true if the specified obj is not undefined
 * NOTE: Does not work for global variables (because the variable gets defined by virtue of passing it in)... use "typeof()" directly
 */
function isDefined(anObject) {
    return typeof anObject !== 'undefined';
}

/**
 * Returns true if the specified obj is not undefined and not null
 * NOTE: Does not work for global variables... in that case, use "typeof()" directly, because the act of passing them to here will make them appear to be defined
 */
function isDefinedNonNull(anObject) {
    return isDefined(anObject) && anObject !== null;
}

/**
 * Returns true if the specified obj is not undefined and not null and not empty
 * NOTE: Does not work for global variables... in that case, use "typeof()" directly, because the act of passing them to here will make them appear to be defined
 */
function isDefinedNonNullNonEmpty(anObject) {
    return isDefinedNonNull(anObject) && !isEmptyString(anObject) && !isEmptyArray(anObject) && !isEmptyObject(anObject);
}

function isEmptyString(anObject) {
    return isString$1(anObject) && anObject.length === 0;
}

function isEmptyArray(anObject) {
    return isArray(anObject) && anObject.length === 0;
}

function isEmptyObject(anObject) {
    return isObject(anObject) && Object.keys(anObject).length === 0;
}

function isFunction(anObject) {
    // the following works for regular functions and native functions, e.g. iTunes.buy
    return typeof anObject === "function";
}

function isNumber(anObject) {
    return typeof anObject == "number";
}

function isInteger(anObject) {
    return isNumber(anObject) && anObject % 1 === 0;
}

function isString$1(anObject) {
    return typeof anObject === 'string' || anObject instanceof String;
}

function isElement$1(anObject) {
    return !!anObject && anObject.nodeType == 1;
}

function isArray(anObject) {
    return !!anObject && anObject.constructor === Array;
}

function isObject(anObject) {
    return !!anObject && anObject.constructor === Object;
}

/*
 * NOTE: this method skips object properties that are functions.
 */
function values(anObject) {
    var values = [];
    for (var property in anObject) {
        var aValue = anObject[property];
        if (anObject.hasOwnProperty(property) && !isFunction(aValue)) {
            values.push(aValue);
        }
    }
    return values;
}

function keys(anObject) {
    var keys = [];
    for (var property in anObject) {
        if (anObject.hasOwnProperty(property) && !isFunction(anObject[property])) {
            keys.push(property);
        }
    }
    return keys;
}

/**
 * Returns "true" if the passed-in object has any values at all on it.
 * NOTE: this method skips object properties that are functions.
 */
function hasAnyKeys(anObject) {
    for (var aKey in anObject) {
        if (anObject.hasOwnProperty(aKey)) {
            return true;
        }
    }
}

/**
 * Returns "true" if the passed-in object has any values on it at all *and* at least one of those values is non-null.
 * NOTE: this method skips object properties that are functions.
 */
function hasAnyNonNullKeys(anObject) {
    for (var aKey in anObject) {
        if (anObject.hasOwnProperty(aKey) && anObject[aKey]) {
            return true;
        }
    }
}

/**
 * @return {boolean} true if the object has the default object getter and setter methods (e.g. __lookupGetter__())
 * see <rdar://problem/33045481> MetricsKit: Protect against JS errors when __lookupGetter__ is not on the object prototype
 */
function hasGetterAndSetterMethods(anObject) {
    return isObject(anObject) && isFunction(anObject.__lookupGetter__) && isFunction(anObject.__lookupSetter__) && isFunction(anObject.__defineGetter__) && isFunction(anObject.__defineSetter__);
}

/*
 * NOTE: this method returns *only* object properties that are functions.
 */
function methods(anObject) {
    var methods = [];
    for (var property in anObject) {
        var aValue = anObject[property];
        if (anObject.hasOwnProperty(property) && isFunction(aValue)) {
            methods.push(aValue);
        }
    }
    return methods;
}

/*
 * NOTE: this method skips object properties that are functions.
 */
function invert(anObject) {
    var invertedMap = {};
    for (var property in anObject) {
        if (anObject.hasOwnProperty(property) && !isFunction(anObject[property])) {
            invertedMap[anObject[property]] = property;
        }
    }
    return invertedMap;
}

/**
 * Adds all the fields of the objects in the varargs to the fields in the first parameter, "obj".
 * *All* "hasOwnProperty" fields will be added, including functions and fields with no values.
 * @param {Object} targetObject an object with keys and values. If only one parameter is provided, the return value will be the non-null values of that single object.
 * @param {varargs} sourceObjectN a variable number of Object arguments from 0-N. Each object's fields will be copied into targetObject. Later objects take precedence over earlier ones.
 * @return targetObject (*not* a clone) with the additional fields added..
 */
function extend(targetObject /* , ...sourceObjectN(varargs) */) {
    var argumentsArray = [true, true, true].concat(Array.prototype.slice.call(arguments));
    return copyKeysAndValues.apply(null, argumentsArray);
}

/**
 * Takes one or more objects, [possibly] cleans them (removes keys that are typeof 'function', keys with 'null' values, keys with 'undefined' values),
 * merges them (later objects take precedence), and returns a single object with the union of all remaining fields.
 * @param keepNullsAndUndefined a boolean if true fields with a "null" or "undefined" value will still be copied.
 * Otherwise, if false, any field with a "null" or "undefined" value will not be copied.
 * @param keepFunctions a boolean if true fields whose value is typeof 'function' will still be copied.
 * Otherwise, if false, any field with a typeof 'function' value will not be copied.
 * @param inPlace a boolean if true will copy all results to the "targetObject" object, rather than copying them all to a new object.
 *  Otherwise if "inPlace" is false, a new object will be returned and all passed in objects are treated as immutable and so will never be modified.
 * @param {Object} targetObject an object with keys and values. If only one parameter is provided, the return value will be the non-null values of that single object.
 * @param {varargs} sourceObjectN a variable number of Object arguments from 0-N. Each object's fields will be copied into targetObject. Later objects take precedence over earlier ones.
 * @return either targetObject (if "inPlace" is true) or a new object (if "inPlace" is false or "targetObject" is null) with the
 * union of all fields, filtered based on the values of the keepNullsAndUndefined and keepFunctions parameters
 * @example copyKeysAndValues(true, {}) ===> {}
 * @example copyKeysAndValues(true, null) ===> {}
 * @example copyKeysAndValues({true, "foo":10}) ===> {"foo":10}
 * @example copyKeysAndValues({true, "foo":10, "bar":null}) ===> {"foo":10}
 * @example copyKeysAndValues({false, "foo":10, "bar":null}) ===> {"foo":10, "bar":null}
 * @example copyKeysAndValues({true, "foo":10, "bar":null}, {"cat":null}) ===> {"foo":10}
 * @example copyKeysAndValues({true, "foo":10, "bar":null}, {"cat":null, "mouse":"gray"}) ===> {"foo":10, "mouse":"gray"}
 * @example copyKeysAndValues({true, "foo":10, "bar":null}, {"cat":null, "mouse":"gray", "dog":"bark"}) ===> {"foo":10, "mouse":"gray", "dog":"bark"}
 * @example copyKeysAndValues({true, "foo":10, "bar":null}, {"cat":null, "mouse":"gray", "dog":"bark", "foo":11}) ===> {"foo":11, "mouse":"gray", "dog":"bark"}
 * @example copyKeysAndValues({true, "foo":10, "bar":null}, {"cat":null, "mouse":"gray", "dog":"bark", "foo":11}, {"foo":12}) ===> {"foo":12, "mouse":"gray", "dog":"bark"}
 */
function copyKeysAndValues(keepNullsAndUndefined, keepFunctions, inPlace, targetObject /*, sourceObjectN(varargs)*/) {
    var returnValue = inPlace ? targetObject || {} : {};
    var sourceObject;

    for (var ii = 3; ii < arguments.length; ii++) {
        sourceObject = arguments[ii];

        for (var key in sourceObject) {
            if (Object.prototype.hasOwnProperty.call(sourceObject, key)) {
                var value = sourceObject[key];

                if (keepNullsAndUndefined || value !== null && value !== undefined) {
                    if (keepFunctions || typeof value !== 'function') {
                        returnValue[key] = value;
                    }
                }
            }
        }
    }
    return returnValue;
}

/**
 * Add one or more function names to the list of non overrideable functions
 * attachDelegate will check this list and not override any functions with matching names
 * @param {Array} functionNames
 * @returns undefined
 */
function addNonOverrideableFunctions(functionNames) {
    for (var i = 0; i < functionNames.length; i++) {
        var functionName = functionNames[i];
        _nonOverrideableFunctions[functionName] = true;
    }
}

/**
 * Replace any "target" methods found on "delegate" with the delegate's version of the method.
 * The replacement function will actually be our own wrapper function with the original function attached as a property called origFunction
 * in case the delegate's replacement method wants to, essentially, call "super"
 * We do delegation this way, vs. checking each time a "target" function is called, because this way we don't pollute the implementation
 * of all the target's functions.
 * Subsequent calls to "attachDelegate" will then replace whatever methods *they* match, including methods that have already been replaced.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If a replaced method is overridden again with a subsequent "setDelegate" call, the "origFunction" parameter will be the previous delegate's function.
 * NOTE: Only methods present on "target" will be replaced
 * @param {Object} target
 * @param {Object} delegate
 * @returns {Boolean} true if one or more methods on the delegate object were attached to the target object
 */
function attachDelegate(target, delegate) {
    var returnValue = false;

    if (target && delegate && target !== delegate) {
        // only attach methods that exist on the target
        var methodsToOmitMap = {};
        Object.keys(delegate).forEach(function (methodName) {
            if (!target[methodName]) {
                methodsToOmitMap[methodName] = true;
            }
        });

        // ignore nonOverrideableFunctions
        extend(methodsToOmitMap, _nonOverrideableFunctions);

        returnValue = attachMethods(target, delegate, null, methodsToOmitMap);
    }

    return returnValue;
}

/**
 * Replace any "target" methods found on "source" with the source's version of the method.
 * The replacement function will actually be our own wrapper function with the original function attached as a property called origFunction
 * in case the source's replacement method wants to, essentially, call "super"
 * We do delegation this way, vs. checking each time a "target" function is called, because this way we don't pollute the implementation
 * of all the target's functions.
 * Subsequent calls to "attachMethods" will then replace whatever methods *they* match, including methods that have already been replaced.
 * This allows callers to use "canned" sources to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If a replaced method is overridden again with a subsequent "attachMethod" call, the "origFunction" parameter will be the previous source's function.
 * @param {Object} target
 * @param {Object} source
 * @param {Object} (optional) methodContext 'this' context to apply to any bound methods; defaults to the source object
 * @param {Object} (optional) methodsToOmitMap a dictionary of method names to ignore when copying
 * @returns {Boolean} true if one or more methods on the source object were attached to the target object
 */
function attachMethods(target, source, methodContext, methodsToOmitMap) {
    var returnValue = false;

    if (target && source) {
        methodsToOmitMap = methodsToOmitMap || {};
        methodContext = methodContext || source;

        var captureFunction = function captureFunction(methodContext, capturedOrigFunction, source, functionName) {
            var returnValue = function returnValue() {
                // dereference the source so delegate chaining (source object delegating to another object) works properly
                return source[functionName].apply(methodContext, arguments);
            };
            // Attach the origFunction in case its needed later by the caller for delegate chaining.
            // Do that in here too, so it doesn't get overwritten in the loop...
            if (capturedOrigFunction) {
                returnValue.origFunction = capturedOrigFunction;
            }
            // we need to add a symbol to the attached function that doesn't have an original function, in order to remove them by "detachMethods()".
            returnValue.attachedMethod = true;

            return returnValue;
        };

        for (var functionName in source) {
            if (!(functionName in methodsToOmitMap)) {
                if (source[functionName] && isFunction(source[functionName])) {
                    var origFunction = target[functionName];
                    var origFunctionExists = origFunction && isFunction(origFunction);
                    var capturedOrigFunction = null;
                    if (origFunctionExists) {
                        // Avoid binding the delegate function repeatedly
                        // We need to avoid binding the delegated function in order to the "detachMethods" function could reset the delegated function to the original function by the "origFunction" chain.
                        // And the delegated function's context was already bound in captureFunction.
                        if (origFunction.attachedMethod === true) {
                            capturedOrigFunction = origFunction;
                        } else {
                            capturedOrigFunction = origFunction.bind(target);
                        }
                    }

                    // Careful! This is that tough "closure in a loop" case where the local variables captured by the closure
                    // will change even for previously created closure functions on each iteration of this loop!
                    // So, we need to capture it in an additional, invoked, closure...
                    // See (and cited links): http://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example
                    target[functionName] = captureFunction(methodContext, capturedOrigFunction, source, functionName);
                    returnValue = true;
                }
            }
        }
    }
    return returnValue;
}

/**
 * detach the any of delegated methods(the functions which have 'attachedMethod' symbol) from the provided object
 * @param target
 * @returns {boolean} true if one or more delegate methods were detached from the target object
 */
function detachMethods(target) {
    var returnValue = false;
    for (var propKey in target) {
        if (isFunction(target[propKey]) && target[propKey].attachedMethod === true) {
            var methodIsDelegated = target[propKey].origFunction;
            if (methodIsDelegated) {
                while (target[propKey].origFunction) {
                    target[propKey] = target[propKey].origFunction;
                    returnValue = true;
                }
            } else {
                delete target[propKey];
            }
        }
    }
    return returnValue;
}

/**
 * Convenience method to loop over a set of delegatable targets and apply appropriate delegates
 * @param {Object} targetMap containing one or more delegatable target objects
 * @param {Object} delegateMap containing one or more delegates
 * @return {Object} contains the results of all setDelegate calls
 * @example usage:
 *    var targetMap = { environment: environmentObject, eventRecorder: eventRecorderObject, foo: fooObject };
 *    var delegateMap = { environment: environmentDelegate, eventRecorder: eventRecorderDelegate };
 *    setDelegates(targetMap, delegateMap); // returns { environment: true, eventRecorder: true }
 *    // targetMap.environment's delegate is now environmentDelegate and targetMap.eventRecorder's delegate is now eventRecorderDelegate
 */
function setDelegates(targetMap, delegateMap) {
    var resultObject = {};

    for (var targetName in targetMap) {
        if (delegateMap[targetName] && isFunction(targetMap[targetName].setDelegate)) {
            resultObject[targetName] = targetMap[targetName].setDelegate(delegateMap[targetName]);
        }
    }

    return resultObject;
}

/**
 * Reset the delegate functions from the objects of provided target map.
 * @param {Object} targetMap containing one or more delegatable target objects
 * @returns {Boolean} true if one or more delegate methods were reset from the target object
 */
var resetDelegates = function resetDelegates(targetMap) {
    var returnValue = false;

    for (var targetName in targetMap) {
        var delegateObject = targetMap[targetName];
        if (delegateObject && (typeof delegateObject === "undefined" ? "undefined" : _typeof(delegateObject)) === 'object' && isFunction(delegateObject.setDelegate)) {
            returnValue |= detachMethods(delegateObject);
        }
    }
    return !!returnValue;
};

/**
 * @param {Object} sourceObject
 * @param {Object} targetObject
 * @returns {Boolean} true if one or more methods on the target was delegated, false otherwise
 * If one (or more) of the source object's methods has been delegated to a function,
 * the same method on the target object will also be delegated to that function
 */
function copyDelegatedFunctions(sourceObject, targetObject) {
    var returnValue = null;

    if (sourceObject && targetObject && targetObject.setDelegate) {
        var delegatedFunctions = {};
        var functionName;

        for (functionName in sourceObject) {
            if (isFunction(sourceObject[functionName]) && sourceObject[functionName].origFunction) {
                delegatedFunctions[functionName] = sourceObject[functionName];
            }
        }

        returnValue = targetObject.setDelegate(delegatedFunctions);
    }

    return returnValue;
}

var reflect$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _utResetNonOverridableFunctions: _utResetNonOverridableFunctions,
    shallowClone: shallowClone,
    isDefined: isDefined,
    isDefinedNonNull: isDefinedNonNull,
    isDefinedNonNullNonEmpty: isDefinedNonNullNonEmpty,
    isEmptyString: isEmptyString,
    isEmptyArray: isEmptyArray,
    isEmptyObject: isEmptyObject,
    isFunction: isFunction,
    isNumber: isNumber,
    isInteger: isInteger,
    isString: isString$1,
    isElement: isElement$1,
    isArray: isArray,
    isObject: isObject,
    values: values,
    keys: keys,
    hasAnyKeys: hasAnyKeys,
    hasAnyNonNullKeys: hasAnyNonNullKeys,
    hasGetterAndSetterMethods: hasGetterAndSetterMethods,
    methods: methods,
    invert: invert,
    extend: extend,
    copyKeysAndValues: copyKeysAndValues,
    addNonOverrideableFunctions: addNonOverrideableFunctions,
    attachMethods: attachMethods,
    detachMethods: detachMethods,
    attachDelegate: attachDelegate,
    setDelegates: setDelegates,
    resetDelegates: resetDelegates,
    copyDelegatedFunctions: copyDelegatedFunctions
});

/*
 *  src/backoff.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

var DEFAULTS = {
    exponential: {
        maxWait: 1500,
        initialDelay: 100,
        factor: 2
    }
};

/**
 * @param {int} (optional) initialDelay - time in ms before the first reattempt (each subsequent reattempt will wait exponentially longer than the previous one)
 * @param {int} (optional) maxWait - max cumulative time in ms to wait before giving up (does not include the time taken by the function to execute)
                                     setting this to 0 will cause the strategy to retry indefinitely
 * @param {int} (optional) factor - multiplier to apply when delaying subsequent reattempts. Defaults to DEFAULT_EXPONENT_FACTOR
 */
var ExponentialStrategy = function ExponentialStrategy(initialDelay, maxWait, factor) {
    this.delay = initialDelay || DEFAULTS.exponential.initialDelay;
    this.maxWait = isNumber(maxWait) ? maxWait : DEFAULTS.exponential.maxWait;
    this.factor = factor || DEFAULTS.exponential.factor;

    this.timeWaited = 0;
};

ExponentialStrategy.prototype.nextDelay = function nextDelay() {
    var returnValue = null;

    var timeRemaining = this.maxWait - this.timeWaited;

    if (timeRemaining > 0) {
        this.delay = Math.min(this.delay, timeRemaining);
        this.timeWaited += this.delay;
    }

    if (this.maxWait === 0 || timeRemaining > 0) {
        returnValue = this.delay;
        this.delay = this.delay * this.factor; // increase the delay for next time
    }

    return returnValue;
};

/**
 * Execute a function according to a given backoff failure strategy
 * @param {Object} strategy is an object representing a failure stategy. It has a nextDelay() method that returns the time in ms to wait until reattempting
 * @param {Function} networkRequestor - the function to execute. It should accept an onSuccessHandler and an onFailureHandler as its final arguments
 * @param {Function} onSuccessHandler - callback to execute on success
 * @param {Function} onFailureHandler - callback to execute on failure
 */
function _backoff(strategy, networkRequestor, onSuccessHandler, onFailureHandler) {
    var onBackoff = function onBackoff() {
        var delay = strategy.nextDelay();
        if (delay) {
            setTimeout(_backoff.bind(null, strategy, networkRequestor, onSuccessHandler, onFailureHandler), delay);
        } else {
            onFailureHandler.apply(onFailureHandler, arguments);
        }
    };

    networkRequestor.call(networkRequestor, onSuccessHandler, onBackoff);
}

/**
 * Execute a function according to an exponential backoff failure strategy
 * @param {Function} networkRequestor - the function to execute. It should accept an onSuccessHandler and an onFailureHandler as its final arguments
 * @param {Function} onSuccessHandler - callback to execute on success
 * @param {Function} onFailureHandler - callback to execute on failure
 * @param {int} (optional) initialDelay - time in ms before the first reattempt (each subsequent reattempt will wait exponentially longer than the previous one)
 * @param {int} (optional) maxWait - max cumulative time in ms to wait before giving up (does not include the time taken by the function to execute)
                                     setting this to 0 will cause the strategy to retry indefinitely
 * @param {int} (optional) factor - multiplier to apply when delaying subsequent reattempts. Defaults to DEFAULT_EXPONENT_FACTOR
 */
function exponentialBackoff(networkRequestor, onSuccessHandler, onFailureHandler, initialDelay, maxWait, factor) {
    var strategy = new ExponentialStrategy(initialDelay, maxWait, factor);
    _backoff(strategy, networkRequestor, onSuccessHandler, onFailureHandler);
}

var backoff = /*#__PURE__*/Object.freeze({
    __proto__: null,
    exponentialBackoff: exponentialBackoff
});

/*
 *  src/number.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * "De-res" a number (lower the resolution of the number) per the Privacy Team and these radars:
 * <rdar://problem/17423020> Add "capacityXXX" fields to UserXP Figaro reporting.
 * <rdar://problem/23571925> Privacy: De-res capacityXXX fields
 * Default behavior will de-res numbers by a magnitude of 1024^2 ie. bytes to megabytes and remove the last two significant digits
 * For example, a raw number of bytes "de-res"'d to MB, but without the "floor" filter, would look like these examples:
 *      31708938240/1024/1024 ==> 30240
 *      15854469120/1024/1024 ==> 15120
 *      63417876480/1024/1024 ==> 60480
 *
 * With the "floor" formula we replace the two least significant digits with "00"
 * Doing so will convert values like so:
 *
 *      31708938240/1024/1024 ==> 30200
 *      15854469120/1024/1024 ==> 15100
 *      63417876480/1024/1024 ==> 60400
 *
 * @param {number} aNumber
 * @param {number} (optional) magnitude, must be greater than 0. default 1024^2
 * @param {number} (optional) significantDigits to remove, must be a positive integer or 0. default 2
 * @returns {number} if the "aNumber" parameter is absent, the return value will be undefined.
 * If any of the arguments are disallowed values, the value "NaN" will be returned.
 * @overridable
 */
function deResNumber(aNumber, magnitude, significantDigits) {
    var returnValue = undefined; // jshint ignore: line

    if (isDefined(aNumber)) {
        if (!isDefined(magnitude)) {
            magnitude = 1024 * 1024;
        }
        if (!isDefined(significantDigits)) {
            significantDigits = 2;
        }

        if (isNumber(aNumber) && isNumber(magnitude) && magnitude > 0 && isInteger(significantDigits) && significantDigits >= 0) {
            var roundFactor = Math.pow(10, significantDigits);
            var roundOperation = aNumber > 0 ? 'floor' : 'ceil';

            returnValue = Math[roundOperation](aNumber / magnitude / roundFactor) * roundFactor;
        } else {
            returnValue = NaN;
        }
    }

    return returnValue;
}

var number = /*#__PURE__*/Object.freeze({
    __proto__: null,
    deResNumber: deResNumber
});

/*
 *  src/config.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 * @deprecated This class will be removed in the next Major release because the methods of this class have been moved to the mt-client-config/src/config/metrics_config.js
 * Config utility methods
 * IMPORTANT: These methods should be called within the context of a Config instance that implements a value() method,
 *            such as @amp/mt-client-config (the singleton or any instance created by it).
 *            They can be attached via reflect.attachMethods, passing the config instance as the methodContext
 * @example:
 *     var Config = require('@amp/mt-client-config');
 *     var configUtils = ( ... ); // this file
 *     reflect.attachMethods(Config, configUtils, Config);
 * Failing to use the correct context will result in thrown errors ("this.value is not a function").
 */

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * @deprecated
 * Boolean config value which, when "true", tells clients to avoid all metrics code paths (different than simply not sending metrics).
 * Useful for avoiding discovered client bugs.
 * NOTE1: This will cause unrecoverable event loss, as the clients will not be recording events at all.
 * NOTE2: Typically all event_handlers will check for this in addition to "recordEvent()" checking because that way
 * if a client overrides "recordEvent", these checks will still take effect.
 * We also test it in recordEvent() in case someone creates their own event_handler, we'd still want to exclude what needs to be excluded.
 * @param {String} (optional) topic the Figaro topic to use to look up config values
 * @returns {boolean}
 */
function disabled(topic) {
    return this.value('disabled', topic) ? true : false;
}

/**
 * @deprecated
 * Array config value which instructs clients to avoid sending particular event types.
 * Useful for reducing server processing in emergencies by abandoning less-critical events.
 * Useful for dealing with urgent privacy concerns, etc., around specific events.
 * NOTE1: This will cause unrecoverable event loss, as the clients will not be recording events at all.
 * NOTE2: Typically all event_handlers will check for this in addition to "recordEvent()" checking because that way
 * if a client overrides "recordEvent", these checks will still take effect.
 * We also test it in recordEvent() in case someone creates their own event_handler, we'd still want to exclude what needs to be excluded, in case they don't.
 * @param {String} (optional) topic the Figaro topic to use to look up config values
 * @returns {Array} Guaranteed to always return a valid array, though it may be empty if the value was unset in config
 */
function blacklistedEvents(topic) {
    var returnArray = this.value('blacklistedEvents', topic);

    return returnArray || [];
}

/**
 * @deprecated
 * Array config value which instructs clients to avoid sending particular event fields.
 * Useful for dealing with urgent privacy concerns, etc., around specific event fields (e.g. dsid)
 * NOTE: Typically all event_handlers will check for this in addition to "recordEvent()" checking because that way
 * if a client overrides "recordEvent", these checks will still take effect.
 * We also test it in recordEvent() in case someone creates their own event_handler, we'd still want to exclude what needs to be excluded, in case they don't.
 * @param {String} (optional) topic the Figaro topic to use to look up config values
 * @returns {Array} Guaranteed to always return a valid array, though it may be empty if the value was unset in config
 */
function blacklistedFields(topic) {
    var returnArray = this.value('blacklistedFields', topic);

    return returnArray || [];
}

/**
 * @deprecated
 * Remove all blacklisted fields from the passed-in object.
 * IMPORTANT: This action is performed in-place for performance of not having to create new objects each time.
 * NOTE: Typically all event_handlers will call this in addition to "recordEvent()" calling it because that way
 * if a client overrides "recordEvent", these checks will still take effect.
 * We also test it in recordEvent() in case someone creates their own event_handler, we'd still want to exclude what needs to be excluded, in case they don't.
 * @param {Object} eventFields a dictionary of event data
 * @param {String} (optional) topic the Figaro topic to use to look up config values
 * @returns {Object} the passed-in object with any blacklisted fields removed
 */
function removeBlacklistedFields(eventFields, topic) {
    if (eventFields) {
        var blacklistedFieldsArray = blacklistedFields.call(this, topic);

        for (var ii = 0; ii < blacklistedFieldsArray.length; ii++) {
            var aBlacklistedField = blacklistedFieldsArray[ii];
            // Double check this is not null (or empty string), or "delete" will blow up...
            if (aBlacklistedField) {
                if (aBlacklistedField in eventFields) {
                    delete eventFields[aBlacklistedField];
                }
            }
        }
    }
    return eventFields;
}

/**
 * @deprecated
 * Convenience function used by event handlers to determine if they should build and return metricsData.
 * NOTE: Typically all event_handlers will check for this in addition to "recordEvent()" checking because that way
 * if a client overrides "recordEvent", these checks will still take effect.
 * We also test it in recordEvent() in case someone creates their own event_handler, we'd still want to exclude what needs to be excluded, in case they don't.
 * @param {String} anEventType
 * @param {String} (optional) topic the Figaro topic to use to look up config values
 * @returns {Boolean} returns "true" if <b>either</b> "disabled()" is true or "blacklistedEvents()" contains this eventType
 */
function metricsDisabledOrBlacklistedEvent(anEventType, topic) {
    var returnValue = disabled.call(this, topic) || (anEventType ? blacklistedEvents.call(this, topic).indexOf(anEventType) > -1 : false);

    return returnValue;
}

/**
 * @deprecated
 * Config map which instructs clients to de-res (lower the resolution of) particular event fields.
 * The Privacy team typically requires device capacity information to be de-resed.
 * @param {String} (optional) topic the Figaro topic to use to look up config values
 * @returns {Array} An array of config objects { fieldName, (optional) magnitude, (optional) significantDigits }
 * Guaranteed to always return a valid array, though it may be empty if the value was unset in config
 */
function deResFields(topic) {
    var returnArray = this.value('deResFields', topic);

    return returnArray || [];
}

/**
 * @deprecated
 * De-res appropriate fields in the passed-in object by lowering the resolution of those field values.
 * For example, a raw number of bytes "de-res"'d to MB, but without the "floor" filter, would look like these examples:
 *      31708938240/1024/1024 ==> 30240
 *      15854469120/1024/1024 ==> 15120
 *      63417876480/1024/1024 ==> 60480
 *
 * With the "floor" formula we replace the two least significant digits with "00"
 * Doing so will convert values like so:
 *
 *      31708938240/1024/1024 ==> 30200
 *      15854469120/1024/1024 ==> 15100
 *      63417876480/1024/1024 ==> 60400
 *
 * IMPORTANT: This action is performed in-place for performance of not having to create new objects each time.
 * NOTE: Be careful not to call this method more than once for a given event, as de-resing a number more than
 * once can lead to inaccurate reporting (numbers will likely be smaller than their real values)
 * @param {Object} eventFields a dictionary of event data
 * @param {String} (optional) topic the Figaro topic to use to look up de-res config values
 * @returns {Object} the passed-in object with any fields de-resed
 */
function applyDeRes(eventFields, topic) {
    if (eventFields) {
        var deResFieldsConfigArray = deResFields.call(this, topic);
        var fieldName;

        deResFieldsConfigArray.forEach(function (deResFieldConfig) {
            fieldName = deResFieldConfig.fieldName;
            if (fieldName in eventFields) {
                eventFields[fieldName] = deResNumber(eventFields[fieldName], deResFieldConfig.magnitude, deResFieldConfig.significantDigits);
            }
        });
    }
    return eventFields;
}

var config = /*#__PURE__*/Object.freeze({
    __proto__: null,
    disabled: disabled,
    blacklistedEvents: blacklistedEvents,
    blacklistedFields: blacklistedFields,
    removeBlacklistedFields: removeBlacklistedFields,
    metricsDisabledOrBlacklistedEvent: metricsDisabledOrBlacklistedEvent,
    deResFields: deResFields,
    applyDeRes: applyDeRes
});

/*
 *  src/string.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 **************************** PUBLIC METHODS/IVARS ****************************
 */

/** Canned alphabets for use with convertNumberToBaseAlphabet
* Users can create their own alphabets/bases, e.g. "base61Alphabet",
* by truncating characters from the below, pre-defined, alphabets)
*/
var base10Alphabet = '0123456789';
var base16Alphabet = base10Alphabet + 'ABCDEF';
var base36Alphabet = base10Alphabet + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
var base61Alphabet = base36Alphabet + 'abcdefghijklmnopqrstuvwxy';
var base62Alphabet = base61Alphabet + 'z';

/**
 * Test if mainString starts with subString.
 * Optionally specify boolean "ignoreCase".
 * @param mainString
 * @param subString
 * @param ignoreCase
 * @returns {boolean} "false" if "mainString" or "subString" are null.
 */
function startsWith(mainString, subString, ignoreCase) {
    var returnValue = false;

    if (mainString && subString) {
        mainString = mainString.substr(0, subString.length);
        if (ignoreCase) {
            mainString = mainString.toLowerCase();
            subString = subString.toLowerCase();
        }
        returnValue = mainString.indexOf(subString) === 0;
    }
    return returnValue;
}

/**
 * Test if one string ends with another.
 * @param mainString
 * @param subString
 * @param ignoreCase
 * @returns {boolean} "false" if "mainString" or "subString" are null.
 */
function endsWith(mainString, subString, ignoreCase) {
    var returnValue = false;
    if (mainString && subString) {
        if (ignoreCase) {
            mainString = mainString.toLowerCase();
            subString = subString.toLowerCase();
        }
        // These two lines of logic (the guts) are the implementation from Prototype.js, which is well-optimized and well-tested.
        var endIndex = mainString.length - subString.length;
        returnValue = endIndex >= 0 && mainString.lastIndexOf(subString) === endIndex;
    }
    return returnValue;
}

/**
 * Removes characters in the passed-in charString from the front and back of baseString
 *
 * If no "charsString" is passed in (or it's non-null but identical to stringWhitespace), it tries to use the browser-platform-native "trim()" if found, otherwise trims the stringWhitespace characters (which are the same set trimmed by the built-in function):
 * If a non-null "charsString" string is passed in, it will try to remove all characters within that string, regardless of their order.
 *
 * (NOTE: These come from WebKit's built-in "trim()" method, who's testcase lives here:
 * http://code.google.com/p/v8/source/browse/branches/bleeding_edge/test/mjsunit/third_party/string-trim.js?spec=svn3842&r=3052
 *  '\u0009' (HORIZONTAL TAB)
 *  '\u000A' (LINE FEED OR NEW LINE)
 *  '\u000B' (VERTICAL TAB)
 *  '\u000C' (FORMFEED)
 *  '\u000D' (CARRIAGE RETURN)
 *  '\u0020' (SPACE)
 *  '\u00A0' (NO-BREAK SPACE)
 *  '\u2000' (EN QUAD)
 *  '\u2001' (EM QUAD)
 *  '\u2002' (EN SPACE)
 *  '\u2003' (EM SPACE)
 *  '\u2004' (THREE-PER-EM SPACE)
 *  '\u2005' (FOUR-PER-EM SPACE)
 *  '\u2006' (SIX-PER-EM SPACE)
 *  '\u2007' (FIGURE SPACE)
 *  '\u2008' (PUNCTUATION SPACE)
 *  '\u2009' (THIN SPACE)
 *  '\u200A' (HAIR SPACE)
 *  '\u3000' (IDEOGRAPHIC SPACE)
 *  '\u2028' (LINE SEPARATOR)
 *  '\u2029' (PARAGRAPH SEPARATOR)
 *  '\u200B' (ZERO WIDTH SPACE (category Cf)'}
 * NOTE: If you pass a custom "charString" and want whitespace removed as well, be sure to include the whitespace string as well
 * Examples: " hello world ".trim() -> "hello world" -- " e hello world f".trim(stringWhitespace+"ef") -> "hello world"
 * @param basestring is the string to trim
 * @param If no "charsString" is passed in (or it's non-null but identical to stringWhitespace), it tries to use the browser-platform-native "trim()" if found, otherwise trims the stringWhitespace characters (which are the same set trimmed by the built-in function):
 * If a non-null "charsString" string is passed in, it will try to remove all characters within that string, regardless of their order.
 * @param forceNonNativeTrim is mostly used for testing purposes, but does what it says.
 */
function trim(baseString, charString, forceNonNativeTrim) {
    var returnValue = null;
    var stringWhitespace = "\t\n\x0B\f\r \xA0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u3000\u2028\u2029\u200B";
    var whitespaceTrimStartRegex = new RegExp('^[' + stringWhitespace + ']+'); // No need to create a new one of these objects on each call!
    var whitespaceTrimEndRegex = new RegExp('[' + stringWhitespace + ']+$'); // No need to create a new one of these objects on each call!

    if (baseString) {
        if (!forceNonNativeTrim && (!charString || charString == stringWhitespace) && baseString.trim) {
            // Use browser-built-in trim, if it exists...
            returnValue = baseString.trim();
        } else {
            // NOTE: IF YOU MODIFY THIS METHOD, COPY AND TEST THE MODIFICATION TO itmsCheck.js WHICH HAS A COPY/PASTED VERSION (SANS COMMENTS)
            var trimChars = null;
            var startRegex = null;
            var endRegex = null;

            if (charString && typeof charString !== 'undefined') {
                // This is bits and pieces combined together from here: http://stackoverflow.com/questions/494035/how-do-you-pass-a-variable-to-a-regular-expression-javascript
                charString = charString.replace(/([.?*+^$[\]\\(){}-])/g, "\\$1"); // If we don't do this, then if "mainString" has .'s, or other regex chars in it, the regex interprets them as part of the regex!
                trimChars = "[" + charString + "]";
                startRegex = new RegExp('^' + trimChars + '+');
                endRegex = new RegExp(trimChars + '+$');
            } else {
                trimChars = stringWhitespace;
                startRegex = whitespaceTrimStartRegex;
                endRegex = whitespaceTrimEndRegex;
            }
            var str = baseString.replace(startRegex, '');
            returnValue = str.replace(endRegex, '');
        }
    }
    return returnValue;
}

/**
 * Changes snake_case "source" string to lowerCamelCase or UpperCamelCase
 * @param {String} source underscore separated sentence/list of words
 * @param {Boolean} upperCamelCase - optional parameter specifying whether to capitalize the first letter, defaults to false
 * @return {String} result the source parameter in lower or upper camel case
 */
function snakeCaseToCamelCase(source, upperCamelCase) {
    var result = '';
    if (source) {
        var words = source.toLowerCase().split('_');
        var firstChar;

        for (var i = 0; i < words.length; i++) {
            firstChar = words[i][0];
            if (i !== 0 || upperCamelCase) {
                firstChar = firstChar.toUpperCase();
            }
            result += firstChar + words[i].slice(1);
        }
    }
    return result;
}

/**
 * Changes snake_case "source" string to UpperCamelCase
 * @param  {String} source Underscore separated sentence/list of words
 * @return {String} result The source parameter in upper camel case
 */
function snakeCaseToUpperCamelCase(source) {
    return snakeCaseToCamelCase(source, true);
}

/**
 * Turns an object into a query param string
 * @param {Object} params is the set of key-value pairs to turn into a query param string.
 * @returns {String} a query param string with URI-encoded values created using the key-value pairs in the passed in object. e.g. "app=com.apple.Safari&testValue=test&eventTime=14927450"
 * NOTE: The first key of the returned string is never prefaced, not with an ampersand (&) or a question mark (?)
 * @example
 *     var paramString = _utils.string.paramString({
 *          app: 'com.apple.Safari',
 *          testValue: 'test',
 *          eventTime: 14927450
 *     });
 */
function paramString(params) {
    var paramString = '';
    var delimiter = '';
    var firstKey = true;

    for (var key in params) {
        var value = params[key];
        if (value || value === 0 || value === false) {
            paramString += delimiter + key + '=' + encodeURIComponent(value);
            if (firstKey) {
                delimiter = '&';
                firstKey = false;
            }
        }
    }
    return paramString;
}

function exceptionString$1(className, methodName) {
    return "The function " + className + "." + methodName + "() must be overridden with a platform-specific delegate function." + "If you have no data for this function, have your delegate return null " + "or undefined (no 'return')";
}

/**
 * Parses a user agent string for a particular product name and returns its version
 * @param {String} userAgent that conforms with RFC 7231 section 5.5.3 regarding User-Agents
 * @param {String} (optional) productName the name of a product identifier to search for e.g. 'iTunes'; if omitted, defaults to the first identifier
 * @return {String} the version of the product, or null if none found
 * @example
 *      versionStringFromUserAgent('iTunes/12.6 (Macintosh; OS X 10.12.4) AppleWebKit/603.1.30.0.34') returns '12.6'
 *      versionStringFromUserAgent('iTunes/12.6 (Macintosh; OS X 10.12.4) AppleWebKit/603.1.30.0.34', 'AppleWebKit') returns '603.1.30.0.34'
 *      versionStringFromUserAgent('iTunes/12.6 (Macintosh; OS X 10.12.4) AppleWebKit/603.1.30.0.34', 'Macintosh') returns null
 *          (strings contained in parentheses are counted as comments, not product identifiers)
 */
function versionStringFromUserAgent(userAgent, productName) {
    var returnValue = null;

    productName = productName || '\\S+'; // default to the first product name

    var re = new RegExp('\\b' + productName + '/(\\S+)\\b', 'i');
    var match = re.exec(userAgent);

    if (match && match[1]) {
        returnValue = match[1];
    }

    return returnValue;
}

/**
 * Takes a client ID (universally unique per device) and generates another UUID that is unique per request
 * TODO: have a fallback in case clientId is unavailable
 * @param {string} clientId, a base-61 UUID that uses 'z' as a delimiter
 * @return {string} A generated UUID, to be used in visit stitching
 */
function requestId(clientId) {
    // NOTE: The reason we integrate "clientId" into this requestId (uuid) is because there is no itms.crypto functionality in ITMLKit for creating robust UUIDs, so we
    //      leverage off the fact that "clientId" was created cryptographically strong in Java.
    var delimiter = 'z';
    var epochTime = Date.now();
    var randomNum = Math.floor(Math.random() * 100000);

    // convert to base 36, and use uppercase since 'z' is a delimiter in clientId
    epochTime = epochTime.toString(36).toUpperCase();
    randomNum = randomNum.toString(36).toUpperCase();

    return clientId + delimiter + epochTime + delimiter + randomNum;
}

/**
 * Generates a RFC4122-compliant UUID (v4)
 * See https://tools.ietf.org/html/rfc4122
 * For a discussion on the probability of collisions of version 4 UUIDs, see:
 *      https://en.wikipedia.org/wiki/Universally_unique_identifier#Collisions
 * @param {Function} (optional) pseudoRNG a function that returns a pseudo random number between 0 and 1
 *      defaults to a cryptographically strong PRNG when available or Math.random()
 *      which is not cryptographically strong, but can be used where a small number of collisions are acceptable
 * @return {String}
 * TODO: consider optimizing to use fewer calls to randomHexCharacter (i.e. switch to a randomHexString method)
 */
function uuid(pseudoRNG) {
    var template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    var uuid = '';
    var character;

    for (var i = 0, len = template.length; i < len; i++) {
        character = template.charAt(i);

        if (character === 'x') {
            uuid += randomHexCharacter(pseudoRNG);
        } else if (character === 'y') {
            uuid += randomHexCharacter(pseudoRNG, '8', 'b');
        } else {
            uuid += character;
        }
    }

    return uuid;
}

/**
 * Generates a random hexdecimal character between 0 and f
 * @param {Function} (optional) a pseudo random number generator that returns a value between 0 and 1
 *      defaults to a cryptographically strong PRNG when available or Math.random()
 *      which is not cryptographically strong, but can be used where a small number of collisions are acceptable
 * @param {String} (optional) min the lowest character (0-f) to include, inclusive
 * @param {String} (optional) max the highest character (0-f) to include, inclusive
 * @return {String}
 */
function randomHexCharacter(pseudoRNG, min, max) {
    var cryptoObject = global.crypto || global.msCrypto;
    var randomCharacter;

    if (pseudoRNG) {
        randomCharacter = (pseudoRNG() * 16 | 0).toString(16);
    } else if (cryptoObject && cryptoObject.getRandomValues) {
        randomCharacter = (cryptoObject.getRandomValues(new Uint8Array(1))[0] & 15).toString(16);
    } else if (cryptoObject && cryptoObject.randomBytes) {
        randomCharacter = cryptoObject.randomBytes(1).toString('hex')[0];
    } else {
        randomCharacter = (Math.random() * 16 | 0).toString(16);
    }

    // rejection sampling: if character not in desired range, generate another one
    if (min && max && (randomCharacter < min || randomCharacter > max)) {
        randomCharacter = randomHexCharacter(pseudoRNG, min, max);
    }

    return randomCharacter;
}

/**
 * Adapted from MTStringUtil.java, which copied from MZStringUtil.java.
 * Base-2 to base-62 target alphabets are accepted.
 * Alphabet order must be 0-9, then "A" stands for 10, "Z" for 35, "a" (lower-case) for 36 and "z" (lower-case) for 61.
 * Not sure if there is any standard for displaying numbers higher than base-36. Lowercase letters are used to go up
 * to base-62.
 *
 * @param {Number} number a POSITIVE base 10 number to convert
 * @param {String} targetAlphabet indicates the base of the target value (by virtue of the length of the alphabet)
 *                                as well as the characters to use during conversion. "Canned" alphabets are provided,
 *                                but homegrown alphabets may be used by truncating values from canned alphabets.
 * @return {String} a string that has been converted to targetAlphabet
 */
function convertNumberToBaseAlphabet(number, targetAlphabet) {
    var returnValue = '';
    var targetRadix = targetAlphabet.length;

    if (targetRadix <= 36) {
        returnValue = number.toString(targetRadix).toUpperCase();
    } else {
        var remainder;
        var charForRemainder;
        var charArray = [];

        while (number > 0) {
            remainder = number % targetRadix;
            charForRemainder = targetAlphabet.charAt(remainder);
            charArray.push(charForRemainder);
            number = (number - remainder) / targetRadix;
        }

        returnValue = charArray.reverse().join('');
    }

    if (returnValue === '') {
        returnValue = '0';
    }

    return returnValue;
}

/**
 * Generates a random base62 string. If strong crypto is available, this will try to use it first.
 * See https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues#Browser_compatibility
 * for availability.
 * @param {Boolean} hasPrefix - optional parameter specifying whether to add version/crypto indicator prefix to the string.
 * @return {string} A random 24 character base62 random string if successful, or null if no strong crypto is available.
 */
function cryptoRandomBase62String(hasPrefix) {
    var base62String;
    // Test to make sure unsigned numbers with full 32 bits are supported
    if (Math.floor(0xFFFFFFFF / 0x100) == 0xFFFFFF) {
        var cryptoObject = global.crypto || global.msCrypto;
        var arr;
        var i;
        var j;
        var num;
        var isCrypto;

        // UUID has 16 bytes
        if (cryptoObject && cryptoObject.getRandomValues) {
            arr = cryptoObject.getRandomValues(new Uint32Array(16 / Uint32Array.BYTES_PER_ELEMENT));
            isCrypto = true;
        } else if (cryptoObject && cryptoObject.randomBytes) {
            var b = cryptoObject.randomBytes(16);
            arr = new Uint32Array(b.buffer, b.byteOffset, b.byteLength / Uint32Array.BYTES_PER_ELEMENT);
            isCrypto = true;
        } else {
            arr = new Uint32Array(16 / Uint32Array.BYTES_PER_ELEMENT);
            for (i = 0; i < arr.length; i++) {
                arr[i] = Math.floor(Math.random() * Math.floor(0xFFFFFFFF));
            }
        }

        if (arr) {
            base62String = "";
            for (i = 0; i < arr.length; i++) {
                num = arr[i];
                for (j = 0; j < 6; j++) {
                    // 4-byte block encoded to 6 byte base62
                    base62String += base62Alphabet[num % 62];
                    num = Math.floor(num / 62);
                }
            }
            if (hasPrefix) {
                // 1st char: version (currently 1)
                // 2nd char: separator _
                // 3rd char: encryption type, 0 = unknown, 1 = yes, 2 = no
                // 4th char: separator _
                base62String = "1_" + (isCrypto ? "1" : "2") + "_" + base62String;
            }
        }
    }
    return base62String;
}

var string$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base10Alphabet: base10Alphabet,
    base16Alphabet: base16Alphabet,
    base36Alphabet: base36Alphabet,
    base61Alphabet: base61Alphabet,
    base62Alphabet: base62Alphabet,
    startsWith: startsWith,
    endsWith: endsWith,
    trim: trim,
    snakeCaseToCamelCase: snakeCaseToCamelCase,
    snakeCaseToUpperCamelCase: snakeCaseToUpperCamelCase,
    exceptionString: exceptionString$1,
    paramString: paramString,
    versionStringFromUserAgent: versionStringFromUserAgent,
    requestId: requestId,
    uuid: uuid,
    randomHexCharacter: randomHexCharacter,
    convertNumberToBaseAlphabet: convertNumberToBaseAlphabet,
    cryptoRandomBase62String: cryptoRandomBase62String
});

/*
 *  src/cookies.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 *
 * Cookie related util methods
 * @constructor
 *
 * Packaging note: tree-shaking does not remove unused functions from this class object
 * It might be more efficient to separate the cookie delegate from the utility functions
 */
var cookies = {
    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */

    /**
     * Allows replacement of one or more of this class' functions
     * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
     * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
     * Your delegate can be a true object instance, an anonymous object, or a class object.
     * Your delegate is free to have as many additional non-matching methods as it likes.
     * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
     *
     * NOTE: when the delegate function is called, it will include an additional final parameter representing the original function that it replaced.
     * This allows the delegate to, essentially, call "super" before or after it does some work.
     * @example:
     * To override one or more methods, in place:
     *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
     * To override one or more methods with a separate object:
     *      eventRecorder.setDelegate(eventRecorderDelegate);
     *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
     *                                       sendMethod: 'itms'};
     * To override one or more methods with an instantiated object from a class definition:
     *      eventRecorder.setDelegate(new EventRecorderDelegate());
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
     *                                                          return 'itms';
     *                                                      };
     * To override one or more methods with a class object (with "static" methods):
     *      eventRecorder.setDelegate(EventRecorderDelegate);
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.sendMethod = function sendMethod() {
     *                                                return 'itms';
     *                                            };
     * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
     * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
     * otherwise returns false.
     */
    setDelegate: function setDelegate(delegate) {
        return attachDelegate(this, delegate);
    },

    /**
     * The cookie string, e.g. "iTunes.cookie" (iTunes desktop), "iTunes.cookieForDefaultURL" (HTML iOS), "itms.cookie" (itml app), "document.cookie" (browser)
     * NOTE: Callers should override this method if they want to supply a different cookie.
     * @overridable
     */
    cookie: function cookie() {
        var cookieOwnerObject;

        if (typeof window !== 'undefined' && 'iTunes' in window && 'cookie' in iTunes) {
            cookieOwnerObject = iTunes;
        } else if (typeof itms !== 'undefined' && isDefined(itms.cookie)) {
            cookieOwnerObject = itms;
        } else if (typeof document !== 'undefined') {
            cookieOwnerObject = document;
        } else {
            throw "cookies.cookie: No cookie object available";
        }

        return cookieOwnerObject.cookie;
    },

    // NOTE: MetricsKit does not currently need to set cookies, so setting functions are commented out until they are needed
    /**
     * Normal/Primary cookie setter method.
     * Invokes JavaScript's "escape()" function on "cookieValue" before passing to "cookies.setUnescaped()"
     *
     * Set cookie with the given name and value at the path "/"
     * @param cookieName the name of the cookie; must not contain whitespace or semicolons.
     * @param cookieValue must not contain semicolons or whitespace.  Use escape() if necessary
     * @param lifespanInSeconds may be one of: 1. the time-to-live in seconds, 2. null to expire at browser (session) termination, 3. negative to delete a cookie
     * @param path the path to use (optional,if null,  defaults to "/")
     * @param domain the domain to use (if null, defaults to the current domain)
     */
    // this.set = function set(cookieName, cookieValue, lifespanInSeconds, path, domain) { };

    /**
     * "Normal Use" cookie getter method.
     * Invokes JavaScript's "unescape()" function on value returned from "cookies.getUnescaped()" and returns that unescaped value.
     */
    get: function get$$1(cookieName) {
        // NOTE: IF YOU MODIFY THIS METHOD, COPY AND TEST THE MODIFICATION TO itmsCheck.js WHICH HAS A COPY/PASTED VERSION (SANS COMMENTS)
        var returnValue = this.getUnescaped(cookieName);
        if (returnValue) returnValue = unescape(returnValue);
        return returnValue;
    },

    // NOTE, The jingle "setUnescaped" method has a lot of special-case code both for devices and ITML.
    // That is important functionality for setting cookies on those platforms but we don't currently need to set cookies (we used to do it as a device workaround in iOS6) and
    // to include it here, we would need to create platform-specific delegates, so let's save all that mess for the day we actually need this functionality at
    // which point you SHOULD grab and adapt the code from Jingle:
    setUnescaped: function setUnescaped(cookieName, cookieValue, lifespanInSeconds, path, domain) {},

    /**
     * Funnel-point cookie-getting method.
     * Parsing document.cookie is simple, but there are a lot of quirks.
     *
     * The simple format is "a=b; c=d;", but according to RFC 2965 (from 2006, but only Opera supports it),
     * any amount of whitespace (including none) is optional as a separator.
     * NOTE:KBERN: We trim whitespace from the beginning and end of both keys and values based on my reading of:
     *     http://tools.ietf.org/html/rfc2965
     * on page 3 it says,
     *     "NOTE: The syntax above allows whitespace between the attribute and the = sign.", and so even though
     *     Meaning that a) there does have to be an "=" sign, and b) there can be whitespace on both sides of it.
     *     Safari seems to collapse whitespace around the "=", but there is no guarantee that all browsers will
     *     behave that way on all platforms, therefore I think that both the keys and values need to be trimmed of
     *     both leading and trailing spaces.
     *
     * According to the most widely supported spec (the 1995 Netscape cookie draft doc), the name-value pairs are
     * "a sequence of characters excluding semi-colon, comma and white space".  This means the value can contain
     * the equals sign, and any other number of weird characters!
     *
     * In short, don't mess with this function.
     *
     * <rdar://problem/8123192> Javascript cookie parsing is chopping off trailing = signs
     */
    getUnescaped: function getUnescaped(cookieName) {
        var result = null;

        // NOTE: IF YOU MODIFY THIS METHOD, COPY AND TEST THE MODIFICATION TO itmsCheck.js WHICH HAS A COPY/PASTED VERSION (SANS COMMENTS)
        var cookieString = this._getRaw();
        if (cookieString && cookieName) {
            var splitCookies = cookieString.split(';');

            // GO THROUGH THE COOKIES BACKWARDS BECAUSE...
            // (This comment, and searching from back->front is from Dojo: http://www.bedework.org/trac/bedework/browser/trunk/deployment/resources/javascript/dojo-0.4.1-ajax/src/io/cookie.js?rev=1164
            //  I haven't tried to reproduce this, but it's no skin off our backs to go backwards anyway, so...)
            // Which cookie should we return?
            // If there are cookies set for different sub domains in the current
            // scope there could be more than one cookie with the same name.
            // I think taking the last one in the list takes the one from the
            // deepest subdomain, which is what we're doing here.
            for (var i = splitCookies.length - 1; !result && i >= 0; i--) {
                var aCookie = splitCookies[i];
                var separatorIndex = aCookie.indexOf("=");

                if (separatorIndex > 0) {
                    if (separatorIndex + 1 == aCookie.length) {
                        result = ""; // there *is* a cookie key, but there is nothing to the right of the "="
                    } else {
                        // Trim all leading and trailing whitespace from key...
                        var cookieKey = trim(aCookie.substring(0, separatorIndex));

                        if (cookieKey == cookieName) {
                            // Trim all leading and trailing whitespace from the value as well, since there may be whitespace to the right of the "=" sign
                            result = trim(aCookie.substring(separatorIndex + 1));
                        }
                    }
                }
            }
        }
        return result;
    },

    /**
     * adding a cover accessor to document.cookie so that in iOS 4.2 and newer we can use iTunes.cookies instead (allows access to private storage)
     */

    /**
     * Clear a cookie (expire/delete/remove it)
     * @param {Object} cookieName
     */
    remove: function remove(cookieName, domain) {
        return this.setUnescaped(cookieName, ".", this.EXPIRE_NOW, null, domain);
    },

    // PRIVATE METHODS:

    // NOTE: MetricsKit does not currently need to set cookies, so setting functions are commented out until they are needed
    /**
     * @param val the raw Cookie string (Webkit), or a Cookie dict (ITML) to be set.
     */
    // this._setRaw = function _setRaw(val) { };

    /**
     * @returns all Cookies as a string.
     */
    _getRaw: function _getRaw() {
        return this.cookie() || "";
    }
};

// CONSTANTS:
// Convenient lifespanInSeconds values:
cookies.EXPIRE_NOW = -1;
cookies.EXPIRE_SESSION = null; // or "0"
cookies.EXPIRE_ONE_SECOND = 1;
cookies.EXPIRE_ONE_MINUTE = cookies.EXPIRE_ONE_SECOND * 60;
cookies.EXPIRE_ONE_HOUR = cookies.EXPIRE_ONE_MINUTE * 60;
cookies.EXPIRE_ONE_DAY = cookies.EXPIRE_ONE_HOUR * 24;
cookies.EXPIRE_ONE_WEEK = cookies.EXPIRE_ONE_DAY * 7;
cookies.EXPIRE_ONE_MONTH = cookies.EXPIRE_ONE_DAY * 31;
cookies.EXPIRE_ONE_YEAR = cookies.EXPIRE_ONE_DAY * 365;
cookies.EXPIRE_ONE_SIDEREAL_YEAR = cookies.EXPIRE_ONE_DAY * 365.25; // (31556926279 or so)... For those who want decades long accuracy :-( ... of course we could also make special day times since a day is really 24 hours and 2 milliseconds long :-)
cookies.EXPIRE_SIX_MONTHS = cookies.EXPIRE_ONE_DAY * 180; // <rdar://problem/11067278> Cookies: reduce max age to 6 months

/*
 *  src/utils/delegates_info.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2016 Apple Inc. All rights reserved.
 *
 */

/**
 * Used to store information
 * about attached delegates as a tree,
 * in which delegates may contain their own
 * list of "child" delegates as an array
 * @type {Object}
 * @example
 * // If metricsKit.attachDelegate(delegatesITML)
 *  delegatesMap = {
        '@amp/mt-metricskit5.1.0': {
            name: '@amp/mt-metricskit',
            version: '5.1.0'
            // The accessor delegatesMap[...] would not run correctly if initialized
            // at the same time as this object, but since it's added after delegatesMap
            // is created, it works
            delegates: [delegatesMap['@amp/mt-metricskit-delegates-itml3.1.2']]
            // The above array contains a pointer to another object in delegatesMap
        }
        '@amp/mt-metricskit-delegates-itml3.1.2': {
            name: '@amp/mt-metricskit-delegates-itml',
            version: '3.1.2'
        }
    }
 */
var delegatesMap = {};

/*
 * Used to keep a record of which delegates have been added to which targets
 * for use with deduping the child 'delegates' field of a delegate object
 * (The reason for using this object instead of adding it to the delegatesMap
 * or changing the delegates subfield in delegatesMap to be an object
 * is that delegatesMap represents the value of the mt-metricskit base field
 * xpDelegatesInfo, which requires a certain format.
 * This map is a theoretical extension of delegatesMap, to facilitate constant
 * time lookup for use with deduping.)
 * @type {Object}
 * @example
 * After mt-metricskit adds delegates-itml and delegates-html as delegates
 * and delegates-itml has added base-events as a delegate
 * {
 *    'mt-metricskit2.1.1': ['mt-metricskit-delegates-itml3.1.5', 'mt-metricskit-delegates-html0.1.3'],
 *    'mt-metrickit-delegates-itml3.1.5': ['mt-metricskit-base-events1.1.2']
 * }
 */
var dedupingMap = {};

/**
 * @param {Object} delegate The object to retrieve name & version info off of
 * @param {function} delegate.mtName Returns the name of the delegate as a string
 * @param {function} delegate.mtVersion Returns the version of the delegate as a string
 * @returns {Object} Contains the passed-in delegate's info, esp. name & version
 */
var createDelegateInfoObject = function createDelegateInfoObject(delegate) {
    var delegateInfo = {};

    if (typeof delegate.mtName === 'function' && typeof delegate.mtVersion === 'function') {
        // Add delegate name, version, and any previously-attached "child" delegates to delegatesInfoList
        delegateInfo.name = delegate.mtName();
        delegateInfo.version = delegate.mtVersion();
    }

    return delegateInfo;
};

/**
 * Returns a concatted string of the passed-in delegate's
 * name and version, to be used when storing the delegate in delegatesMap
 * @param {Object} delegate Delegate to create key string from
 * @param {function} delegate.mtName Returns the name of the delegate as a string
 * @param {function} delegate.mtVersion Returns the version of the delegate as a string
 * @returns {String} The concatted name and version of the passed-in delegate
 * @example
 * "mt-metricskit-delegates-itml3.1.2"
 */
var createDelegateKey = function createDelegateKey(delegate) {
    var delegateKey;
    if (typeof delegate.mtName === 'function' && typeof delegate.mtVersion === 'function') {
        delegateKey = delegate.mtName() + delegate.mtVersion();
    }
    return delegateKey;
};

/**
 * Creates delegate info objects for passed-in target object and delegate object,
 * and stores them in the delegatesMap. The info object of the delegate being attached
 * to the target will be stored in the target's info object's 'delegates' field
 * @param {Object} target The object being partially or wholly overwritten by the delegate
 * @param {Object} delegate The object overwriting the target object's functionality
 * @param {function} target.mtName Returns the name of the target as a string
 * @param {function} target.mtVersion Returns the version of the target as a string
 * @param {function} delegate.mtName Returns the name of the delegate as a string
 * @param {function} delegate.mtVersion Returns the version of the delegate as a string
 */
function storeDelegateInfo(target, delegate) {
    var targetKey = createDelegateKey(target);
    var delegateKey = createDelegateKey(delegate);
    if (targetKey && delegateKey) {
        // Create delegate info objects (containing delegate's name & version)
        // and add to delegatesMap
        if (!delegatesMap[delegateKey]) {
            delegatesMap[delegateKey] = createDelegateInfoObject(delegate);
        }
        if (!delegatesMap[targetKey]) {
            delegatesMap[targetKey] = createDelegateInfoObject(target);
            dedupingMap[targetKey] = {};
        }
        // Add delegate's info object to target's delegates array in delegatesMap
        if (delegatesMap[targetKey].delegates) {
            if (!dedupingMap[targetKey][delegateKey]) {
                delegatesMap[targetKey].delegates.push(delegatesMap[delegateKey]);
            }
        } else {
            delegatesMap[targetKey].delegates = [delegatesMap[delegateKey]];
        }
        dedupingMap[targetKey][delegateKey] = true;
    }
}

/**
 * Return the delegate object stored in delegatesMap
 * for the passed-in delegate
 * @returns {Object} The stored delegate object for the passed-in delegate
 */
function getStoredDelegateObject(delegate) {
    return delegatesMap[createDelegateKey(delegate)];
}

var delegates_info = /*#__PURE__*/Object.freeze({
    __proto__: null,
    storeDelegateInfo: storeDelegateInfo,
    getStoredDelegateObject: getStoredDelegateObject
});

/*
 *  src/key_value.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 * Takes a SINGLE searchSource and string representation of an object path (a namespace) and returns the object at that subpath (possibly after first creating it)
 * If the objects in the path do not already exist off of searchSource and "createIfNeeded" is true, this method will create all the JavaScript objects required to make it a valid object path
 * If any component already exists, it will be maintained. New components are created as "{}"
 * e.g. after this call:
 *      keyValue.valueForKeyPath(rootObject, 'foo.bar.Tot')
 * there will always be a valid JavaScript object of:
 *      rootObject.foo.bar.Tot
 * @param searchSource a key/value object
 * @param keyPath a simple property key name, e.g. "foo", or a nested property key name "path", e.g. foo.bar.tot
 * @return the discovered and/or created object at the specified path hanging off the specified searchSources
 *         If "createIfNeeded" is not specified, and keyPath or searchSources are not both valid, "undefined" will be returned (since "null" could be a valid return value stored at some keyPath)
 *         If the goal of the caller is simply to create the object path and "createIfNeeded" has been specified, the return value may be ignored.
 * @example valueForKeyPath("foo", {"bar":10, "foo":12}); returns "12"
 */
function _valueForKeyPath(keyPath, searchSource, createIfNeeded) {
    var tailObject = searchSource;

    if (keyPath && searchSource) {
        var objectStrings = keyPath.split('.');

        for (var ii = 0; tailObject && ii < objectStrings.length; ii++) {
            var anObjectString = objectStrings[ii];
            if (!(anObjectString in tailObject) && createIfNeeded) {
                tailObject[anObjectString] = {};
            }
            if (anObjectString in tailObject) {
                tailObject = tailObject[anObjectString];
            } else {
                tailObject = null;
            }
        }
    }
    return tailObject;
}

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Takes one or more searchSources and string representation of an object path (a namespace) and returns the object at that subpath
 * @param {String} keyPath a simple property key name, e.g. "foo", or a nested property key name "path", e.g. foo.bar.tot
 * @param {varargs} searchSources at least one key/value object(s), or array(s) of key/value objects, or list(s) of key/value objects.
 * Later sets of key/value pairs overwrite earlier sets.
 * Callers are not asked to pass a unified (coalesced) set of key/value objects because that is a much more expensive operation
 * to preform each time we are searching for a keyPath.
 * @return the discovered object at the specified path hanging off the specified searchSources. Later sets of key/value pairs overwrite earlier sets.
 * @example valueForKeyPath("foo", {"bar":10, "foo":12}); returns "12"
 * @example valueForKeyPath("foo.cat", [{"bar":10, "foo":12}, {"bar":10, "foo":{"cat":"meow", "dog":"ruff"}}]); returns "meow"
 * @example valueForKeyPath("foo.cat", {"bar":10, "foo":12}, {"bar":10, "foo":{"cat":"meow", "dog":"ruff"}}); returns "meow"
 */
function valueForKeyPath(keyPath /*, searchSources<varargs>*/) {
    var returnValue = null;

    if (keyPath && arguments.length > 1) {
        // Pass in all sources after the first ("keyPath"). We do this even if there's only one param, in case that one param is an object instead of an array
        var normalizedSearchSources = sourcesArray(Array.prototype.slice.call(arguments, 1));

        // Now we just loop through our normalizedSearchSources looking for "keyPath" in any of them.
        // We start at the end and look backwards, because the later sources take precedence over earlier ones.
        for (var ii = normalizedSearchSources.length - 1; ii >= 0; ii--) {
            var aSearchSource = normalizedSearchSources[ii];

            returnValue = _valueForKeyPath(keyPath, aSearchSource);
            if (isDefinedNonNull(returnValue)) {
                break;
            }
        }
    }
    return returnValue;
}

/**
 * If the objects in the path do not already exist off of searchSource, this method will create all the JavaScript objects required to make it a valid object path
 * If any component already exists, it will be maintained. New components are created as "{}"
 * e.g. after this call:
 *      keyValue.createObjectAtKeyPath(rootObject, 'foo.bar.Tot')
 * there will always be a valid JavaScript object of:
 *      rootObject.foo.bar.Tot
 * @param searchSource a key/value object
 * @param keyPath a simple property key name, e.g. "foo", or a nested property key name "path", e.g. foo.bar.tot
 * @return the created object at the specified path hanging off the specified searchSources
 *         If the goal of the caller is simply to create the object path and "createIfNeeded" has been specified, the return value may be ignored.
 */
function createObjectAtKeyPath(keyPath, searchSource) {
    return _valueForKeyPath(keyPath, searchSource, true);
}

/**
 * Expands the sources param, and any varargs that might follow it and puts them all into an array.
 * Items within "sources" or varargs can, themselves, be arrays, in which case they will be decomposed and their items added to the top level of the returned array.
 * @example sourcesArray("foo", {"bar":10, "foo":12}); returns ["foo", {"bar":10, "foo":12}]
 * @example sourcesArray("foo.cat", [{"bar":10, "foo":12}, {"bar":10, "foo":{"cat":"meow", "dog":"ruff"}}]); returns ["foo.cat", {"bar":10, "foo":12}, {"bar":10, "foo":{"cat":"meow", "dog":"ruff"}}]
 * @example sourcesArray("foo.cat", {"bar":10, "foo":12}, {"bar":10, "foo":{"cat":"meow", "dog":"ruff"}}); returns ["foo.cat", {"bar":10, "foo":12}, {"bar":10, "foo":{"cat":"meow", "dog":"ruff"}}]
 * @param sources an object, an array of objects, an array of objects where some objects are themselves arrays
 * @param varargs additional objects to be added to the returned array.
 * @returns {Array}
 */
function sourcesArray(sources /*, varargs*/) {
    var returnValue = [];
    var arrayifiedSources = [];

    // This will add in the individual searchSources whether they are in a single object or an array...
    arrayifiedSources = arrayifiedSources.concat(sources);
    // This will add in anything that "arguments" had as varargs...
    if (arguments && arguments.length > 1) {
        arrayifiedSources = arrayifiedSources.concat(Array.prototype.slice.call(arguments, 1));
    }

    // If any of the items in "sources" is already an array, this loop will expand it and add each element as an individual source.
    // We only do this one level deep (i.e. we don't look to see if there are arrays within arrays in this list).
    for (var ii = 0; ii < arrayifiedSources.length; ii++) {
        var arrayItem = arrayifiedSources[ii];
        returnValue = returnValue.concat(arrayItem);
    }

    return returnValue;
}

var key_value = /*#__PURE__*/Object.freeze({
    __proto__: null,
    valueForKeyPath: valueForKeyPath,
    createObjectAtKeyPath: createObjectAtKeyPath,
    sourcesArray: sourcesArray
});

/*
 *  src/metrics/utils/event_fields.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Takes one or more eventFields objects, cleans them (removes keys that are typeof 'function', keys with 'null' values, keys with 'undefined' values),
 * merges them (later objects take precedence), and returns a single object with the union of all remaining fields.
 * Passed in objects are treated as immutable and so will never be modified.
 * @param eventFields an object with keys and values OR an array of objects with keys and values.
 * If only one parameter is provided, the return value will be the non-null values of that single object.
 * @param varargs additional objects to be merged in, similar to eventFields (i.e. dictionaries, arrays of dictionaries, or some combination of the two).
 * Later objects take precedence over earlier ones.
 * @return a new object with the union of all non-function, non-null and non-undefined fields.
 * Passed in objects are treated as immutable and so will never be modified.
 * @example mergeAndCleanEventFields({}) ===> {}
 * @example mergeAndCleanEventFields(null) ===> {}
 * @example mergeAndCleanEventFields({"foo":10}) ===> {"foo":10}
 * @example mergeAndCleanEventFields({"foo":10, "bar":null}) ===> {"foo":10}
 * @example mergeAndCleanEventFields({"foo":10, "bar":null}, {"cat":null}) ===> {"foo":10}
 * @example mergeAndCleanEventFields({"foo":10, "bar":null}, {"cat":null, "mouse":"gray"}) ===> {"foo":10, "mouse":"gray"}
 * @example mergeAndCleanEventFields({"foo":10, "bar":null}, {"cat":null, "mouse":"gray", "dog":"bark"}) ===> {"foo":10, "mouse":"gray", "dog":"bark"}
 * @example mergeAndCleanEventFields({"foo":10, "bar":null}, {"cat":null, "mouse":"gray", "dog":"bark", "foo":11}) ===> {"foo":11, "mouse":"gray", "dog":"bark"}
 * @example mergeAndCleanEventFields({"foo":10, "bar":null}, {"cat":null, "mouse":"gray", "dog":"bark", "foo":11}, {"foo":12}) ===> {"foo":12, "mouse":"gray", "dog":"bark"}
 */
function mergeAndCleanEventFields(eventFields /*, varargs*/) {
    var argumentsArray = [false, false, false].concat(Array.prototype.slice.call(arguments));
    // expand argumentsArray, in case it contains arrays)
    var expandedArgumentsArray = [];

    for (var ii = 0; ii < argumentsArray.length; ii++) {
        var itemToPush = argumentsArray[ii];
        // Either push each item in this item...
        if (itemToPush && itemToPush.constructor === Array) {
            for (var jj = 0; jj < itemToPush.length; jj++) {
                expandedArgumentsArray.push(itemToPush[jj]);
            }
            // or push the item itself (if it is not an array)
        } else {
            expandedArgumentsArray.push(itemToPush);
        }
    }
    return copyKeysAndValues.apply(null, expandedArgumentsArray);
}

/**
 * This method is the workhorse of all the various eventHandlers.
 * It will take all of the parameters of the callers "metricsData()" method, merge them together,
 * invoke accessors on their known fields, and return the resultant map.
 * @param eventHandler the calling eventHandler
 * @param knownFields the calling eventHandler's list (array) of strings that are that handler's known field values.
 * If the caller has accessors to be invoked, they must be present in the "knownFields" array
 * @param {Boolean} includeAllKnownFields if false, only known field accessors that match caller provided field names will be invoked.
 * @returns {Arguments} all of the arguments that the calling eventHandler received.
 * @example:
 * Page.prototype.metricsData = function(pageId, pageType, pageContext, eventFieldsMapN(varargs)) {
 *      var pageFields = { pageId: pageId, pageType: pageType, pageContext: pageContext };
 *      return utils.eventFields.processMetricsData(this, this.knownFields(), true, pageFields, eventFieldsMapN); });
 */
function processMetricsData(eventHandler, knownFields, includeAllKnownFields, callerSuppliedEventFieldsMapsArray) {
    var callerProvidedFields = mergeAndCleanEventFields(callerSuppliedEventFieldsMapsArray);
    // Initialize returnValue with the passed-in fields in case there are fields we haven't contemplated or don't have accessor methods for, they will still be included.
    var returnValue = callerProvidedFields;

    if (eventHandler && knownFields) {
        var knownFieldValues = {};

        if (!includeAllKnownFields) {
            // only include known field names that were also included in caller provided maps
            knownFields = knownFields.filter(function (fieldName) {
                return fieldName in callerProvidedFields;
            });
        }
        if (knownFields.length) {
            for (var ii = 0; ii < knownFields.length; ii++) {
                var knownFieldName = knownFields[ii];
                var knownFieldAccessor = eventHandler[knownFieldName];

                if (isFunction(knownFieldAccessor)) {
                    // NOTE: If the accessor method prefers to use a value from the passed-in callerProvidedFields, it must do that on its own.
                    knownFieldValues[knownFieldName] = knownFieldAccessor.call(eventHandler, callerProvidedFields);
                }
            }
        }

        returnValue = mergeAndCleanEventFields(returnValue, knownFieldValues);
    }

    return returnValue;
}

/**
 * Returns an object containing the intersection of properties in
 * data and matching string values in the fieldMap property corresponding to 'sectionName'
 * ( e.g. fieldMap.custom[sectionName] is an object containing arrays of strings which
 * correspond to the keys desired in the mappedFields object )
 * @param {Object} data The model data corresponding to element we're mapping fields for
 * @param {String} sectionName Specifies which section of the fieldMap to use (eg: 'impressions', 'location', or 'custom')
 * @param {Object} fieldsMap contains one or more field mapping(s)
 * @param {Function} (optional) onError callback to be invoked with an error message; e.g. console.error
 * @return {Object} Contains intersection of data and fieldsMap values
 * @example
 * // where impressionFieldsMapSection = {
 * //   impressionType: ['type', 'impressionType'],
 * //   id: ['targetId', 'id']
 * //};
 * applyFieldsMap({type: 'button', id: '123', name: 'playbutton'}, 'impressions')
 * // returns {impressionType: 'button', id: '123'}
 */
function applyFieldsMap(data, sectionName, fieldsMap, onError) {
    var fieldsMapSection;
    var mappedFields;
    var errorMessage;

    if (data && sectionName && fieldsMap) {
        mappedFields = {};
        fieldsMapSection = valueForKeyPath(sectionName, fieldsMap, fieldsMap.custom);
        if (fieldsMapSection) {
            var i;
            var value;
            if (isArray(fieldsMapSection)) {
                for (i = 0; i < fieldsMapSection.length; ++i) {
                    value = data[fieldsMapSection[i]];
                    if (isDefinedNonNull(value)) {
                        mappedFields[fieldsMapSection[i]] = value;
                    }
                }
            } else if (isObject(fieldsMapSection)) {
                for (var key in fieldsMapSection) {
                    for (i = 0; i < fieldsMapSection[key].length; ++i) {
                        value = valueForKeyPath(fieldsMapSection[key][i], data);
                        if (isDefinedNonNull(value)) {
                            mappedFields[key] = value;
                            break;
                        }
                    }
                }
            } else {
                errorMessage = 'metrics: incorrect data type provided to applyFieldsMap (only accepts objects and Arrays)';
            }
        } else {
            errorMessage = 'metrics: unable to get ' + sectionName + ' section from fieldsMap';
        }
    } else {
        var missingArgs = [];

        if (!data) {
            missingArgs.push('data');
        }
        if (!sectionName) {
            missingArgs.push('sectionName');
        }
        if (!fieldsMap) {
            missingArgs.push('fieldsMap');
        }

        errorMessage = 'metrics: missing argument(s): ' + missingArgs.join(',') + ' not provided to applyFieldsMap';
    }

    if (errorMessage && isFunction(onError)) {
        onError(errorMessage);
    }

    return mappedFields;
}

var event_fields = /*#__PURE__*/Object.freeze({
    __proto__: null,
    mergeAndCleanEventFields: mergeAndCleanEventFields,
    processMetricsData: processMetricsData,
    applyFieldsMap: applyFieldsMap
});

/*
 *  src/metrics/utils/network.js
 *  mt-metricskit
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 * Makes an XHR GET request
 * @param {String} url of the request
 * @param {Function} onSuccessHandler function to execute on request success (response returned)
 * @param {Function} onFailureHandler function to execute on request failure (error returned)
 */
function makeAjaxGetRequest(url, onSuccessHandler, onFailureHandler) {
    makeAjaxRequest(url, 'GET', null, onSuccessHandler, onFailureHandler);
}

/**
 * Creates, modifies, and sends an XMLHttpRequest object
 * @param {String} url url of endpoint
 * @param {String} method "GET", "POST", etc.
 * @param {*} data data to send to endpoint if method is "POST", "PUT", etc.
 * @param {Function} [onSuccess] optional function to execute on request success (takes response returned)
 * @param {Function} [onFailure] optional function to execute on request failure (takes error returned and optional status code)
 * @param {Object} [options] optional dictionary of options which define how to modify the XMLHttpRequest
 * @param {boolean} [options.async] optional boolean which determines if the request should be asynchronous
 * @param {Number} [options.timeout] optional which determines request timeout
 * @param {Number} [options.withCredentials] optional which determines request withCredentials
 */
function makeAjaxRequest(url, method, data, onSuccess, onFailure, options) {
    var request = new XMLHttpRequest();
    data = data || undefined;
    options = options || {};
    onSuccess = isFunction(onSuccess) ? onSuccess : function () {};
    onFailure = isFunction(onFailure) ? onFailure : function () {};
    // Sets async to true by default
    var async = options.async === false ? false : true;

    // synchronous requests should not use the timeout property:
    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout
    if (options.timeout && async) {
        request.timeout = options.timeout;
    }

    request.onload = function onload() {
        // Successful response status is defined as 2xx by default
        if (request.status >= 200 && request.status < 300) {
            onSuccess(request.response);
        } else {
            // Pass in optional status code so status logic can be performed on failure
            onFailure(new Error('XHR error: server responded with status ' + request.status + ' ' + request.statusText), request.status);
        }
    };
    request.onerror = function onError() {
        onFailure(new Error('XHR error'));
    };

    request.open(method, url, async);

    // Because of rdar://72864343, we allow callers to optionally specify "withCredentials".
    // The default value is true, which allows CORS requests to have cookies set on response
    // (e.g. we're itunes.apple.com, userxp is xp.apple.com).
    request.withCredentials = typeof options.withCredentials === 'boolean' ? options.withCredentials : true;
    request.setRequestHeader("Content-type", "application/json");

    request.send(data);
}

var network = /*#__PURE__*/Object.freeze({
    __proto__: null,
    makeAjaxGetRequest: makeAjaxGetRequest,
    makeAjaxRequest: makeAjaxRequest
});

/*
 *  src/metrics/utils/sampling.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PRIVATE METHODS/IVARS ************************************
 */
var _sessions = {};

/**
 * Manually clears an active sampling session
 * @param {String} sessionName
 */
var _clearSession = function _clearSession(sessionName) {
    if (_sessions[sessionName]) {
        clearTimeout(_sessions[sessionName]);
        _sessions[sessionName] = null;
    }
};

/**
 ****************************** PSEUDO-PRIVATE METHODS/IVARS **********************************
 * These functions need to be accessible for ease of testing, but should not be used by clients
 */
function _utClearSessions() {
    for (var sessionName in _sessions) {
        _clearSession(sessionName);
    }
}

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * A random lottery that is successful with samplingPercentage frequency
 * @param {Number} samplingPercentage (between 0 and 1)
 * @return {Boolean} whether or not the lottery was successful
 */
function lottery(samplingPercentage) {
    return Math.random() < samplingPercentage;
}

/**
 * Determines whether a particular sampling session is active
 * @param {String} sessionName the name associated with a particular session
 * @param {Number} sessionSamplingPercentage (between 0 and 1)
 * @param {Number} sessionDuration (in ms)
 * @return {Boolean} whether or not the sampling session associated with sessionName is currently active
 */
function sessionSampled(sessionName, sessionSamplingPercentage, sessionDuration) {
    var returnValue;

    // if a timer is currently running, we are sampled in to this session
    if (_sessions[sessionName]) {
        returnValue = true;
    } else {
        // roll the dice
        var sampleNow = lottery(sessionSamplingPercentage);

        // check if we need to enable sampling for sessionDuration ms
        if (sampleNow && sessionDuration > 0) {
            _sessions[sessionName] = setTimeout(_clearSession.bind(null, sessionName), sessionDuration);
        }

        returnValue = sampleNow;
    }

    return returnValue;
}

/**
 * Determines whether an eventType should be sampled.
 * Session sampling (sessionSamplingPercentage and sessionDuration) will be checked first, and samplingPercentage will be used as a fallback.
 * @param {Boolean} (optional) samplingForced whether to always sample in. Default false.
 * @param {Number} (optional) sessionSamplingPercentage (between 0 and 1) the frequency at which to initiate sampling sessions for eventType. Default 0.
 * @param {Number} (optional) sessionDuration the duration, in milliseconds, of sampling sessions for this eventType. Default 0.
 * @param {Number} (optional) samplingPercentage (between 0 and 1) the frequency at which to sample in individual events. Default 0.
 * @example sampling.isSampledIn('pageRender', null, 0.05, 60000);
 * @return {Boolean} whether or not eventType is currently sampled in
 */
function isSampledIn(eventType, samplingForced, sessionSamplingPercentage, sessionDuration, samplingPercentage) {
    return samplingForced || sessionSampled(eventType, sessionSamplingPercentage, sessionDuration) || lottery(samplingPercentage);
}

var sampling = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _utClearSessions: _utClearSessions,
    lottery: lottery,
    sessionSampled: sessionSampled,
    isSampledIn: isSampledIn
});

/*
 *  src/storage.js
 *  mt-metricskit-utils-private
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PRIVATE METHODS/IVARS ************************************
 */

var CONSTANTS = {
    STORAGE_TYPE: {
        LOCAL_STORAGE: 'localStorage',
        SESSION_STORAGE: 'sessionStorage'
    }
};

/**
 * Cover function for sessionStorage/localStorage.
 * Some clients do not have implementations of storage objects, and some are platform-specific (e.g. iTunes.sessionStorage)
 * This helper method will shim storage object functionality as necessary
 * @param {object} storageObject - this is either the platform-specific implementation of session/localStorage, or null if none exists
 * @returns {object} a storage object, either the provided platform-specific one or a dummy/shimmed version
 */
var _storageObject = function _storageObject(storageObject) {
    var aStorageObject = null; // We'll capture this variable as a singleton in the closure below...
    var errorShown = false;

    return function () {
        if (!storageObject) {
            if (!errorShown) {
                console.error("storageObject: storage object not found. Override this function if there is a platform-specific implementation");
                errorShown = true; // only show error the first time
            }
            // Let's not kill the whole app by "throw"ing here, and let's not make all callers be required to check for undefined return values.
            // We'll just create a dummy sessionStorage object which will not hold values across page JS contexts, but at least it will hold them for *some* time...
            if (!aStorageObject) {
                aStorageObject = {
                    storage: {},
                    getItem: function getItem(key) {
                        return this.storage[key];
                    },

                    setItem: function setItem(key, value) {
                        this.storage[key] = value;
                    },

                    removeItem: function removeItem(key) {
                        delete this.storage[key];
                    }
                };
            }
        } else {
            aStorageObject = storageObject;
        }
        return aStorageObject;
    };
};

/**
 * Fetches the given storage object from the global object.  This function wraps around a try-catch to avoid any exception from being thrown
 * in cases where the local storage API is disabled (say for example by disabling cookies in Safari preferences)
 * @param {Object} storageObjectType the storage object type to be evaluated on the window object.  Possible values are localStorage or sessionStorage and are defined in CONSTANTS.STORAGE_TYPE object above.
 * @return {Object} the storage object or null if key doesn't exist in storage or the storage api is disabled
 */
function _defaultStorageObject(storageObjectType) {
    var storageObject = null;
    var storageObjectClass = null;
    var isLocalStorageObjectType = storageObjectType === CONSTANTS.STORAGE_TYPE.LOCAL_STORAGE;
    try {
        storageObjectClass = isLocalStorageObjectType ? typeof localStorage === "undefined" ? "undefined" : _typeof(localStorage) : typeof sessionStorage === "undefined" ? "undefined" : _typeof(sessionStorage);
        if (storageObjectClass !== 'undefined') {
            storageObject = isLocalStorageObjectType ? localStorage : sessionStorage;
        } else {
            storageObject = null;
        }
    } catch (e) {
        // We allow the current process to run without interruption instead of bringing the app down
        storageObject = null;
        console.error("_utils.storage._defaultStorageObject: Unable to retrieve storage object: " + e);
    }
    return storageObject;
}

/**
 ************************************ PSEUDO-PRIVATE METHODS/IVARS ************************************
 * These functions need to be accessible for ease of testing, but should not be used by clients
 */
function _utDefaultStorageObject(storageObjectType) {
    return _defaultStorageObject(storageObjectType);
}

/**
 **************************** PUBLIC METHODS/IVARS ****************************
 */
var localStorageObject = _storageObject(_defaultStorageObject(CONSTANTS.STORAGE_TYPE.LOCAL_STORAGE));
var sessionStorageObject = _storageObject(_defaultStorageObject(CONSTANTS.STORAGE_TYPE.SESSION_STORAGE));

/**
 * Stringifies an object and saves it to storage
 * @param {Object} storageObject an object that adheres to the Web Storage API
 * @param {String} key
 * @param {Object} (optional) objectToSave the object to stringify and save; if null, key will be removed from storageObject
 * @return {Object} the object that was saved to storage or null if nothing was saved (if removing an item, returns undefined)
 */
function saveObjectToStorage(storageObject, key, objectToSave) {
    var result = null;

    if (objectToSave) {
        // setItem may throw errors if storage is full, or stringify could error
        try {
            storageObject.setItem(key, JSON.stringify(objectToSave));
            result = objectToSave;
        } catch (e) {}
    } else {
        result = storageObject.removeItem(key);
    }

    return result;
}

/**
 * Fetches an object stored as a serialized JSON string and unpacks it
 * @param {Object} storageObject an object that adheres to the Web Storage API
 * @param {String} key
 * @return {Object} the object from storage or null if key doesn't exist in storage (returns undefined if stored value failed to parse)
 */
function objectFromStorage(storageObject, key) {
    var result = null;
    var serializedObject = storageObject.getItem(key);

    if (serializedObject) {
        try {
            result = JSON.parse(serializedObject);
        } catch (e) {
            result = undefined;
        }
    }

    return result;
}

var storage = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _utDefaultStorageObject: _utDefaultStorageObject,
    localStorageObject: localStorageObject,
    sessionStorageObject: sessionStorageObject,
    saveObjectToStorage: saveObjectToStorage,
    objectFromStorage: objectFromStorage
});

/*
 *  src/utils.js
 *  mt-client-logger-core
 *
 *  Copyright © 2016-2017 Apple Inc. All rights reserved.
 *
 */

var utils = {
    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */

    /** Special flag classes that can be passed as arguments to logger methods in order to dictate logging behavior
     *  Use class instances to guarantee that flag arguments are unique, and use constructor names for O(1) lookup */
    flagArguments: {
        /**
         * When logging, if any of the arguments is an instance of this class, the log output will include a call stack trace.
         * @example usage: logger.warn('danger!', logger.INCLUDE_CALL_STACK);
         */
        INCLUDE_CALL_STACK: new function INCLUDE_CALL_STACK() {}(),
        /**
         * When logging, if any of the arguments is an instance of this class, the remaining arguments will be mirrored to the logging server
         * @example usage: logger.info('some message', logger.MIRROR_TO_SERVER);
         */
        MIRROR_TO_SERVER: new function MIRROR_TO_SERVER() {}(),
        /**
         * When logging, if any of the arguments is an instance of this class, the client (console) output will be suppressed
         * This would typically be used when callers want to log an event to the server without printing it
         * @example usage: logger.debug(someDiagnosticsInfoObject, logger.MIRROR_TO_SERVER, logger.SUPPRESS_CLIENT_OUTPUT);
         */
        SUPPRESS_CLIENT_OUTPUT: new function SUPPRESS_CLIENT_OUTPUT() {}()
    },

    /**
     * Allows replacement of one or more of this class' functions
     * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
     * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
     * Your delegate can be a true object instance, an anonymous object, or a class object.
     * Your delegate is free to have as many additional non-matching methods as it likes (these methods will not be copied to the target object).
     * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
     *
     * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
     * This allows callers to replace some number of methods that need custom implementations.
     * If, for example, a client wants to use the standard logger implementation with the exception of, say, the "debug" method, they can
     * call "setDelegate()" with their own delegate containing only a single method of "debug" as the delegate, which would leave all the other methods intact.
     *
     * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
     * This allows the delegate to, essentially, call "super" before or after it does some work.
     * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
     * @example:
     * To override one or more methods, in place:
     *      logger.setDelegate({ debug: console.debug });
     * To override one or more methods with a separate object:
     *      logger.setDelegate(customLoggerDelegate);
     *      (where "customLoggerDelegate" might be defined elsewhere as, e.g.:
     *          var customLoggerDelegate = { debug: function(msg) { document.getElementById('debugMsg').innerHTML = msg; },
     *                                       serverUrl: function() { return 'https://custom-log-server.apple.com'; } };
     * To override one or more methods with an instantiated object from a class definition:
     *      eventRecorder.setDelegate(new CustomLoggerDelegate());
     *      (where "CustomLoggerDelegate" might be defined elsewhere as, e.g.:
     *          function CustomLoggerDelegate() {
     *         }
     *         CustomLoggerDelegate.prototype.debug = function debug(msg) {
     *                                                    document.getElementById('debugMsg').innerHTML = msg;
     *                                                };
     *         CustomLoggerDelegate.prototype.serverUrl = function serverUrl() {
     *                                                          return 'https://custom-log-server.apple.com';
     *                                                    };
     * To override one or more methods with a class object (with "static" methods):
     *      eventRecorder.setDelegate(CustomLoggerDelegate);
     *      (where "CustomLoggerDelegate" might be defined elsewhere as, e.g.:
     *          function CustomLoggerDelegate() {
     *         }
     *         CustomLoggerDelegate.debug = function debug(msg) {
     *                                          document.getElementById('debugMsg').innerHTML = msg;
     *                                      };
     *         CustomLoggerDelegate.serverUrl = function serverUrl() {
     *                                                return 'https://custom-log-server.apple.com';
     *                                          };
     * @param {Object} delegate Object or Class with delegate method(s) to be called instead of default (built-in) methods.
     * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
     * otherwise returns false.
     */
    setDelegate: function setDelegate(delegate) {
        return reflect$1.attachDelegate(this, delegate);
    },

    /**
     * If the log level allows, logs/throws an error to the console and mirrors the log event to the server
     * @param {Logger} logger
     * @param {String} methodName
     * @param {Array-like Object} origArguments
     */
    execute: function execute(logger, methodName, origArguments) {
        var methodLevel = logger.levelStringToIntMap[methodName];

        if (logger.level() !== logger.NONE && logger.level() <= methodLevel) {
            var argumentsArray = Array.prototype.slice.call(origArguments);
            var logArguments = utils.nonFlagLogArguments(argumentsArray);
            var logOptions = utils.logOptions(logger, methodLevel, argumentsArray);
            var callstack = logOptions.includeCallStack ? new Error().stack : null;
            var enrichedLogArguments = callstack ? logArguments.concat('\n' + callstack) : logArguments; // add newline for nicer output

            // so testing harness can verify logging done within tested functions:
            logger[methodName]._lastLog = enrichedLogArguments;

            if (logOptions.mirrorToServer) {
                utils.sendToServer(logger, methodName, logArguments, callstack);
            }

            if (logOptions.throwInsteadOfPrint) {
                throw new Error(logArguments.toString());
            } else if (!logOptions.suppressClientOutput) {
                if (console[methodName]) {
                    console[methodName].apply(console, enrichedLogArguments);
                } else {
                    // fallback to console.log - node does not have console.debug
                    console.log.apply(console, enrichedLogArguments);
                }
            }
        }
    },

    /**
     * Indicates whether an item is a specific flag object that dictates logging behavior
     * @param {*} argument
     * @return {Boolean}
     */
    isFlagObject: function isFlagObject(argument) {
        return argument && argument === utils.flagArguments[argument.constructor.name];
    },

    /**
     * Creates a new array without specific arguments that dictate logging behavior (and are not intended to be logged)
     * @param {Array} argumentsArray
     * @return {Array}
     */
    nonFlagLogArguments: function nonFlagLogArguments(argumentsArray) {
        return argumentsArray.filter(function (argument) {
            return !utils.isFlagObject(argument);
        });
    },

    /**
     * Inspects an array of arguments for specific flag objects that dictate log behavior and returns an object representing the intended behavior
     * By checking for all of the various flags in one pass, we avoid looping over the arguments array more than necessary
     * @param {Logger} logger
     * @param {Int} methodLevel
     * @param {Array} argumentsArray
     * @return {Object}
     */
    logOptions: function logOptions(logger, methodLevel, argumentsArray) {
        var logOptions = {};
        var optionName;

        argumentsArray.forEach(function (argument) {
            if (utils.isFlagObject(argument)) {
                optionName = string$1.snakeCaseToCamelCase(argument.constructor.name);
                logOptions[optionName] = true;
            }
        });

        if (reflect$1.isFunction(logger.mirrorToServerLevel) && logger.mirrorToServerLevel() !== logger.NONE && logger.mirrorToServerLevel() <= methodLevel) {
            logOptions.mirrorToServer = true;
        }
        if (logger.throwLevel() !== logger.NONE && logger.throwLevel() <= methodLevel) {
            logOptions.throwInsteadOfPrint = true;
        }

        return logOptions;
    },

    /**
     * Sends a log event to the server immediately without checking resolution
     * TODO: refactor to use eventRecorder once it is a standalone package
     * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
     * @param {Logger} logger
     * @param {String} level
     * @param {Array} logArguments
     * @param {String} (optional) callstack
     * @return {String} the JSON-stringified event that was sent to the server
     * @overridable
     */
    sendToServer: function sendToServer(logger, level, logArguments, callstack) {}
};

/*
 *  src/logger.js
 *  mt-client-logger-core
 *
 *  Copyright © 2016-2017 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PRIVATE METHODS/IVARS ************************************
 */

// Define log levels separately to expose this constant.
// TODO clean constants up when consolidate.
var LOG_LEVELS = {
    NONE: 0,
    DEBUG: 1,
    INFO: 2,
    WARN: 3,
    ERROR: 4
};
var LOGGER_LEVELS = {
    MIN_LEVEL: LOG_LEVELS.NONE,
    MAX_LEVEL: LOG_LEVELS.ERROR,
    levelIntToStringMap: {
        0: 'none',
        1: 'debug',
        2: 'info',
        3: 'warn',
        4: 'error'
    },
    levelStringToIntMap: {
        'none': 0,
        'debug': 1,
        'info': 2,
        'warn': 3,
        'error': 4
    }
};

reflect$1.extend(LOGGER_LEVELS, LOG_LEVELS);

/** Global properties */
var LOGGER_PROPERTIES = {
    loggerName: 'defaultLogger',
    level: LOGGER_LEVELS.INFO,
    throwLevel: LOGGER_LEVELS.NONE
};

var _initialized = false;

/** A map of logger names to Logger instances */
var _loggers = {};

/**
 * Provides basic "log4j" type functionality.
 * The functionality in this class is typically replaced via a delegate.
 * NOTE: This class has a "secret" field hanging off each logger function called "_lastLog" which allows us to inspect logged errors from within our test cases of various functionality
 *       to ensure that the correct errors are thrown.
 * DEFAULT implementation: console logging
 * DEFAULT logger level: INFO
 * @see setDelegate
 * @delegatable
 * @constructor
 * @param {String} loggerName
 */
function Logger(loggerName) {
    // @private
    this._loggerName = loggerName;

    /* These variables are enumerated here for clarity */
    /* jshint ignore:start */
    // @private
    this._level;
    // @private
    this._throwLevel;
    /* jshint ignore:end */

    // lazily add prototype properties
    if (!_initialized) {
        _initialized = true;
        reflect$1.extend(Logger.prototype, LOGGER_LEVELS);
        reflect$1.extend(Logger.prototype, utils.flagArguments);
    }
}

/**
 * Returns the logger instance that has the name <loggerName>, creating a new one if it doesn't exist
 * @param {String} loggerName
 * @return {Logger}
 */
function loggerNamed(loggerName) {
    loggerName = loggerName || LOGGER_PROPERTIES.loggerName;
    var returnLogger = _loggers[loggerName];

    if (!returnLogger) {
        returnLogger = new Logger(loggerName);
        _loggers[loggerName] = returnLogger;
    }

    return returnLogger;
}

/** Default class property setters and getters */
Logger.level = function level() {
    return LOGGER_PROPERTIES.level;
};
Logger.throwLevel = function throwLevel() {
    return LOGGER_PROPERTIES.throwLevel;
};

// TODO: new PR with this, flesh out and make app-wide with docs
// Logger.setDelegate = function setDelegate() { };
// Logger.logCallback = function logCallback() { };

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class instance's functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes (these methods will not be copied to the target object).
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the standard logger implementation with the exception of, say, the "debug" method, they can
 * call "setDelegate()" with their own delegate containing only a single method of "debug" as the delegate, which would leave all the other methods intact.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      logger.setDelegate({ debug: console.debug });
 * To override one or more methods with a separate object:
 *      logger.setDelegate(customLoggerDelegate);
 *      (where "customLoggerDelegate" might be defined elsewhere as, e.g.:
 *          var customLoggerDelegate = { debug: function(msg) { document.getElementById('debugMsg').innerHTML = msg; },
 *                                       serverUrl: function() { return 'https://custom-log-server.apple.com'; } };
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new CustomLoggerDelegate());
 *      (where "CustomLoggerDelegate" might be defined elsewhere as, e.g.:
 *          function CustomLoggerDelegate() {
 *         }
 *         CustomLoggerDelegate.prototype.debug = function debug(msg) {
 *                                                    document.getElementById('debugMsg').innerHTML = msg;
 *                                                };
 *         CustomLoggerDelegate.prototype.serverUrl = function serverUrl() {
 *                                                          return 'https://custom-log-server.apple.com';
 *                                                    };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(CustomLoggerDelegate);
 *      (where "CustomLoggerDelegate" might be defined elsewhere as, e.g.:
 *          function CustomLoggerDelegate() {
 *         }
 *         CustomLoggerDelegate.debug = function debug(msg) {
 *                                          document.getElementById('debugMsg').innerHTML = msg;
 *                                      };
 *         CustomLoggerDelegate.serverUrl = function serverUrl() {
 *                                                return 'https://custom-log-server.apple.com';
 *                                          };
 * @param {Object} delegate Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Logger.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * The name of this logger
 * @returns {String}
 * @overridable
 */
Logger.prototype.loggerName = function loggerName() {
    return this._loggerName;
};

/**
 * Deduces the integer level from either a string or integer
 * @param {*} level loglevel which may be either a string (e.g. 'debug', 'DEBUG', 'Debug', etc.) or an integer (e.g. 1, 2, 3 or logger.DEBUG, logger.INFO, logger.WARN, etc.
 * @return {Int} the level as an integer or null if an invalid level argument was passed
 * @overrideable
 */
Logger.prototype.levelParameterAsInt = function levelParameterAsInt(level) {
    var returnLevel = null;
    var integerLevel;

    if (reflect$1.isString(level)) {
        integerLevel = this.levelStringToIntMap[level.toLowerCase()];
    } else if (reflect$1.isNumber(level)) {
        integerLevel = level;
    }

    if (integerLevel >= this.MIN_LEVEL && integerLevel <= this.MAX_LEVEL) {
        returnLevel = integerLevel;
    }

    return returnLevel;
};

/**
 * Sets the level at which we will log at or above
 * @param {*} level loglevel which may be either a string (e.g. 'debug', 'DEBUG', 'Debug', etc.) or an integer (e.g. 1, 2, 3 or logger.DEBUG, logger.INFO, logger.WARN, etc.
 * @overridable
 */
Logger.prototype.setLevel = function setLevel(level) {
    var integerLevel = this.levelParameterAsInt(level);
    if (integerLevel !== null) {
        this._level = integerLevel;
    }
};

/**
 * NOTE: This setting should be honored by all delegates.
 * This setting will cause any emitted log message at or above the specified level to throw an exception with the log message instead of logging to the console.
 * This is useful during testcase execution when we would expect to have no log output, or perhaps only "info" log output, etc.
 * @param {*} throwLevel loglevel which may be either a string (e.g. 'debug', 'DEBUG', 'Debug', etc.) or an integer (e.g. 1, 2, 3 or logger.DEBUG, logger.INFO, logger.WARN, etc.
 */
Logger.prototype.setThrowLevel = function setThrowLevel(throwLevel) {
    var integerLevel = this.levelParameterAsInt(throwLevel);
    if (integerLevel !== null) {
        this._throwLevel = integerLevel;
    }
};

/**
 * Returns the current logger level as an integer
 * @overridable
 */
Logger.prototype.level = function level() {
    var level = this._level;
    return reflect$1.isNumber(level) ? level : Logger.level();
};

/**
 * Returns the current logger level as a string
 * @overridable
 */
Logger.prototype.levelString = function levelString() {
    return this.levelIntToStringMap[this.level()];
};

/**
 * Returns the current logger throw level as an integer
 * @overridable
 */
Logger.prototype.throwLevel = function throwLevel() {
    var throwLevel = this._throwLevel;
    return reflect$1.isNumber(throwLevel) ? throwLevel : Logger.throwLevel();
};

/**
 * Emits the log message if log level is set to "debug".
 * DEFAULT implementation: console.debug()
 * @param {Object} a list of objects (perhaps a single string) to be stringified and emitted as the log message
 * @api public
 * @overridable
 */
Logger.prototype.debug = function debug() {
    utils.execute(this, 'debug', arguments);
};

/**
 * Emits the log message if log level is set to "info".
 * DEFAULT implementation: console.info()
 * @param {Object} a list of objects (perhaps a single string) to be stringified and emitted as the log message
 * @api public
 * @overridable
 */
Logger.prototype.info = function info() {
    utils.execute(this, 'info', arguments);
};

/**
 * Emits the log message if log level is set to "warn".
 * DEFAULT implementation: console.warn()
 * @param {Object} a list of objects (perhaps a single string) to be stringified and emitted as the log message
 * @api public
 * @overridable
 */
Logger.prototype.warn = function warn() {
    utils.execute(this, 'warn', arguments);
};

/**
 * Emits the log message if log level is set to "error".
 * DEFAULT implementation: console.error()
 * @param {Object} a list of objects (perhaps a single string) to be stringified and emitted as the log message
 * @api public
 * @overridable
 */
Logger.prototype.error = function error() {
    utils.execute(this, 'error', arguments);
};

/**
 * @param {String} levelString
 * @return {String} the most recent log event for this level
 */
Logger.prototype.lastLog = function lastLog(levelString) {
    return this[levelString] ? this[levelString]._lastLog : null;
};

/*
 *  src/environment.js
 *  mt-client-config
 *
 *  Copyright © 2016-2017 Apple Inc. All rights reserved.
 *
 */

var attachDelegate$1 = reflect$1.attachDelegate;
var localStorageObject$1 = storage.localStorageObject;
var sessionStorageObject$1 = storage.sessionStorageObject;

/**
 * Provides a set of environment-specific (platform-specific) functions which can be individually overridden for the needs
 * of the particular environment, or replaced en masse by providing a single replacement environment delegate object
 * The functionality in this class is typically replaced via a delegate.
 * @see setDelegate
 * @delegatable
 * @constructor
 */
var environment = {
    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */

    /**
     * Allows replacement of one or more of this class' functions
     * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
     * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
     * Your delegate can be a true object instance, an anonymous object, or a class object.
     * Your delegate is free to have as many additional non-matching methods as it likes.
     * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
     *
     * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
     * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
     * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
     * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
     * but override the "appVersion" method again, this time with their own supplied delegate.
     *
     * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
     * This allows the delegate to, essentially, call "super" before or after it does some work.
     * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
     * @example:
     * To override one or more methods, in place:
     *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
     * To override one or more methods with a separate object:
     *      eventRecorder.setDelegate(eventRecorderDelegate);
     *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
     *                                       sendMethod: 'itms'};
     * To override one or more methods with an instantiated object from a class definition:
     *      eventRecorder.setDelegate(new EventRecorderDelegate());
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
     *                                                          return 'itms';
     *                                                      };
     * To override one or more methods with a class object (with "static" methods):
     *      eventRecorder.setDelegate(EventRecorderDelegate);
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.sendMethod = function sendMethod() {
     *                                                return 'itms';
     *                                            };
     * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
     * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
     * otherwise returns false.
     */
    setDelegate: function setDelegate(delegate) {
        return attachDelegate$1(this, delegate);
    },

    localStorageObject: localStorageObject$1,
    sessionStorageObject: sessionStorageObject$1
};

/*
 *  src/network.js
 *  mt-client-config
 *
 *  Copyright © 2018 Apple Inc. All rights reserved.
 *
 */

var attachDelegate$1$1 = reflect$1.attachDelegate;
var makeAjaxRequest$1 = network.makeAjaxRequest;

/**
 * Network request methods exposed so delegate callers can override
 * @constructor
 */
var network$1 = {
    /**
     * Allows replacement of one or more of this class' functions
     * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
     * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
     * Your delegate can be a true object instance, an anonymous object, or a class object.
     * Your delegate is free to have as many additional non-matching methods as it likes.
     * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
     *
     * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
     * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
     * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
     * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
     * but override the "appVersion" method again, this time with their own supplied delegate.
     *
     * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
     * This allows the delegate to, essentially, call "super" before or after it does some work.
     * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
     * @example:
     * To override one or more methods, in place:
     *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
     * To override one or more methods with a separate object:
     *      eventRecorder.setDelegate(eventRecorderDelegate);
     *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
     *                                       sendMethod: 'itms'};
     * To override one or more methods with an instantiated object from a class definition:
     *      eventRecorder.setDelegate(new EventRecorderDelegate());
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
     *                                                          return 'itms';
     *                                                      };
     * To override one or more methods with a class object (with "static" methods):
     *      eventRecorder.setDelegate(EventRecorderDelegate);
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.sendMethod = function sendMethod() {
     *                                                return 'itms';
     *                                            };
     * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
     * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
     * otherwise returns false.
     */
    setDelegate: function setDelegate(delegate) {
        return attachDelegate$1$1(this, delegate);
    },
    /**
     * Covers private utils implementation of makeAjaxRequest for delegation
     */
    makeAjaxRequest: makeAjaxRequest$1
};

/*
 *  src/config.js
 *  mt-client-config
 *
 *  Copyright © 2016-2017 Apple Inc. All rights reserved.
 *
 */

var attachDelegate$2 = reflect$1.attachDelegate;
var hasAnyKeys$1 = reflect$1.hasAnyKeys;
var isArray$1 = reflect$1.isArray;
var saveObjectToStorage$1 = storage.saveObjectToStorage;
var objectFromStorage$1 = storage.objectFromStorage;
var exponentialBackoff$1 = backoff.exponentialBackoff;
var valueForKeyPath$1 = key_value.valueForKeyPath;

var NO_TOPIC_KEY = 'noTopicConfig';

/**
 * The default config should not include keys which have meaning if they are omitted.
 * For example, a configSource without impressions means no impressions should be recorded, and in this case we should
 * not have impressions in defaults so we don't inadvertently disobey the client's configSource.
 */
var DEFAULTS$1 = {
    blacklistedFields: ['capacitySystem', 'capacitySystemAvailable', 'capacityDisk', 'capacityData', 'capacityDataAvailable'],
    compoundSeparator: '_',
    configBaseUrl: 'https://xp.apple.com/config/1/report',
    constraints: {
        profiles: {
            AMPWeb: {
                precedenceOrderedRules: [{
                    filters: 'any',
                    fieldConstraints: {
                        clientId: {
                            generateValue: true,
                            namespace: 'AMPWeb_isSignedOut',
                            expirationPeriod: 86400000
                        }
                    }
                }, {
                    filters: {
                        valueMatches: {
                            isSignedIn: [true]
                        }
                    },
                    fieldConstraints: {
                        clientId: {
                            generateValue: true,
                            namespace: 'AMPWeb_isSignedIn',
                            expirationPeriod: 15552000000
                        }
                    }
                }]
            },
            strict: {
                precedenceOrderedRules: [{
                    filters: 'any',
                    fieldConstraints: {
                        clientId: {
                            generateValue: true,
                            scopeFieldName: 'parentPageUrl',
                            scopeStrategy: 'mainDomain',
                            expirationPeriod: 86400000
                        },
                        consumerId: { blacklisted: true },
                        dsId: { blacklisted: true },
                        parentPageUrl: { scope: 'hostname' }
                    }
                }, {
                    filters: {
                        valueMatches: {
                            eventType: ['click'],
                            actionType: ['signUp']
                        }
                    },
                    fieldConstraints: {
                        parentPageUrl: { scope: 'fullWithoutParams' }
                    }
                }, {
                    filters: {
                        valueMatches: {
                            eventType: ['dialog'],
                            dialogType: ['upsell'],
                            result: ['upsell']
                        }
                    },
                    fieldConstraints: {
                        parentPageUrl: { scope: 'fullWithoutParams' }
                    }
                }, {
                    filters: {
                        valueMatches: {
                            userType: ['signedIn']
                        }
                    },
                    fieldConstraints: {
                        clientId: { scopeStrategy: 'all' }
                    }
                }, {
                    filters: {
                        valueMatches: {
                            userType: ['signedIn'],
                            eventType: ['click', 'dialog', 'media', 'search']
                        }
                    },
                    fieldConstraints: {
                        clientId: { blacklisted: true },
                        consumerId: { blacklisted: false },
                        dsId: { blacklisted: false }
                    }
                }, {
                    filters: {
                        valueMatches: {
                            userType: ['signedIn'],
                            eventType: ['page', 'impressions']
                        },
                        nonEmptyFields: ['pageHistory']
                    },
                    fieldConstraints: {
                        clientId: { blacklisted: true },
                        consumerId: { blacklisted: false },
                        dsId: { blacklisted: false }
                    }
                }]
            }
        }
    },
    fieldsMap: {
        cookies: ['itcCt', 'itscc'],
        custom: {
            impressions: ['id', 'adamId', 'link.type', 'station-hash'],
            location: ['id', 'adamId', 'dataSetId', 'name', 'fcKind', 'kindIds', 'type', 'link.type', 'station-hash', 'core-seed-name']
        },
        single: {
            targetId: ['id', 'adamId', 'contentId', 'type', 'link.type', 'fcId', 'userPreference', 'label', 'station-hash', 'linkIdentifier']
        }
    },
    metricsUrl: 'https://xp.apple.com/report',
    postFrequency: 60000,
    postFrequencyLowLatency: 5000,
    tokenSeparator: '|'
};

var _configs = {};

/**
 * Appends the provided source and its subsection if the subsection key matches the provided topic to the provided configSources array.
 * @param {Array} configSources
 * @param {String} topic
 * @param {Object} source
 */
var _appendSectionAndSubsectionToConfigSources = function _appendSectionAndSubsectionToConfigSources(configSources, topic, source) {
    if (source) {
        configSources.push(source);
        var subsection = source[topic];
        if (subsection && hasAnyKeys$1(subsection)) {
            configSources.push(subsection);
        }
    }
};

/**
 * Provides config-related functionality including managing config sources and values.
 * The functionality in this class is typically replaced via a delegate.
 * @see setDelegate
 * @delegatable
 * @constructor
 * @param {String} topic
 */
var Config = function Config(topic) {
    // @private
    this._topic = topic;

    // @private
    this._debugSource = null;
    // @private
    this._cachedSource = null;
    // @private
    this._serviceSource = null;
    // @private
    this._initCalled = false;
    // @private
    this._initialized = false;
    // @private
    this._showedDebugWarning = false;
    // @private
    this._showedNoProvidedSourceWarning = false;
    // @private
    this._keyPathsThatSuppressWarning = {
        configBaseUrl: true // used to fetch a config source, so we do not expect sources to be set when retrieving this value
    };

    // @const
    this.DEBUG_SOURCE_KEY = 'mtClientConfig_debugSource' + DEFAULTS$1.compoundSeparator + this._topic;
    // @const
    this.CACHED_SOURCE_KEY = 'mtClientConfig_cachedSource' + DEFAULTS$1.compoundSeparator + this._topic;
};

/**
 * DEPRECATED - Use getConfig() and init() instead
 */
Config.createConfig = function createConfig(topic, configSourcesFn, onSuccessHandler, onFailureHandler) {
    var returnConfig = Config.getConfig(topic);

    if (topic && topic !== NO_TOPIC_KEY // default config does not need to initialize
    && !returnConfig._initCalled) {
        returnConfig.init(configSourcesFn, onSuccessHandler, onFailureHandler);
    }

    return returnConfig;
};

/**
 * Creates a new config instance associated with <topic>, unless it already exists, then returns it
 * @param {String} topic
 * @return {Config}
 */
Config.getConfig = function getConfig(topic) {
    topic = topic || NO_TOPIC_KEY;
    var returnConfig = _configs[topic];

    if (!returnConfig) {
        returnConfig = new Config(topic);
        _configs[topic] = returnConfig;
    }

    return returnConfig;
};

/**
 * cleanup resources from the config of the provided topic and remove it from the config cache
 * @param {String} topic
 */
Config.cleanupConfig = function cleanupConfig(topic) {
    if (topic && _configs[topic]) {
        var releasedConfig = _configs[topic];
        releasedConfig.setCachedSource();
        releasedConfig.setDebugSource();
        delete _configs[topic];
    }
};

/**
 * @return {Config} the default config instance, which is not associated with any topic
 */
Config.defaultConfig = function defaultConfig() {
    return Config.getConfig();
};

/**
 * Returns the highest-precedence property value associated with keyPath
 * Tries to use the topic-specific config instance, and if it doesn't exist, uses the default config instance
 * @param {String} keyPath the dot-separated (".") path to the desired config value.
 * @param {String} (optional) topic
 * @returns {*} the value at the reached keypath. Returns "null" if the key or key's value is not found.
 * Values found in later (farthest in array) dictionaries of key/value pairs overwrite earlier dictionaries.
 * @see Config.prototype.value()
 */
Config.value = function value(keyPath, topic) {
    var config$$1 = topic && _configs[topic] || Config.defaultConfig();

    return config$$1.value.call(config$$1, keyPath);
};

/**
 * Delegatable platform-specific environment and logger methods used by all config instances
 */
Config.environment = environment;
Config.logger = /*#__PURE__*/loggerNamed('mt-client-config');
Config.network = network$1;

/**
 ************************************ PSEUDO-PRIVATE METHODS/IVARS ************************************
 * These functions need to be accessible for ease of testing, but should not be used by clients
 */
Config.prototype._defaults = function _defaults() {
    return DEFAULTS$1;
};

Config.prototype._setInitialized = function _setInitialized(initialized) {
    this._initialized = initialized;
};

Config.prototype._setInitCalled = function _setInitCalled(initCalled) {
    this._initCalled = initCalled;
};

Config.prototype._setShowedDebugWarning = function _setShowedDebugWarning(value) {
    this._showedDebugWarning = value;
};

Config.prototype._setShowedNoProvidedSourceWarning = function _setShowedNoProvidedSourceWarning(value) {
    this._showedNoProvidedSourceWarning = value;
};

/**
 ************************************ PUBLIC METHODS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Config.prototype.setDelegate = function setDelegate(delegate) {
    return attachDelegate$2(this, delegate);
};

/**
 * @return {String} the Figaro topic that this config corresponds with
 * Most clients do not need to override this method
 */
Config.prototype.topic = function topic() {
    return this._topic;
};

/**
 * Returns the metrics config endpoint hostname
 * Most clients do not need to override this method
 * @return {String} a hostname e.g.xp.apple.com
 */
Config.prototype.configHostname = function configHostname() {};

/**
 * Returns a constructed URL to the metrics config endpoint for use with getConfig()
 * Most clients do not need to override this method
 * @return {String} a URL to the metrics config endpoint e.g. https://xp.apple.com/config/1/report/xp_its_main
 */
Config.prototype.configUrl = function configUrl() {
    var configHostname = this.configHostname();
    var returnUrl;

    if (configHostname) {
        returnUrl = 'https://' + configHostname + '/config/1/report';
    } else {
        returnUrl = this.value('configBaseUrl');
    }

    if (this._topic !== NO_TOPIC_KEY) {
        returnUrl += '/' + this.topic();
    } else {
        Config.logger.error("config.configUrl(): Topic must be provided");
    }

    return returnUrl;
};

/**
 * This function will be used to access all of the sources for configuration data (e.g. disabled, blacklistedEvents, fieldsMap, etc.)
 * THIS METHOD MUST BE PROVIDED BY A DELEGATE
 * Returns an array of key/value objects (dictionaries) for all of the config sources (e.g. the bag, the page, the control parent, etc.).
 * This method will be called frequently and repeatedly from the metrics.config.* functions.
 * MetricsKit will use this return value to traverse the list of config objects, looking for config values.
 * If later dictionaries of key/value pairs contain any keys already collected, the most late (farthest in the area) config value will overwrite earlier ones.
 * IMPORTANT: This function might be called frequently and repeatedly so should be optimized for performance.
 *            It will be called frequently (rather than having this API provide a "setConfig" method for permanently setting the config values) since
 *            these config values can always be changing from one call to the next, so this ensures that they are current.
 * THEREFORE: This function should NOT try to "simplify" by, e.g., merging all config sources into a single object to return when called.
 *            Doing so is an enormous amount of work to do each time MetricsKit needs to look up a single value.
 *            It is far more efficient for MetricsKit to simply interogate each configSource for the required key, rather than
 *            the delegate function merging *all* keys of *all* sources (looping through all values of all sources) in order to look up a single value.
 * @example var sources = function() { return [itms.getBag().metrics, pageData.metrics.config]; };   // return an array of sources of app config
 * @example var sources = function() { return metrics.utils.keyValue.sourcesArray(itms.getBag().metrics, pageData.metrics.config, swooshData.metrics.config); }; // Let MetricsKit help build the array from a varargs list of sources
 * @example var sources = function() { return metrics.utils.keyValue.sourcesArray(existingArrayOfConfigSources, pageData.metrics.config, swooshData.metrics.config); }; // Let MetricsKit help build the array from a varargs list of sources where some args are already arrays of other sources (only works one level deep)
 * @see metrics.system.configSources.sources for simple creation of the return value of config sources.
 */
Config.prototype.sources = function sources() {};

/**
 * Search through the configuration sources provided by "metrics.system.configSources()", looking for the highest precedence value for "key"
 * If no config sources provided, look for values in the DEFAULTS constant
 * "keypath" can be a simple top-level config key such as "postFrequency" or a compound "path", such as fieldsMap.cookies
 * @param {String} keyPath the dot-separated (".") path to the desired config value.
 * @returns {Object} the value at the reached keypath. Returns "null" if the key or key's value is not found.
 * Values found in later (farthest in array) dictionaries of key/value pairs overwrite earlier dictionaries.
 * @see metrics.system.configSources.setDelegate()
 */
Config.prototype.value = function value(keyPath) {
    var cachedSource = this.cachedSource();
    var serviceSource = this.serviceSource();
    var configSourcesArray = this.sources();
    var savedDebugSource = this.debugSource(); // NOTE: Always go through the accessor method, since it may need to be retrieved from localStorage
    var sourceProvided = cachedSource || serviceSource || configSourcesArray || savedDebugSource;
    var sourcesToCheck;

    // show relevant warnings
    if (!configSourcesArray && !serviceSource && !(keyPath in this._keyPathsThatSuppressWarning)) {
        if (!this._showedNoProvidedSourceWarning) {
            this._showedNoProvidedSourceWarning = true;
            Config.logger.warn("Metrics config: No config provided via delegate or fetched via init(), using default/cached config values.");
        }
    }
    if (savedDebugSource) {
        if (!this._showedDebugWarning) {
            // We do this in case developers forget to clear this and wonder why the app isn't working correctly in normal running.
            this._showedDebugWarning = true;
            Config.logger.warn("\"debugSource\" found.\nThis will override any same-named client-supplied configSource fields.\nThis setting \"sticks\" across session, use \"setDebugSource(null)\" to clear");
        }
    }

    if (!isArray$1(configSourcesArray)) {
        configSourcesArray = [configSourcesArray];
    }

    // Use default blacklisting rules only if there are no provided sources
    if (keyPath.indexOf('blacklisted') === 0) {
        if (sourceProvided) {
            sourcesToCheck = [cachedSource, serviceSource, configSourcesArray, savedDebugSource];
        } else {
            sourcesToCheck = [DEFAULTS$1];
        }
    } else {
        // For non-blacklist rules, check all sources
        // Let "DEFAULTS" be overwritten by cachedSource, then serviceSource, then client-supplied configSources,
        // and then let "savedDebugSource" overwrite everyone
        sourcesToCheck = [DEFAULTS$1, cachedSource, serviceSource, configSourcesArray, savedDebugSource];
    }

    sourcesToCheck = this.configSourcesWithOverrides(sourcesToCheck, this.topic());
    // Pass each source as an individual argument; valueForKeyPath won't expand configSourcesArray if it is nested in sourcesToCheck
    return valueForKeyPath$1.apply(null, [keyPath].concat(sourcesToCheck));
};

/**
* Pushes any subsections within a config source to the front of the provided config sources array if the subsection key matches with the specified topic.
* This method is used by the default implementation of 'value(keyPath)' to determine precedence
* of config sources for the given topic.
* Subsections that are later in the array will take precedence over earlier subsections.
* Note that if one of the config sources is an array, this method will traverse one level deep
* to check for the presence of a dictionary that may contain a desired subsection.
* We traverse one level deep to maintain parity with _utils.keyValue.valueForKeyPath() which will be used to traverse the config sources
* @param {Array} configSources
* @param {String} topic
* @returns {Array} returnSources
*/
Config.prototype.configSourcesWithOverrides = function configSourcesWithOverrides(configSources, topic) {
    var returnSources = configSources;
    if (configSources && configSources.length && topic) {
        returnSources = [];
        for (var i = 0; i < configSources.length; i++) {
            var source = configSources[i];
            if (source) {
                if (isArray$1(source) && source.length) {
                    var subarray = [];
                    for (var j = 0; j < source.length; j++) {
                        _appendSectionAndSubsectionToConfigSources(subarray, topic, source[j]);
                    }
                    returnSources.push(subarray);
                } else {
                    _appendSectionAndSubsectionToConfigSources(returnSources, topic, source);
                }
            }
        }
    }
    return returnSources;
};

/**
 * Set's a "priority" configSource that will override any same-named client-supplied configSource fields.
 * This can be done in code (e.g. in testcases) or, more typically, in Web Inspector when debugging or testing a running app (client) using MetricsKit.
 * This is useful when testing, both in testcases and at runtime. One example would be to set a temporary "bag" structure that could then be tweaked at will, e.g. blacklisting fields, etc.
 * This setting "sticks" across session so that it can be set, the app restarted, and the values will be present at the earliest runnings of the app.
 * Use "setDebugSource(null)" to clear this value
 * NOTE: If no "localStorage" is available (e.g. when testing), this value will only last for the session or until it is explicitly cleared.
 * Here is an example of how to use this to test an app at runtime (and/or launch time)
 *      Run the app
 *      Open Web Inspector
 *      Set a variable to bag contents, e.g. var debugBag = itms.getBag();
 *      Call: metrics.config.setDebugSource(debugBag.metrics);
 *      enter: debugBag.metrics.disabled=true;
 *      Then do some things to generate events and make sure that:
 *          The app doesn’t crash
 *          No JavaScript events are generated in the console
 *          The events aren’t sent
 *      Reset that by entering: delete debugBag.metrics.disabled
 *      enter: debugBag.metrics.blacklistedEvents = [“page”, “click”];
 *      Then do some things to generate events and make sure that:
 *          The app doesn’t crash
 *          No JavaScript events are generated in the console
 *          Those events, and only those events, aren’t sent
 *      I save the object you set via metrics.config.setDebugSource to localStorage to facilitate testing at app startup, so remember to clear it out when you’re done or you’ll be confused why things aren’t working right in the future:
 *      metrics.config.setDebugSource();
 *      If there are values you want to be in effect at app-launch, just do the tweaking to the bag before your call to metrics.config.setDebugSource(debugBag.metrics);, passing in the tweaked bag.
 * @param aDebugSource a plain old JavaScript object with keys and values which will be searched when config is requested.
 * @returns {*} debugSource
 */
Config.prototype.setDebugSource = function setDebugSource(aDebugSource) {
    this._debugSource = aDebugSource || null;
    return saveObjectToStorage$1(environment.localStorageObject(), this.DEBUG_SOURCE_KEY, this._debugSource);
};

/**
 * Return any previously set debugSource which would be stored in localStorage.
 * If not present in localStorage, the class variable value of debugSource will be returned.
 * @returns {*} debugSource
 */
Config.prototype.debugSource = function debugSource() {
    if (this._debugSource) ;else {
        // Otherwise look in localStorage for one...
        this._debugSource = objectFromStorage$1(environment.localStorageObject(), this.DEBUG_SOURCE_KEY);
    }
    return this._debugSource;
};

/**
 * Save a source to localStorage which will have config values that can be used in the next visit until a fresh config is fetched
 * @param {Object} aSource
 * @return {Object}
 */
Config.prototype.setCachedSource = function setCachedSource(aSource) {
    this._cachedSource = aSource || null;
    return saveObjectToStorage$1(environment.localStorageObject(), this.CACHED_SOURCE_KEY, this._cachedSource);
};

/**
 * Return any previously set savedSource which would be stored in localStorage.
 * The class variable value of savedSource will be returned if non-null to avoid expensive reads from disk.
 * @return {Object}
 */
Config.prototype.cachedSource = function cachedSource() {
    if (this._cachedSource) ;else {
        // Otherwise look in localStorage for one...
        this._cachedSource = objectFromStorage$1(environment.localStorageObject(), this.CACHED_SOURCE_KEY);
    }
    return this._cachedSource;
};

/**
 * Set a source, typically one that was fetched from the config endpoint,
 * which will have config values that can be overwritten by clients via config.setDelegate
 * @param {Object} aServiceSource
 * @return {Object}
 */
Config.prototype.setServiceSource = function setServiceSource(aServiceSource) {
    this._serviceSource = aServiceSource;
    return this._serviceSource;
};

/**
 * Returns a config source that was retrieved from the metrics config service endpoint
 * @return {Object}
 */
Config.prototype.serviceSource = function serviceSource() {
    return this._serviceSource;
};

/**
 * Fetches a config payload from configUrl and stores it in _serviceSource
 * TODO: do not fetch config if it has already been fetched
 * TODO: allow callers to specify failure strategy
 * @param {String} configUrl
 * @param {Function} onSuccessHandler (optional) function to call on success
 * @param {Function} onFailureHandler (optional) function to call on failure
 */
Config.prototype.fetchConfig = function fetchConfig(configUrl, onSuccessHandler, onFailureHandler) {
    onFailureHandler = onFailureHandler || function () {};

    var onSuccessWrapper = function onSuccessWrapper(response) {
        var validResponse;

        try {
            response = JSON.parse(response);
            validResponse = true;
        } catch (e) {
            // Fail if the response is invalid
            onFailureHandler.call(onFailureHandler, e);
        }

        // Don't wrap the whole successHandler in the try/catch
        if (validResponse && onSuccessHandler) {
            onSuccessHandler.call(onSuccessHandler, response);
        }
    };

    exponentialBackoff$1(network$1.makeAjaxRequest.bind(network$1, configUrl, 'GET', null), onSuccessWrapper, onFailureHandler);
};

/**
 * Initialize config by setting config delegate or fetching it from the config endpoint as necessary
 * If we wanted config to persist across page turns, we could save it via setCachedSource and fetch it every time we wake up,
 * but we expect most clients to be single page apps
 * @param {Function} (optional) configSourcesFn - a function that returns an array of key/value objects (dictionaries) for all of the config sources
 *                                                (e.g. the bag, the page, the control parent, etc.).
 * @param {Function} (optional) onSuccessHandler - function to execute on success; typically omitted if configSourcesFn was provided.
 * @param {Function} (optional) onFailureHandler - function to execute on failure
 */
Config.prototype.init = function init(configSourcesFn, onSuccessHandler, onFailureHandler) {
    if (!this._initCalled) {
        this._initCalled = true;

        onSuccessHandler = onSuccessHandler || function () {};

        var onComplete = function onComplete() {
            this._initialized = true;
            onSuccessHandler.call(onSuccessHandler);
        }.bind(this);

        if (configSourcesFn) {
            this.setDelegate({
                sources: configSourcesFn
            });
            onComplete();
        } else {
            // grab any previously cached config source to use while a new one is fetched
            this.setCachedSource(this.cachedSource());

            var configUrl = this.configUrl();
            var onConfigFetched = function onConfigFetched(configObject) {
                this.setCachedSource(configObject);
                this.setServiceSource(configObject);
                onComplete();
            }.bind(this);

            this.fetchConfig(configUrl, onConfigFetched, onFailureHandler);
        }
    }
};

/**
 * DEPRECATED - Use init() instead
 */
Config.prototype.initialize = function initialize(configSourcesFn, onSuccessHandler, onFailureHandler) {
    return this.init.apply(this, Array.prototype.slice.call(arguments));
};

/**
 * Indicates whether or not config has initialized.
 * Initialization is accomplished in one of the following ways:
 *     1) a service source is set via a call to config.setServiceSource()
 *     2) a source function delegate is set via config.setDelegate()
 * @return {Boolean}
 */
Config.prototype.initialized = function initialized() {
    return this._initialized;
};

/*
 *  src/system/environment.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

/**
 * Provides a set of environment-specific (platform-specific) functions which can be individually overridden for the needs
 * of the particular environment, or replaced en masse by providing a single replacement environment delegate object
 * The functionality in this class is typically replaced via a delegate.
 * @see setDelegate
 * @delegatable
 * @constructor
 */
var Environment$4 = function Environment() {};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Environment$4.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Some clients have platform-specific implementations of these objects (e.g. iTunes.sessionStorage), so we cover them in case they need to be overriden.
 */
Environment$4.prototype.localStorageObject = storage.localStorageObject;
Environment$4.prototype.sessionStorageObject = storage.sessionStorageObject;

/*
 *  src/system/index.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

var System$1 = function System() {
    this.environment = new Environment$4();
    this.logger = loggerNamed('mt-client-constraints');
};

/*
 *  src/treatment_matchers/non_empty_match
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

/**
 *
 * @param {String} fieldName - name of field in eventData
 * @param {Object} eventData - a dictionary of event data
 * @returns {Boolean} return true if the fieldName does exist in the eventData otherwise return false
 */
function nonEmptyMatch(fieldName, eventData) {
    // Since the isObject will return undefined/null if the eventData is undefined/null.
    // workaround here to convert the return value to boolean here to ensure this function returns boolean value. Should be fix it in the isObject()
    return !!reflect$1.isObject(eventData) && eventData.hasOwnProperty(fieldName) && reflect$1.isDefinedNonNullNonEmpty(eventData[fieldName]);
}

/*
 *  src/treatment_matchers/value_match
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

/**
 *
 * @param {String} fieldName - name of field in eventData
 * @param {Object} eventData - a dictionary of event data
 * @param {Array} fieldMatchValues - a list of possible values to match for that field
 * @returns {Boolean} return true if the field value exists in "fieldMatchValues" otherwise return false
 */
function valueMatch(fieldName, eventData, fieldMatchValues) {
    if (!reflect$1.isObject(eventData)) {
        return false;
    }

    var fieldValue = eventData[fieldName];
    return eventData.hasOwnProperty(fieldName) && fieldMatchValues.indexOf(fieldValue) > -1;
}

/*
 *  src/treatment_matchers/index.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var matchers = {
    nonEmpty: nonEmptyMatch,
    valueMatches: valueMatch
};

/*
 *  src/utils/constants.js
 *  mt-client-constraints
 *
 *  Copyright © 2019 Apple Inc. All rights reserved.
 *
 */

var FIELD_RULES = {
    OVERRIDE_FIELD_VALUE: 'overrideFieldValue'
};

/*
 *  src/field_handlers/base.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

/**
 * Provides methods to manage field constraints that apply to all fields
 * @constructor
 */
var Base$1$1 = function Base() {};

/**
 ************************************ PUBLIC METHODS ************************************
 */
/**
 * @param {Object} eventFields a dictionary of event data
 * @param {Object} fieldRules includes information about how to constrain a field
 * @param {String} fieldName the name of the field to constrain
 * @return {any} a field value that adheres to the provided rules
 * @overridable
 */
Base$1$1.prototype.constrainedValue = function constrainedValue(eventFields$$1, fieldRules, fieldName) {
    var fieldValue = eventFields$$1 && eventFields$$1.hasOwnProperty(fieldName) ? eventFields$$1[fieldName] : null;

    return this.applyConstraintRules(fieldValue, fieldRules);
};

/**
 * @param {any} fieldValue an unconstrained value
 * @param {Object} fieldRules includes information about how to constrain a field
 * @return {any} a field value that adheres to the provided rules
 * @overridable
 */
Base$1$1.prototype.applyConstraintRules = function applyConstraintRules(fieldValue, fieldRules) {
    var returnValue = fieldValue;

    if (fieldRules && fieldRules.blacklisted) {
        returnValue = null;
    } else if (fieldRules && fieldRules.hasOwnProperty(FIELD_RULES.OVERRIDE_FIELD_VALUE)) {
        returnValue = fieldRules.overrideFieldValue;
    }

    return returnValue;
};

/*
 *  src/field_actions/base.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */
var exceptionString$2 = string$1.exceptionString;

/**
 * Parent class of field_actions classes
 * @param {Object} constraintsInstance - the instance of Constraints class
 * @constructor
 */
var Base$1$2 = function Base(constraintsInstance) {
    // @private
    this._constraintsInstance = constraintsInstance;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Base$1$2.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Abstract method to constrain value
 * @param {Any} value - the value of fieldName in eventData, null if the eventData does not exist or the fieldName does not exist in the eventData
 * @param {Object} fieldRules - includes information about how to constrain the field
 * @param {Object} eventData - a dictionary of event data, which should include a pre-existing (unconstrained) field
 * @param {String} fieldName - name of the field being field_actions in eventData
 * @return {Any} the constrained value
 */
Base$1$2.prototype.constrainedValue = function constrainedValue(value, fieldRules, eventData, fieldName) {
    throw exceptionString$2('field_actions.Base', 'constrainedValue');
};

/**
 * A public method to wrap the "constrainedValue" method to contains common code for all field_actions subclasses.
 * @param {String} fieldName - name of the field being field_actions in eventData
 * @param {Object} eventData - a dictionary of event data, which should include a pre-existing (unconstrained) field
 * @param {Object} fieldRules - includes information about how to constrain the field
 * @return {Any} the constrained value
 */
Base$1$2.prototype.performAction = function performAction(fieldName, eventData, fieldRules) {
    var value = eventData && reflect$1.isDefined(eventData[fieldName]) ? eventData[fieldName] : null;
    // return the original value if there are no rules to apply
    if (reflect$1.isDefinedNonNull(fieldRules) && !reflect$1.isEmptyObject(fieldRules)) {
        value = this.constrainedValue(value, fieldRules, eventData, fieldName);
    }
    return value;
};

/*
 *  src/utils/url.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * @param {String} aUrl
 * @return {String} the hostname part of the provided url e.g. www.apple.com
 * @overridable
 * Note: see https://nodejs.org/api/url.html for a diagram illustrating the different parts of a URL
 */
function hostname(aUrl) {
    aUrl = aUrl || '';

    var urlParts = withoutParams(aUrl).split('/');
    var hostAndAuth;
    var host;
    var hostname;

    if (aUrl.indexOf('//') === -1) {
        hostAndAuth = urlParts[0];
    } else {
        hostAndAuth = urlParts[2];
    }

    host = hostAndAuth.substring(hostAndAuth.indexOf('@') + 1);
    hostname = host.split(':')[0];

    return hostname;
}

/**
 * @param {String} aUrl
 * @return {String} the domain part of the provided url shortened to the "main" part of the domain (apple.com or apple.co.uk)
 * @overridable
 * Note: this method uses a heuristic to determine if the url has a country code second level domain and will miss
 *       ccSLDs that are not exactly two chracters long or one of: 'com', 'org, 'net', edu', 'gov'
 *       For example, "www.example.ltd.uk" will be shortened to "ltd.uk"
 *       All two-letter top-level domains are ccTLDs: https://en.wikipedia.org/wiki/Country_code_top-level_domain
 */
function mainDomain(aUrl) {
    var urlSegments = hostname(aUrl).split('.');
    var lastSegment = urlSegments[urlSegments.length - 1];
    var secondToLastSegment = urlSegments[urlSegments.length - 2];
    var segmentsToKeep = 2;

    if (lastSegment && lastSegment.length === 2 && secondToLastSegment && (secondToLastSegment.length === 2 || secondToLastSegment in reservedCCSLDs())) {
        segmentsToKeep = 3;
    }

    return urlSegments.slice(-1 * segmentsToKeep).join('.');
}

/**
 * @return {Object} a map of country-code second level domains (ccSLDs) used in the heuristic
 * that determines the main part of a domain (defined as TLD + ccSLD + 1)
 * @overridable
 */
function reservedCCSLDs() {
    var reservedCCSLDs = {
        com: true,
        org: true,
        net: true,
        edu: true,
        gov: true
    };

    return reservedCCSLDs;
}

/**
 * @param {String} aUrl
 * @return {String} the url with any query parameters and/or hash removed
 * @overridable
 */
function withoutParams(aUrl) {
    aUrl = aUrl || '';
    return aUrl.split('?')[0];
}

/*
 *  src/field_actions/id_action/time_based_action.js
 *  mt-client-constraints
 *
 *  Copyright © 2021 Apple Inc. All rights reserved.
 *
 */

/**
 * The time-based ID generating strategy
 * The ID value will change after its lifespan expires
 */
function constrainedValue(idString, idRules, eventData, fieldName) {

    var storageKey = this.storageKey(fieldName, eventData, idRules);
    var environment = this._constraintsInstance.system.environment;
    var idData = storage.objectFromStorage(environment.localStorageObject(), storageKey) || {};

    idData.value = this.idString(idData, idRules);
    if (this.rulesHaveLifespan(idRules) && (!reflect$1.isNumber(idData.expirationTime) || this.timeExpired(idData.expirationTime))) {
        idData.expirationTime = this.expirationTime(idRules.lifespan);
    }

    storage.saveObjectToStorage(environment.localStorageObject(), storageKey, idData);
    idString = idData.value;

    return idString;
}

/*
 *  src/field_actions/id_action/session_time_based_action.js
 *  mt-client-constraints
 *
 *  Copyright © 2021 Apple Inc. All rights reserved.
 *
 */

// @private
// A global cache storage to store the served clientIds by the clientId storageKey
// Make it as a global variable to ensure the cached clientId can be shared between multiple MK instances
var _sessionIdCache = {};

/**
 * The user-session-based + time-based ID generating strategy
 * When the id getting expired, this function will return a consistent ID until the current user session ends, even if the ID is scheduled to expire in the middle of the session
 */
function constrainedValue$1(idString, idRules, eventData, fieldName) {
    var storageKey = this.storageKey(fieldName, eventData, idRules);
    var returnedIdString = _sessionIdCache[storageKey];

    if (!returnedIdString) {
        returnedIdString = constrainedValue.apply(this, arguments);
        _sessionIdCache[storageKey] = returnedIdString;
    }
    return returnedIdString;
}

/*
 *  src/field_actions/id_action/id_action.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var STORAGE_KEY_SEPARATOR = '_';
var MT_ID_NAMESPACE = 'mtId';

var IdAction = function IdAction() {
    Base$1$2.apply(this, arguments);
};

IdAction.prototype = Object.create(Base$1$2.prototype);
IdAction.prototype.constructor = IdAction;

/*
 * Possible strategies that can be used to scope an ID value
 */
IdAction.prototype.SCOPE_STRATEGIES = {
    ALL: 'all',
    MAIN_DOMAIN: 'mainDomain'
};

/**
 * @param {Object} (optional) idRules includes information about when to expire the ID
 * @return {Boolean}
 */
IdAction.prototype.rulesHaveLifespan = function rulesHaveLifespan(idRules) {
    idRules = idRules || {};

    return reflect$1.isNumber(idRules.lifespan);
};

/**
 * @param {Number} (optional) lifespan the amount of time, in milliseconds, that an ID should be valid for
 * @return {Number} a timestamp in ms since epoch, or null if no lifespan was provided
 */
IdAction.prototype.expirationTime = function expirationTime(lifespan) {
    return lifespan ? Date.now() + lifespan : null;
};

/**
 * @param {String} fieldName - name of the field being field_actions in eventData
 * @param {Object} eventData a dictionary of event data
 * @param {Object} idRules includes information about how to namespace/scope the id
 * @return {String} the key that id data should be stored under
 * @example
 * (storageKeyPrefix ? storageKeyPrefix : mtId_<fieldName>)_<namespace>_(scopeStrategy ? <eventData[scopeFieldName]> : 'all')
 * @overridable
 */
IdAction.prototype.storageKey = function storageKey(fieldName, eventData, idRules) {
    var scope = this.scope(eventData, idRules);
    return this.storageKeyPrefix(idRules, fieldName) + (scope ? STORAGE_KEY_SEPARATOR + scope : '');
};

/**
 * @param {Object} idRules includes information about how to namespace/scope the id
 * @param {String} fieldName - name of the field being field_actions in eventData
 * @return {String} a prefix to be used when storing id data in localStorage
 * @overridable
 */
IdAction.prototype.storageKeyPrefix = function storageKeyPrefix(idRules, fieldName) {
    return idRules && reflect$1.isString(idRules.storageKeyPrefix) && idRules.storageKeyPrefix.length > 0 ? idRules.storageKeyPrefix : MT_ID_NAMESPACE + STORAGE_KEY_SEPARATOR + fieldName;
};

/**
 * @param {Object} eventData a dictionary of event data
 * @param {Object} idRules includes information about how to namespace/scope the id
 * @return {String} the namespace/scope for this set of event data and rules
 * @overridable
 */
IdAction.prototype.scope = function scope(eventData, idRules) {
    var idKey = '';

    if (idRules) {
        if (idRules.namespace) {
            idKey += idRules.namespace;
        }
        if (idRules.scopeStrategy) {
            var domainScope;

            switch (idRules.scopeStrategy) {
                case this.SCOPE_STRATEGIES.MAIN_DOMAIN:
                    var scopeFieldName = idRules.scopeFieldName;
                    domainScope = mainDomain(eventData[scopeFieldName]) || 'unknownDomain';
                    break;
                case this.SCOPE_STRATEGIES.ALL: /* fall through */
                default:
                    // no scope
                    domainScope = this.SCOPE_STRATEGIES.ALL;
                    break;
            }

            if (idKey.length) {
                idKey += STORAGE_KEY_SEPARATOR;
            }
            idKey += domainScope;
        }
    }

    return idKey;
};

/**
 * @param {Object} (optional) existingIdData
 * @param {Object} (optional) idRules includes information about when to expire the ID
 * @return {String} an ID
 * @overridable
 */
IdAction.prototype.idString = function idString(existingIdData, idRules) {
    var existingId = existingIdData ? existingIdData.value : null;
    var returnValue = existingId;

    if (!existingId || reflect$1.isNumber(existingIdData.expirationTime) && this.timeExpired(existingIdData.expirationTime)) {
        returnValue = this.generateId(idRules);
    }

    return returnValue;
};

/**
 * @param {Object} (optional) idRules includes information about how to constrain the field
 * @return {String} a generated ID
 * @overridable
 * @see comments in the related MTClientId.java
 */
IdAction.prototype.generateId = function generateId(idRules) {
    var uuid = this.rawUUID();
    var expirationTime = null;
    var separator = null;

    if (idRules) {
        expirationTime = this.expirationTime(idRules.lifespan);
        separator = idRules.tokenSeparator;
    }

    var idString = this.generatedIdMetadata(expirationTime) + this.idTokenSeparator() + uuid || '';

    var convertedIdString = idString.split(this.idTokenSeparator()).map(function (segment) {
        var segmentAsNumber = parseInt(segment, 16);
        return string$1.convertNumberToBaseAlphabet(segmentAsNumber, string$1.base61Alphabet);
    }).join(this.generatedIdSeparator(separator));

    return convertedIdString || '0';
};

/**
 * @return {String} uuid consisting of hex characters and dashes; defaults to a RFC4122-compliant UUID
 * @overridable
 */
IdAction.prototype.rawUUID = function rawUUID() {
    return string$1.uuid();
};

/**
 * @param {Number} (optional) expirationTime a timestamp in ms since epoch at which the existing ID will expire
 * @return {String} a token-separated hex string of metadata to attach to a ID,
 * including the ID version and the timestamp at which it expires, if any
 * @overridable
 */
IdAction.prototype.generatedIdMetadata = function generatedIdMetadata(expirationTime) {
    var parameters = [this.generatedIdVersion()];

    if (expirationTime) {
        parameters.push(expirationTime);
    }

    return parameters.map(function (param) {
        return param.toString(16);
    }).join(this.idTokenSeparator());
};

/**
 * @return {Number} the version of the generated ID
 * @overridable
 */
IdAction.prototype.generatedIdVersion = function generatedIdVersion() {
    return 4;
};

/**
 * @return {String} the separator used to tokenize sections of an unformatted ID string
 * @overridable
 */
IdAction.prototype.idTokenSeparator = function idTokenSeparator() {
    return '-';
};

/**
 * @param {String} (optional) separator
 * @return {String} the separator used to tokenize sections of a finalized, formatted ID string
 * @overridable
 */
IdAction.prototype.generatedIdSeparator = function generatedIdSeparator(separator) {
    return separator || 'z';
};

/**
 * @param {Number} timestamp a timestamp in ms since epoch
 * @return {Boolean}
 * @overridable
 */
IdAction.prototype.timeExpired = function timeExpired(timestamp) {
    return timestamp <= Date.now();
};

/**
 * @param {String} idString - the ID field in eventData
 * @param {Object} idRules - includes information about how to constrain the field
 * @param {String}(optional) idRules.storageKeyPrefix - a prefix to be used when storing ID data in localStorage, default is MT_ID_NAMESPACE
 * @param {String}(optional) idRules.namespace - a string to be used when storing ID data in localStorage.
 * @param {String}(optional) idRules.scopeStrategy - a strategy that can be used to scope a ID value [all/mainDomain]
 * @param {String}(optional) idRules.scopeFieldName - name of the scope field in eventData, the value would be an URL and used to get the main domain as a part of scope. It is used when parameters.scopeStrategy set to "mainDomain"
 * @param {String}(optional) idRules.tokenSeparator - the separator used to tokenize sections of a finalized, formatted ID string. Default is 'z'
 * @param {Integer}(optional) idRules.lifespan - the expiration period for the ID (milliseconds)
 * @param {Boolean}(optional) idRules.persistIdForSession - a boolean to indicate whether to persist the ID until the current user session ends, even if it is scheduled to expire in the middle of the session
 * @param {Object} eventData - a dictionary of event data, which should include a pre-existing (unconstrained) ID field
 * @param {String} fieldName - name of the field being field_actions in eventData
 * @return {String} the constrained ID
 */
IdAction.prototype.constrainedValue = function constrainedValue$2(idString, idRules, eventData, fieldName) {

    if (eventData && idRules && !reflect$1.isEmptyObject(idRules)) {
        if (idRules.persistIdForSession === true) {
            idString = constrainedValue$1.apply(this, arguments);
        } else {
            idString = constrainedValue.apply(this, arguments);
        }
    }
    return idString;
};

/*
 *  src/field_handlers/client_id.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

/**
 * Provides methods to manage clientId field constraints.
 * @constructor
 */
var ClientId = function ClientId(base, constraintsInstance) {
    // @private
    this._base = base;
    // @private
    this._idAction = new IdAction(constraintsInstance);
    this._idAction.setDelegate({
        storageKey: function storageKey(fieldName, eventData, idRules) {
            return this.storageKeyPrefix() + '_' + this.scope(eventData, idRules);
        }.bind(this._idAction),
        storageKeyPrefix: function storageKeyPrefix() {
            return 'mtClientId';
        }
    });
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * @param {Object} eventFields a dictionary of event data, which may include a pre-existing (unconstrained) clientId
 * @param {Object} clientIdRules includes information about when to expire the clientId and how to namespace/scope it
 * @return {String} a clientId that adheres to the provided rules
 * @overridable
 */
ClientId.prototype.constrainedValue = function constrainedValue(eventFields$$1, clientIdRules) {
    // adapt expirationPeriod to lifespan
    var clonedRules = clientIdRules;
    if (clientIdRules && reflect$1.isNumber(clientIdRules.expirationPeriod)) {
        clonedRules = reflect$1.extend({}, clientIdRules);
        clonedRules.lifespan = clonedRules.expirationPeriod;
        delete clonedRules.expirationPeriod;
    }

    var clientIdString = this._idAction.performAction('clientId', eventFields$$1, clonedRules);

    return this._base.applyConstraintRules(clientIdString, clientIdRules);
};

/*
 *  src/field_actions/url_action.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var UrlAction = function UrlAction() {
    Base$1$2.apply(this, arguments);
};

UrlAction.prototype = Object.create(Base$1$2.prototype);
UrlAction.prototype.constructor = UrlAction;

/*
 * Possible truncation strategies that can be applied to a parentPageUrl
 */
UrlAction.prototype.SCOPES = {
    HOSTNAME: 'hostname',
    FULL: 'full',
    FULL_WITHOUT_PARAMS: 'fullWithoutParams'
};

/**
 * @param {String} url - the URL field in eventData
 * @param {Object} fieldRules - includes information about how to constrain the field
 * @return {String} the constrained URL
 */
UrlAction.prototype.constrainedValue = function constrainedValue(url, fieldRules) {

    if (url && fieldRules && fieldRules.scope) {
        switch (fieldRules.scope) {
            case this.SCOPES.HOSTNAME:
                url = hostname(url);
                break;
            case this.SCOPES.FULL_WITHOUT_PARAMS:
                url = withoutParams(url);
                break;
            case this.SCOPES.FULL: /* fall through */
        }
    }

    return url;
};

/*
 *  src/field_handlers/parent_page_url.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

/**
 * Provides methods to manage parentPageUrl field constraints.
 * @constructor
 */
var ParentPageUrl = function ParentPageUrl(base) {
    // @private
    this._base = base;
    // @private
    this._urlAction = new UrlAction();
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * @param {Object} eventFields a dictionary of event data, which should include a pre-existing (unconstrained) parentPageUrl
 * @param {Object} parentPageUrlRules includes information about whether to strip certain parts of the URL
 * @return {String} a parentPageUrl modified according to the provided rules
 * @overridable
 */
ParentPageUrl.prototype.constrainedValue = function constrainedValue(eventFields$$1, parentPageUrlRules) {
    var modifiedUrl = this._urlAction.performAction('parentPageUrl', eventFields$$1, parentPageUrlRules);

    return this._base.applyConstraintRules(modifiedUrl, parentPageUrlRules);
};

/*
 *  src/field_handlers/index.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

/**
 * @deprecated the field handlers has been deprecated and replaced with "De-res treatments(src/field_actions/*)"
 * @param constraintsInstance
 * @constructor
 */
var FieldHandlers = function FieldHandlers(constraintsInstance) {
    this.base = new Base$1$1(constraintsInstance);
    this.clientId = new ClientId(this.base, constraintsInstance);
    this.parentPageUrl = new ParentPageUrl(this.base, constraintsInstance);
};

/*
 *  src/treatment/legacy_treatment.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var LegacyTreatment = function LegacyTreatment(constraintInstance) {
    // @private
    this._fieldHandlers = new FieldHandlers(constraintInstance);
};

/**
 * @param {Object} eventData a dictionary of event data
 * @param {Object} eventConstraints a set of constraints to apply to this event
 * @return {Object} the event data modified according to the appropriate constraints
 * Note: event fields will be modified in place and also returned
 * @example
 * var eventData = {
 *     eventType: 'click',
 *     pageType: 'TopCharts',
 *     parentPageUrl: 'https://itunes.apple.com/music/topcharts/12345',
 *     // etc.
 * };
 * var eventConstraints = {
 *         fieldConstraints: { parentPageUrl: { scope: 'hostname' } }
 *     }
 * legacyTreatment.applyConstraints(eventData, eventConstraints) =>
 *     {
 *         eventType: click,
 *         pageType: 'TopCharts',
 *         parentPageUrl: 'itunes.apple.com', // truncated to hostname only
 *         etc... // all other fields remain the same
 *     }
 */
LegacyTreatment.prototype.applyConstraints = function applyConstraints(eventData, eventConstraints) {
    if (eventConstraints && eventConstraints.fieldConstraints) {
        eventData = this.applyFieldConstraints(eventData, eventConstraints.fieldConstraints);
    }

    return eventData;
};

/**
 * @param {Object} eventData a dictionary of event data
 * @param {Object} fieldConstraints a set of constraints to apply to fields in this event, keyed by field name
 * @return {Object} the event data modified according to the appropriate constraints
 * Note: event fields will be modified in place and also returned
 */
LegacyTreatment.prototype.applyFieldConstraints = function applyFieldConstraints(eventData, fieldConstraints) {
    if (fieldConstraints) {
        var constrainedFieldValues = {};
        var constrainedValue;
        var fieldRules;
        var fieldName;

        for (fieldName in fieldConstraints) {
            fieldRules = fieldConstraints[fieldName];
            if (eventData.hasOwnProperty(fieldName) || fieldRules.generateValue === true || fieldRules.hasOwnProperty(FIELD_RULES.OVERRIDE_FIELD_VALUE)) {
                if (fieldName in this._fieldHandlers) {
                    constrainedValue = this._fieldHandlers[fieldName].constrainedValue(eventData, fieldRules);
                } else {
                    constrainedValue = this._fieldHandlers.base.constrainedValue(eventData, fieldRules, fieldName);
                }

                constrainedFieldValues[fieldName] = constrainedValue;
            }
        }

        // assign constrained values only after all of them have been calculated
        // in case some constrained values depend on more than one original field values
        for (fieldName in constrainedFieldValues) {
            eventData[fieldName] = constrainedFieldValues[fieldName];
        }

        eventData = event_fields.mergeAndCleanEventFields(eventData);
    }

    return eventData;
};

/*
 *  src/utils/constraint_generator
 *  mt-client-constraints
 *
 *  Copyright © 2021 Apple Inc. All rights reserved.
 *
 */

/**
 * Adding/replacing the rule properties of targetRules with the ones of newRules
 * @param {Object} targetRules - an object contains an <fieldConstraintsName> property with field rules in it.
 * @param {Object} newRules - an object contains an <fieldConstraintsName> property with new field rules in it.
 * @param {String} fieldRulesKeyName - the field rule property name
 * @param {Function} initialFieldRules - a callback function to decide the target field rule object. Function signature: function (targetRules, sourceRules, fieldName)
 * @returns {Object} updated target rules, all replacements are in-place updating unless the passed-in targetRules object does not exist
 */
function updateFieldRulesets(targetRules, newRules, fieldRulesKeyName, initialFieldRules) {
    var updatedRules = targetRules || {};
    initialFieldRules = initialFieldRules || function (targetRules, sourceRules, fieldName) {
        return targetRules[fieldName] || {};
    };

    if (newRules && newRules[fieldRulesKeyName]) {
        var fieldName;
        var propertyName;
        var updatedFieldRules = updatedRules[fieldRulesKeyName] || {};
        updatedRules[fieldRulesKeyName] = updatedFieldRules;

        // copying the top level rules over is sufficient for a simple rule structure
        for (fieldName in newRules[fieldRulesKeyName]) {
            var fieldRules = initialFieldRules(updatedFieldRules, newRules[fieldRulesKeyName], fieldName);
            updatedFieldRules[fieldName] = fieldRules;
            for (propertyName in newRules[fieldRulesKeyName][fieldName]) {
                fieldRules[propertyName] = newRules[fieldRulesKeyName][fieldName][propertyName];
            }
        }
    }

    return updatedRules;
}

/*
 *  src/constraint_generator/legacy_constraint_generator.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

var LegacyConstraintGenerator = function LegacyConstraintGenerator(constraintInstance) {
    this.treatment = new LegacyTreatment(constraintInstance);
};

/**
 * @param {Object} eventData a dictionary of event data
 * @param {Object} topicConfig the AMP Metrics topic config to use to look up constraint_generator values
 * @param {String}(optional) topic defines the AMP Analytics "topic" to look up the constraint profile
 * @return {Object} a set of constraints to apply to this event
 * @overridable
 * Constraint rules will be applied in the order they are provided in config.
 * @example
 *     Given the following config:
 *     { constraints: {
 *          defaultProfile: 'strict',
 *          profiles: {
 *              strict: {
 *                  precedenceOrderedRules: [
 *                      {
 *                          filters: 'any',
 *                          fieldConstraints: {
 *                              clientId: {
 *                                  generateValue: true,
 *                                  tokenSeparator: 'z',
 *                                  scopeFieldName: 'parentPageUrl',
 *                                  scopeStrategy: 'mainDomain', // apple.com or apple.co.uk
 *                                  expirationPeriod: 86400000 // 24h
 *                              },
 *                              parentPageUrl: {
 *                                  scope: 'hostname' // www.apple.com
 *                              }
 *                          }
 *                      },
 *                      {
 *                          filters: {
 *                              valueMatches: {
 *                                  eventType: ['click'],
 *                                  actionType: ['signUp']
 *                              },
 *                              nonEmptyFields: ['pageHistory']
 *                          },
 *                          fieldConstraints: {
 *                              parentPageUrl: {
 *                                  scope: 'fullWithoutParams'
 *                              }
 *                          }
 *                      },
 *                      {
 *                          filters: {
 *                              valueMatches: {
 *                                  userType: ['signedIn']
 *                              }
 *                          },
 *                          fieldConstraints: {
 *                              clientId: {
 *                                  scopeStrategy: 'all'
 *                              },
 *                              dsId: { blacklisted: true }
 *                          }
 *                      }
 *                  ]
 *              }
 *          }
 *      } }
 *
 *     new Constraints(config).constraintsForEvent({ eventType: 'click', userType: 'signedIn', actionType: 'navigate', ... }) returns:
 *     {
 *         fieldConstraints: {
 *             clientId: {
 *                 generateValue: true, // from 'any' match
 *                 tokenSeparator: 'z', // from 'any' match
 *                 scopeFieldName: 'parentPageUrl', // from 'any' match
 *                 scopeStrategy: 'all', // from userType=signdIn match
 *                 expirationPeriod: 86400000 // from 'any' match
 *             },
 *             dsId: { blacklisted: true }, // from userType=signedIn match
 *             parentPageUrl: {
 *                 scope: 'hostname' // from 'any' match
 *                                   // (the event did not match the rule with eventType=click,
 *                                   // actionType=signUp, nonEmpty pageHistory)
 *             }
 *         }
 *     }
 */
LegacyConstraintGenerator.prototype.constraintsForEvent = function constraintsForEvent(eventData, topicConfig, topic) {
    if (!topicConfig) {
        return null;
    }
    var profilePath = 'constraints.profiles.' + topicConfig.constraintProfile(topic);
    var constraintsConfig = topicConfig.value(profilePath, topic);
    var constraints = null;

    if (constraintsConfig && constraintsConfig.precedenceOrderedRules) {
        var self = this;
        constraints = constraintsConfig.precedenceOrderedRules.reduce(function (accumulatedRules, rule) {
            if (self.eventMatchesRule(eventData, rule)) {
                accumulatedRules = self.updateRules(accumulatedRules, rule);
            }

            return accumulatedRules;
        }, {});
    }

    return constraints;
};

/**
 * @param {Object} eventData a dictionary of event data
 * @param {Object} matchRule contains information about whether an event matches a rule
 * @return {Boolean}
 * @example
 *     var event = { eventType: 'click', userType: 'signedIn', actionType: 'navigate', ... };
 *     var matchRule = {
 *           filters: {
 *              valueMatches: {
 *                  eventType: ['click']
 *              },
 *              nonEmptyFields: ['actionType']
 *          },
 *          fieldConstraints: { ... }
 *     };
 *     eventMatchesRule(event, matchRule); // => true
 */
LegacyConstraintGenerator.prototype.eventMatchesRule = function eventMatchesRule(eventData, matchRule) {
    var returnValue = false;

    if (eventData && matchRule.filters) {
        if (matchRule.filters === 'any') {
            returnValue = true;
        } else if (reflect$1.isObject(matchRule.filters)) {
            returnValue = this.eventMatchesNonEmptyFields(eventData, matchRule.filters.nonEmptyFields) && this.eventMatchesFieldValues(eventData, matchRule.filters.valueMatches);
        }
    }

    return returnValue;
};

/**
 * @param {Object} eventData a dictionary of event data
 * @param {Array<string>} nonEmptyFieldNames
 * @return {Boolean}
 */
LegacyConstraintGenerator.prototype.eventMatchesNonEmptyFields = function eventMatchesNonEmptyFields(eventData, nonEmptyFieldNames) {
    var returnValue = false;

    if (eventData) {
        if (!nonEmptyFieldNames || !reflect$1.isArray(nonEmptyFieldNames)) {
            returnValue = true;
        } else {
            returnValue = nonEmptyFieldNames.every(function (fieldName) {
                return matchers.nonEmpty(fieldName, eventData);
            });
        }
    }

    return returnValue;
};

/**
 * @param {Object} eventData a dictionary of event data
 * @param {Object} valueMatches a mapping of field names to lists of possible values to match for that field.  A matching field value is determined using strict equality.  Field values can be of any primitive type.
 * @return {Boolean}
 */
LegacyConstraintGenerator.prototype.eventMatchesFieldValues = function eventMatchesFieldValues(eventData, valueMatches) {
    var returnValue = false;

    if (eventData) {
        if (!valueMatches || !reflect$1.isObject(valueMatches) || reflect$1.isEmptyObject(valueMatches)) {
            returnValue = true;
        } else {
            returnValue = Object.keys(valueMatches).every(function (fieldMatchName) {
                var fieldMatchValues = valueMatches[fieldMatchName];
                return matchers.valueMatches(fieldMatchName, eventData, fieldMatchValues);
            });
        }
    }

    return returnValue;
};

/**
 * @param {Object} currentRules a dictionary of constraint rules
 * @param {Object} newRule a dictionary of rule data to be added to the current rules
 * @return {Object} the updated set of rules
 * Note: the current rules will be modified in place and also returned
 */
LegacyConstraintGenerator.prototype.updateRules = function updateRules(currentRules, newRule) {
    return updateFieldRulesets(currentRules, newRule, 'fieldConstraints');
};

/*
 *  src/event_actions/blacklisted_event_action.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var BlacklistedEventAction = function BlacklistedEventAction() {};

/**
 * blacklisting the event if the blacklisted parameter is true
 * @param {Object} eventData a dictionary of event data
 * @param {Boolean} blacklisted true if blacklisting the entire event
 * @return {Object} return the passed-in eventData if  blacklisted not equals to false, otherwise, return "null"
 */
BlacklistedEventAction.prototype.performAction = function performAction(eventData, blacklisted) {
    return blacklisted !== true ? eventData : null;
};

/*
 *  src/event_actions/blacklisted_fields_action.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var BlacklistedFieldsAction = function BlacklistedFieldsAction() {};

/**
 * remove the blacklisted event fields from the passed-in eventData
 * @param {Object} eventData a dictionary of event data
 * @param {Array} blacklistedFields the blacklisted fields
 * @return {Object} return a dictionary of event data that excluded the blacklisted fields or "null" if all fields are removed.
 */
BlacklistedFieldsAction.prototype.performAction = function performAction(eventData, blacklistedFields) {
    if (!eventData || !reflect$1.isArray(blacklistedFields) || reflect$1.isEmptyArray(blacklistedFields)) {
        return eventData;
    }
    eventData = reflect$1.extend({}, eventData);

    blacklistedFields.forEach(function (blacklistedField) {
        delete eventData[blacklistedField];
    });

    return !reflect$1.isEmptyObject(eventData) ? eventData : null;
};

/*
 *  src/event_actions/whitelisted_fields_action.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var WhitelistedFieldsAction = function WhitelistedFieldsAction() {};

/**
 * remove the event fields from the passed-in eventData if it is not in the whitelistedFields
 * @param {Object} eventData a dictionary of event data
 * @param {Array} whitelistedFields the whitelisted fields
 * @return {Object} return a dictionary of event data that only included the whitelisted fields
 */
WhitelistedFieldsAction.prototype.performAction = function performAction(eventData, whitelistedFields) {
    // Ignoring an empty whitelistedFields to have consistent behavior with Native MetricsKit
    if (!eventData || !reflect$1.isArray(whitelistedFields) || reflect$1.isEmptyArray(whitelistedFields)) {
        return eventData;
    }
    var returnedData = {};

    Object.keys(eventData).forEach(function (eventField) {
        if (whitelistedFields.indexOf(eventField) > -1) {
            returnedData[eventField] = eventData[eventField];
        }
    });

    return !reflect$1.isEmptyObject(returnedData) ? returnedData : null;
};

/*
 *  src/event_actions/index.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var ACTIONS = {
    blacklistedEventAction: 'blacklisted',
    blacklistedFieldsAction: 'blacklistedFields',
    whitelistedFieldsAction: 'whitelistedFields'
};

var EventActions = function EventActions() {
    // @private
    this._actions = {};
    this._actions[ACTIONS.blacklistedEventAction] = new BlacklistedEventAction();
    this._actions[ACTIONS.blacklistedFieldsAction] = new BlacklistedFieldsAction();
    this._actions[ACTIONS.whitelistedFieldsAction] = new WhitelistedFieldsAction();
};

EventActions.prototype.getAction = function getAction(actionName) {
    return this._actions[actionName];
};

/*
 *  src/field_actions/number_deres
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var NumberAction = function NumberAction() {
    Base$1$2.apply(this, arguments);
};

NumberAction.prototype = Object.create(Base$1$2.prototype);
NumberAction.prototype.constructor = NumberAction;

/**
 * @param {Number} aNumber - a number being constrained
 * @param {Object} fieldRules - includes information about how to constrain the field
 * @param {Number} fieldRules.precision - must be a positive integer
 * @return {Number} the constrained number
 */
NumberAction.prototype.constrainedValue = function constrainedValue(aNumber, fieldRules) {
    var precision = fieldRules ? fieldRules.precision : 0;

    if (reflect$1.isNumber(aNumber) && reflect$1.isNumber(precision) && precision > 0) {
        aNumber = Math.floor(aNumber / precision) * precision;
    }

    return aNumber;
};

/*
 *  src/utils/serial_number_generator.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var DEFAULT_NAMESPACE = 'mt_serial_number';
var EXPIRATION_STORAGE_KEY = 'exp';
var SERIAL_NUMBER_STORAGE_KEY = 'sn';

/**
 *
 * @param {Object} options - An object that contains parameters for generating serial numbers
 * @param {String} options.namespace (optional) - A key that is used to store the serial numbers in the Storage. Default to "mt_serial_number"
 * @param {Number} options.initialSerialNumber (optional) - An initialization serial number. Default to 0
 * @param {Number} options.nextRotationTime (optional) - A timestamp that indicates when should reset the serial number. Default to Number.POSITIVE_INFINITY(never rotate)
 * @param {Number} options.rotationPeriod (optional) - A millisecond to indicate how long the serial number could be alive. Default to Number.POSITIVE_INFINITY(never rotate)
 * @constructor
 */
var SerialNumberGenerator = function SerialNumberGenerator(options) {
    options = options || {};
    // @private
    this._nextRotationTime = options.nextRotationTime || Number.POSITIVE_INFINITY;
    // @private
    this._storageKey = options.namespace || DEFAULT_NAMESPACE;
    // @private
    this._initialSerialNumber = options.initialSerialNumber || 0;
    // @private
    this._rotationPeriod = options.rotationPeriod || Number.POSITIVE_INFINITY;
};

SerialNumberGenerator.prototype.setDelegate = function setDelegate(delegate) {
    reflect$1.attachDelegate(this, delegate);
};

SerialNumberGenerator.prototype.localStorageObject = function localStorageObject() {
    return storage.localStorageObject();
};

/**
 * Return the increased serial number
 * @param {Number} increment (optional) - The amount to increment. Defaults to 1
 * @returns {Number} the increased serial number
 */
SerialNumberGenerator.prototype.getNextSerialNumber = function getNextSerialNumber(increment) {
    var storageKey = this._storageKey;
    var serialNumberData = this._getCurrentSerialNumberData(storageKey);

    var serialNum = serialNumberData[SERIAL_NUMBER_STORAGE_KEY];
    increment = reflect$1.isNumber(increment) ? increment : 1;
    serialNum = parseInt(serialNum, 10);

    if (isNaN(serialNum)) {
        // Reset the serial number to the initialized one, to ensure the logic won't break if the sequence number is an invalid number.
        serialNum = this._initialSerialNumber;
    }
    serialNum = this._increaseSerialNumber(serialNum, increment);
    // Store the increased serial number to storage
    serialNumberData[SERIAL_NUMBER_STORAGE_KEY] = serialNum;
    storage.saveObjectToStorage(this.localStorageObject(), this._storageKey, serialNumberData);

    return serialNum;
};

/**
 * Reset the serial number
 */
SerialNumberGenerator.prototype.resetSerialNumber = function resetSerialNumber() {
    var serialNumberData = storage.objectFromStorage(this.localStorageObject(), this._storageKey);

    if (reflect$1.isDefinedNonNull(serialNumberData)) {
        this._resetSerialNumber(serialNumberData[EXPIRATION_STORAGE_KEY]);
    }
};

/**
 * Delegable method to return the time for calculating rotation
 * @returns {number}
 */
SerialNumberGenerator.prototype.getTime = function getTime() {
    return Date.now();
};

/**
 * Increasing the giving serial number by plus one
 * @param {Number} serialNum
 * @returns {number}
 * @private
 */
SerialNumberGenerator.prototype._increaseSerialNumber = function _increaseSerialNumber(serialNum, increment) {
    return serialNum + increment;
};

/**
 * Rotate and return the serial number data
 * @param {String} storageKey
 * @returns {Object} rotated serial number data
 */
SerialNumberGenerator.prototype._getCurrentSerialNumberData = function _getCurrentSerialNumberData(storageKey) {
    var serialNumberData = storage.objectFromStorage(this.localStorageObject(), storageKey);
    var rotationTime;
    var nextRotationTime;
    if (serialNumberData) {
        rotationTime = serialNumberData[EXPIRATION_STORAGE_KEY];
        rotationTime = parseInt(rotationTime, 10);
        serialNumberData[EXPIRATION_STORAGE_KEY] = rotationTime = isNaN(rotationTime) ? this._nextRotationTime : rotationTime;
    } else {
        // use the "nextRotationTime - rotationPeriod" as the rotationTime if the serialNumberData is not existing in the storage, to check if need to reset serial number
        rotationTime = this._nextRotationTime - this._rotationPeriod;
    }

    // Reset the serial number data if it has expired or never initialized
    // Checking "!serialNumberData" in here to cover the case of when both of this._nextRotationTime and this._rotationPeriod are not provided, "this._nextRotationTime(Infinite) - this._rotationPeriod(Infinite) = NaN" which is always less than "this.getTime()"
    // Use while loop here to catch up to the latest rotation time.
    while (!serialNumberData || this.getTime() >= rotationTime) {
        rotationTime = nextRotationTime = rotationTime + this._rotationPeriod;
        serialNumberData = this._resetSerialNumber(nextRotationTime);
    }
    return serialNumberData;
};

/**
 * Reset the serial number and expiration
 * @param {Number} nextRotationTime - A timestamp that indicates when should reset the serial number
 * @returns reset serialNumberData
 * {
 *     exp: nextRotationTime,
 *     sn: serialNumber
 * }
 */
SerialNumberGenerator.prototype._resetSerialNumber = function _resetSerialNumber(nextRotationTime) {
    var serialNumberData = {};
    serialNumberData[EXPIRATION_STORAGE_KEY] = nextRotationTime;
    serialNumberData[SERIAL_NUMBER_STORAGE_KEY] = this._initialSerialNumber;
    storage.saveObjectToStorage(this.localStorageObject(), this._storageKey, serialNumberData);
    return serialNumberData;
};

/*
 *  src/field_actions/time_deres
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var STORAGE_KEY_SEPARATOR$1 = '_';
var STORAGE_PREFIX_DEFAULT = 'mtTimestamp';

var TimeAction = function TimeAction() {
    Base$1$2.apply(this, arguments);
    // @private
    this._storage = this._constraintsInstance.system.environment.localStorageObject();
    // @private
    /*
     * Store the end time of the giving time precision base on namespace + time fields
     */
    this._precisionEndTimeCache = {};
    // @private
    this._serialNumberGenerator = null;
};

TimeAction.prototype = Object.create(Base$1$2.prototype);
TimeAction.prototype.constructor = TimeAction;

/**
 * @param {Number} time - a timestamp being constrained
 * @param {Object} fieldRules - includes information about how to constrain the field
 * @param {Object} fieldRules.precision - The time must be a positive integer
 * @param {String} fieldRules.storageKeyPrefix - a prefix to be used when storing timestamp de-res related data, default is "mt-timestamp"
 * @param {String} fieldRules.namespace - a namespace for the timestamp de-res related data, default is empty.
 * @param {Object} eventData - a dictionary of event data, which should include a pre-existing (unconstrained) field
 * @param {String} fieldName - name of the field being modified in eventData
 * @return {Number} the constrained time or the original value if time is not defined or fieldRules is unavailable
 */
TimeAction.prototype.constrainedValue = function constrainedValue(time, fieldRules, eventData, fieldName) {
    var returnTimestamp = time;
    if (reflect$1.isNumber(time) && reflect$1.isObject(fieldRules) && reflect$1.isNumber(fieldRules.precision) && fieldRules.precision > 0) {
        var precisionStartTime = this._computePrecisionStartTime(time, fieldRules);
        this._serialNumberGenerator = new SerialNumberGenerator({
            namespace: this._persistentStorageKey(fieldRules, fieldName),
            nextRotationTime: precisionStartTime + fieldRules.precision,
            rotationPeriod: fieldRules.precision
        });
        this._serialNumberGenerator.setDelegate(this._constraintsInstance.system.environment);
        this._serialNumberGenerator.setDelegate({
            getTime: function getTime() {
                return time;
            }
        });
        var serialNumber = this._serialNumberGenerator.getNextSerialNumber();
        returnTimestamp = this._computeTimestamp(precisionStartTime, serialNumber);
        this._serialNumberGenerator = null; // Release the serial number generator.
    }

    return returnTimestamp;
};

TimeAction.prototype._computeTimestamp = function _computeTimestamp(precisionStartTime, sequenceNum) {
    return precisionStartTime + sequenceNum;
};

TimeAction.prototype._persistentStorageKey = function _persistentStorageKey(fieldRules, fieldName) {
    var namespaceSegment = fieldRules.namespace ? STORAGE_KEY_SEPARATOR$1 + fieldRules.namespace : '';
    return (fieldRules.storageKeyPrefix || STORAGE_PREFIX_DEFAULT) + namespaceSegment + STORAGE_KEY_SEPARATOR$1 + fieldName;
};

TimeAction.prototype._computePrecisionStartTime = function _computePrecisionStartTime(time, fieldRules) {
    var precision = fieldRules.precision;
    return Math.floor(time / precision) * precision;
};

/*
 *  src/field_actions/index.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var ACTIONS$1 = {
    ID: 'idGenerator',
    NUMBER: 'numberDeres',
    TIME: 'timeDeres',
    URL: 'urlDeres'
};

var FieldActions = function DeresHandlers(constraintsInstance) {
    this.actions = {};
    this.actions[ACTIONS$1.ID] = new IdAction(constraintsInstance);
    this.actions[ACTIONS$1.NUMBER] = new NumberAction(constraintsInstance);
    this.actions[ACTIONS$1.TIME] = new TimeAction(constraintsInstance);
    this.actions[ACTIONS$1.URL] = new UrlAction(constraintsInstance);
};

FieldActions.prototype.getAction = function getAction(actionName) {
    return this.actions[actionName];
};

/*
 *  src/treatment/action_treatment.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

var ActionTreatment = function ActionTreatment(constraintInstance) {
    // @private
    this._eventActions = new EventActions();

    // @private
    this._fieldActions = new FieldActions(constraintInstance);
};

/**
 * @param {Object} eventData a dictionary of event data
 * @param {Object} eventConstraints a set of constraints to apply to this event
 * @return {Object} constraints the event data modified according to the appropriate constraints or "null" if the event is blacklisted
 * Note:
 *  1. create a new dictionary if the event data is constrained/modified
 *  2. return the original eventData if the constraints parameter is null or an empty dictionary
 * @example
 * var eventData = {
 *     eventType: 'click',
 *     pageType: 'TopCharts',
 *     parentPageUrl: 'https://itunes.apple.com/music/topcharts/12345',
 *     // etc.
 * };
 * var eventConstraints = {
 *         eventActions: { blacklistedFields: ['cookies', 'pageDetails'] },
 *         fieldActions: {
 *              parentPageUrl: {
 *                  treatmentType: 'urlDeres',
 *                  scope: 'hostname'
 *              }
 *         }
 *     }
 * constraints.eventFields.applyEventConstraints(eventData, eventConstraints) =>
 *     {
 *         eventType: click,
 *         pageType: 'TopCharts',
 *         parentPageUrl: 'itunes.apple.com', // truncated to hostname only
 *         etc... // all other fields remain the same, except "cookies", "pageDetails"
 *     }
 */
ActionTreatment.prototype.applyConstraints = function applyConstraints(eventData, constraints) {
    var returnEventData = eventData; // Set the original eventData to the returning variable to return the original eventData if neither event actions nor field actions were applied.

    if (constraints && !reflect$1.isEmptyObject(constraints)) {
        if (constraints.fieldActions && !reflect$1.isEmptyObject(constraints.fieldActions)) {
            var self = this;
            var changedEventFields = Object.keys(constraints.fieldActions).reduce(function (accumulatedFields, fieldName) {
                var fieldRules = constraints.fieldActions[fieldName];

                if (fieldRules) {
                    var fieldAction = fieldRules.treatmentType;
                    var fieldActionHandler = self._fieldActions.getAction(fieldAction);

                    if (fieldRules.blacklisted) {
                        accumulatedFields[fieldName] = null;
                    } else if (fieldRules.hasOwnProperty(FIELD_RULES.OVERRIDE_FIELD_VALUE)) {
                        accumulatedFields[fieldName] = fieldRules[FIELD_RULES.OVERRIDE_FIELD_VALUE];
                    } else if (fieldActionHandler) {
                        var returnedValue = fieldActionHandler.performAction(fieldName, returnEventData, fieldRules);
                        accumulatedFields[fieldName] = returnedValue;
                    }
                }
                return accumulatedFields;
            }, {});

            // If any field has been constrained, we create a new object to contain the merged fields instead of merging the changes to the original eventData.
            if (!reflect$1.isEmptyObject(changedEventFields)) {
                var mergedEventData = reflect$1.extend({}, returnEventData, changedEventFields);
                returnEventData = event_fields.mergeAndCleanEventFields(mergedEventData);
            }
        }

        // perform event actions after the field actions to ensure removing denied fields or keeping allowed fields for those generated fields(e.g. IdGenerator).
        if (constraints.eventActions && !reflect$1.isEmptyObject(constraints.eventActions)) {
            var eventActionNames = Object.keys(constraints.eventActions);

            eventActionNames.forEach(function (eventAction) {
                var eventActionHandler = this._eventActions.getAction(eventAction);

                if (eventActionHandler) {
                    var actionRules = constraints.eventActions[eventAction];
                    returnEventData = eventActionHandler.performAction(returnEventData, actionRules);
                }
            }, this);
        }
    }

    return returnEventData;
};

/*
 *  src/constraint_generator/treatment_generator.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

var TREATMENT_FILTERS_FIELD = 'filters';
var TREATMENT_FILTERS_ALL = 'any';
var TREATMENT_EVENT_ACTIONS = 'eventActions';
var TREATMENT_FIELD_ACTIONS = 'fieldActions';

function _updateTreatment(accumulatedTreatment, treatment) {
    var currentTreatment = accumulatedTreatment || {};
    // update event actions
    _updateEventActions(currentTreatment, treatment);
    // update field actions
    _updateFieldActions(currentTreatment, treatment);

    return currentTreatment;
}

function _updateEventActions(targetTreatment, sourceTreatment) {
    if (!targetTreatment[TREATMENT_EVENT_ACTIONS]) {
        targetTreatment[TREATMENT_EVENT_ACTIONS] = {};
    }
    var currentTreatmentEventActions = targetTreatment[TREATMENT_EVENT_ACTIONS];
    var treatmentEventActions = sourceTreatment[TREATMENT_EVENT_ACTIONS];

    if (treatmentEventActions) {
        Object.keys(treatmentEventActions).reduce(function (accumulatedEventActions, eventAction) {
            var existingActionValue = accumulatedEventActions[eventAction];
            var actionValue = treatmentEventActions[eventAction];
            // Merge the event action values from different treatments
            if (reflect$1.isArray(existingActionValue)) {
                // If the action value is not an array, treat it as a bad data and discard it.
                if (reflect$1.isArray(actionValue)) {
                    actionValue.forEach(function (value) {
                        if (existingActionValue.indexOf(value) === -1) {
                            existingActionValue.push(value);
                        }
                    });
                }
            } else {
                // Currently only have array type and primitive type parameters. Ignore the other types of parameter values.
                if (reflect$1.isArray(actionValue)) {
                    // Clone the array value, to avoid the original array is changed by other treatments.
                    accumulatedEventActions[eventAction] = actionValue.slice();
                } else if (!reflect$1.isObject(actionValue) && !reflect$1.isFunction(actionValue)) {
                    // primitive type, null and undefined
                    // set the existing action value with the primitive type value.
                    accumulatedEventActions[eventAction] = actionValue;
                }
            }

            return accumulatedEventActions;
        }, currentTreatmentEventActions);
    }
}

function _updateFieldActions(targetTreatment, sourceTreatment) {

    if (!targetTreatment[TREATMENT_FIELD_ACTIONS]) {
        targetTreatment[TREATMENT_FIELD_ACTIONS] = {};
    }
    updateFieldRulesets(targetTreatment, sourceTreatment, TREATMENT_FIELD_ACTIONS, function (targetRules, sourceRules, fieldName) {
        // if the target field rule has the same treatmentType as the source field rule, then return the target field rule to replace its rule props with the source ones.
        // otherwise, all of the source field rules will overwrite all of the target field rules
        if (targetRules[fieldName] && targetRules[fieldName].treatmentType === sourceRules[fieldName].treatmentType) {
            return targetRules[fieldName];
        } else {
            // if the treatmentType is not the same between field rules, return an empty object to take the latter field rules
            /*
                {
                    treatments: [{
                        ...,
                        fieldActions: {
                            afield: { treatmentType: 'a', propA: 123 }
                        }
                    }, {
                        ...,
                        fieldActions: {
                            afield: { treatmentType: 'b', propB: 123 }
                        }
                    }]
                }
                 expected output:
                {
                    treatments: [{
                        ...,
                        fieldActions: {
                            afield: { treatmentType: 'b', propB: 123 }
                        }
                    }]
                }
             */
            return {};
        }
    });
}

var TreatmentGenerator = function TreatmentGenerator(constraintsInstance) {
    // @private
    this._constraintsInstance = constraintsInstance;
    this.treatment = new ActionTreatment(constraintsInstance);
};

/**
 * Combine treatments from multiple profiles
 * @param {Array} ConstraintProfiles the constraint profile names
 * @param {Object} topicConfig An AMP Metrics Config
 * @param {String}(optional) topic defines the AMP Analytics "topic" to look up the constraint profile
 * @returns {Array} An Array of combined treatments from multiple constraint profiles
 * @private
 */
TreatmentGenerator.prototype._combineTreatments = function _combineTreatments(constraintProfiles, topicConfig, topic) {
    var combinedTreatments = [];

    if (reflect$1.isArray(constraintProfiles)) {
        constraintProfiles.forEach(function (constraintProfile) {
            var profileName = 'treatmentProfiles.' + constraintProfile;
            var constraints = topicConfig.value(profileName, topic);

            if (constraints && constraints.treatments) {
                combinedTreatments = combinedTreatments.concat(constraints.treatments);
            }
        });
    }

    return combinedTreatments;
};

/**
 * Build the properly constraints for the passed-in event data
 * @param {Object} eventData a dictionary of event data
 * @param {Object} topicConfig An AMP Metrics Config
 * @param {String}(optional) topic defines the AMP Analytics "topic" to look up the constraint profile
 * @return {Object} a set of constraints to apply to this event.
 *                  returns null (MetricsKit will send the original event) if:
 *                      1. no topic config available
 *                      2. defaultTreatmentProfile is undefined
 *                      3. the profile is found but no treatment matched
 * @throws {TypeError} throws a type error if the topic config contains any invalid element.
 * @throws {SyntaxError} throws a syntax error if:
 *                          1. topicConfig.constraintProfiles(topic) is not found in the topic config
 *                          2. the treatment configuration is invalid
 * @overridable
 * Constraint rules will be applied in the order they are provided in config.
 * @example
 *     Given the following config:
 *     metrics: {
 *         ...
 *         low_res_topic: {
 *            defaultTreatmentProfiles: ['iosStores', 'embeddedWeb'],
 *         },
 *         defaultTreatmentProfiles: ['embeddedWeb']
 *         treatmentProfiles: {
 *            iosStores: { version: 1, treatments: [ ... ] },
 *            embeddedWeb: {
 *              version: 2,
 *              treatments: [
 *                  {
 *                      filters: {
 *                          eventType: { valueMatches: ['enter', 'exit' ] },
 *                          isSignedIn: { valueMatches: [true] }
 *                      },
 *                      eventActions: {
 *                          blacklistedFields: ['cookies']
 *                      }
 *                  },
 *                  {
 *                      filters: {
 *                          eventType: { valueMatches: [ 'exit' ] }
 *                      },
 *                      eventActions: {
 *                          blacklistedFields: ['cookies', 'pageDetails']
 *                      },
 *                      fieldActions: {
 *                          clientId: {
 *                              treatmentType: 'idDeres',
 *                              storageKeyPrefix: 'mtClientId',
 *                              namespace: 'test',
 *                              scopeStrategy: 'mainDomain',
 *                              scopeFieldName: 'https://www.apple.com/products/',
 *                              tokenSeparator: 'z',
 *                              lifespan: 86400000
 *                          }
 *                      }
 *                  },
 *                  {
 *                      filters: {
 *                          userType: { valueMatches: ['signedIn'] },
 *                          actionType: { valueMatches: ['navigate'] }
 *                      },
 *                      fieldActions: {
 *                          os: { blacklisted: true },
 *                          // round down time to 1 day
 *                          eventTime: {
 *                              treatmentType: "numberDeres",
 *                              precision: 86400000
 *                          },
 *                          // remove query params
 *                          pageUrl: {
 *                              treatmentType: "urlDeres",
 *                              scope: 'fullWithoutParams'
 *                          },
 *                          // Deres disk available space round down to MB
 *                          capacityDiskAvailable: {
 *                              treatmentType: "numberDeres",
 *                              precision: 1000000, // 1MB
 *                          },
 *                          clientId: {
 *                              treatmentType: 'idDeres',
 *                              scopeFieldName: 'https://www.apple.com/',
 *                              lifespan: 3600000
 *                          }
 *                      }
 *                  }
 *              ]
 *           }
 *        },
 *        ...
 *    }
 *
 *     constraintsForEvent({ eventType: 'exit', isSignedIn: true, userType: 'signedIn', actionType: 'navigate', ... }, topicConfig) returns:
 *     {
 *         eventActions: {
 *              blacklistedFields: ['cookies', 'pageDetails'] // from "eventType: { valueMatches: [ 'exit' ] }", override the one of "treatments[0]"
 *         },
 *         fieldActions: {
 *              os: { blacklisted: true },
 *              eventTime: {
 *                  treatmentType: "numberDeres",
 *                  precision: 86400000
 *              },
 *              pageUrl: {
 *                  treatmentType: "urlDeres",
 *                  scope: 'fullWithoutParams'
 *              },
 *              capacityDiskAvailable: {
 *                  treatmentType: "numberDeres",
 *                  precision: 1000000, // 1MB
 *              },
 *              clientId: {
 *                  treatmentType: 'idDeres',
 *                  storageKeyPrefix: 'mtClientId',
 *                  namespace: 'test',
 *                  scopeStrategy: 'mainDomain',
 *                  scopeFieldName: 'https://www.apple.com/', // override the value from "treatments[1].clientId"
 *                  tokenSeparator: 'z',
 *                  lifespan: 3600000 // override the value from "treatments[1].clientId"
 *              }
 *         }
 *     }
 */
TreatmentGenerator.prototype.constraintsForEvent = function constraintsForEvent(eventData, topicConfig, topic) {
    if (!topicConfig) {
        return null;
    }
    var self = this;
    var constraintProfiles = topicConfig.constraintProfiles(topic);

    // rdar://71993234 if there is no default treatment profile and the client did not declare a treatment profile, do not modify the event
    if (!reflect$1.isDefinedNonNull(constraintProfiles)) {
        return null;
    }

    if (!reflect$1.isArray(constraintProfiles)) {
        throw new TypeError('"constraintProfiles" should be an Array, but got: ' + (constraintProfiles ? constraintProfiles.constructor : constraintProfiles));
    }

    var combinedTreatments = this._combineTreatments(constraintProfiles, topicConfig, topic);

    // rdar://71993234 if the treatments are not found in the topic config
    if (combinedTreatments.length === 0) {
        throw new SyntaxError('The constraintProfiles: ' + constraintProfiles.join(', ') + ' are not found in the topic config');
    }
    var returnTreatment = combinedTreatments.reduce(function (accumulatedTreatment, treatment) {
        if (self.eventMatchesTreatment(eventData, treatment)) {
            accumulatedTreatment = _updateTreatment(accumulatedTreatment, treatment);
        }
        return accumulatedTreatment;
    }, null);

    return returnTreatment;
};

TreatmentGenerator.prototype.eventMatchesTreatment = function eventMatchesTreatment(eventData, treatment) {
    var filters = treatment[TREATMENT_FILTERS_FIELD];

    // Fast false for free-form filter since JS does not support it at the moment
    // Applying the treatment to all events if the value equals to "any"
    if (filters && reflect$1.isString(filters)) {
        return filters === TREATMENT_FILTERS_ALL;
    }

    // If the filter element does not exist or it is an empty filter list. We consider it is an incorrect config.
    if (!reflect$1.isDefinedNonNull(filters) || filters.length === 0) {
        throw new SyntaxError('Unable to find the filter in \n' + JSON.stringify(treatment));
    }

    return Object.keys(filters).every(function (filterField) {
        var fieldFilters = filters[filterField];

        // Fast false for free-form filter since JS does not support it at the moment
        if (fieldFilters && reflect$1.isString(fieldFilters)) {
            return false;
        }
        // if a field isn't an object or doesn't have any matchers. We consider this is a bad filter and discard the event
        if (!fieldFilters || !reflect$1.isObject(fieldFilters) || reflect$1.isEmptyObject(fieldFilters)) {
            throw new SyntaxError('Invalid filter object for field (' + filterField + ') in \n' + JSON.stringify(treatment));
        }
        // Only return the treatments where all treatments match.
        // Current, only one condition for one field.
        return Object.keys(fieldFilters).every(function (matcherName) {
            var matcherParam = fieldFilters[matcherName];

            if (matchers[matcherName]) {
                return matchers[matcherName](filterField, eventData, matcherParam);
            } else {
                throw new SyntaxError('Unable to find the filter (' + matcherName + ') for field (' + filterField + ')in \n' + JSON.stringify(treatment));
            }
        });
    });
};

/*
 *  src/config.js
 *  mt-client-constraints
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

/**
 * The constraints config delegate
 * Constraints attach this delegate to the topic config to have constraints features on the topic config
 */
var constraintsConfig = {

    /**
     * Return the constraint profile from a config with constraint syntax v1
     * @param {String}(optional) topic defines the AMP Analytics "topic" that this event should be stored under
     * @return {String} the name of the constraint profile from constraint syntax v1 to use
     */
    constraintProfile: function constraintProfile(topic) {
        return this.value('constraints.defaultProfile', topic);
    },

    /**
     * Return the constraint profiles from a config with constraint syntax v2
     * @param {String}(optional) topic defines the AMP Analytics "topic" that this event should be stored under
     * @return {Array} an array of the names of the constraint profile to use
     */
    constraintProfiles: function constraintProfiles(topic) {
        return this.value('defaultTreatmentProfiles', topic);
    }
};

/*
 *  src/index.js
 *  mt-client-constraints
 *
 *  Copyright © 2017-2018 Apple Inc. All rights reserved.
 *
 */

function _validateConfig(config$$1) {
    var isValid = true;

    isValid &= reflect$1.isDefinedNonNull(config$$1);
    if (isValid) {
        isValid &= !reflect$1.isEmptyObject(config$$1);
        isValid &= reflect$1.isFunction(config$$1.initialized);
        isValid &= reflect$1.isFunction(config$$1.value);
        isValid &= reflect$1.isFunction(config$$1.constraintProfile);
    }

    return isValid;
}

/**
 * Return true if the passed-in config is based on constraint syntax v2
 * @param topicConfig
 * @returns {Boolean}
 */
function isTreatmentConfig(topicConfig) {
    return reflect$1.isDefinedNonNull(topicConfig.value('treatmentProfiles'));
}

/**
 * Attaching config related methods for Constraints
 * @param {Config} topicConfig An AMP Metrics Config
 * @returns {Config} the passed-in config with constraint-related methods attached
 */
function connectConstraintConfig(topicConfig) {
    // return the topic config if it has already been attached with the Constraint methods.
    if (reflect$1.isFunction(topicConfig.constraintProfile) && reflect$1.isFunction(topicConfig.constraintProfiles)) {
        return topicConfig;
    }
    reflect$1.attachMethods(topicConfig, constraintsConfig, topicConfig);

    return topicConfig;
}

/**
 * Supplies the single JavaScript entrypoint to constraint functionality
 * Since JavaScript is prototype-based and not class-based, and doesn't provide
 * an "official" object model, this API is presented as a functional API, but
 * still retains the ability to override and customize functionality via the
 * "setDelegate()" method. In this way, it doesn't carry with it the spare
 * baggage of exposing a bolt-on object model which may differ from a bolt-on
 * (or homegrown) object model already existing in the app.
 * @module
 * @param {Object} topicConfig a topic config
 * @param {Object} delegates
 * @constructor
 *
 * @example
 * import * as delegates from '@amp-metrics/mt-metricskit-delegates-html';
 * import Constraints, { connectConstraintConfig } from '@amp-metrics/mt-client-constraints';
 * import Config from '@amp-metrics/mt-client-config';
 *
 * const topicConfig = new Config('topic');
 * connectConstraintConfig(topicConfig);
 *
 * var eventData = {...};
 * var constraints = new Constraints(topicConfig, delegates);
 * var constrainedEventData = constraints.applyConstraintTreatments(eventData);
 */
var Constraints = function Constraints(topicConfig, delegate) {

    if (!_validateConfig(topicConfig)) {
        throw new Error('The topic config is not a valid instance of "mt-client-config".');
    }

    // @private
    this._isInitialized = false;

    // @private
    this._topicConfig = topicConfig;

    /**
     * constraint generator for specific topic config
     * @type {ConstraintGenerator}
     */
    // @private
    this._constraintGenerator = null;

    /**
     * system/platform-specific classes
     */
    this.system = new System$1();

    reflect$1.setDelegates(this.system, delegate || {});
};

/**
 * get constraint generator by the topic config
 * @param {Object} topicConfig
 * @returns {Object} the active constraint generator
 */
Constraints.prototype._getConstraintGenerator = function _getConstraintGenerator() {
    // TODO return a Promise when supporting the asynchronization config.
    /*
     *  return new Promise((resolve) => {
     *      if (reflect.isDefinedNonNull(this._topicConfig.value('constraints'))) {
     *          this._constraintGenerator = new LegacyConstraintGenerator(this);
     *      } else {
     *          this._constraintGenerator = new TreatmentGenerator(this);
     *      }
     *      resolve(this._constraintGenerator);
     *  }.bind(this));
     */
    var topicConfig = this._topicConfig;
    if (!this._constraintGenerator || !this._isInitialized) {
        this._isInitialized = topicConfig.initialized();
        if (isTreatmentConfig(topicConfig)) {
            this._constraintGenerator = new TreatmentGenerator(this);
        } else {
            this._constraintGenerator = new LegacyConstraintGenerator(this);
        }
    }
    return this._constraintGenerator;
};

/**
 * Build constraints with the eventData
 * @param {Object} eventData a dictionary of event data
 * @param {String}(optional) topic defines the AMP Analytics "topic" that this event should be stored under
 * @return {Object} constraints a set of constraints to apply to this event
 * @throws {SyntaxError/TypeError} throws a type error if the topic config contains any invalid element.
 */
Constraints.prototype.constraintsForEvent = function constraintsForEvent(eventData, topic) {
    return this._getConstraintGenerator().constraintsForEvent(eventData, this._topicConfig, topic);
};

/**
 * Apply the given eventData with associated constraints
 * @param {Object} eventData a dictionary of event data
 * @param {Object}(optional) constraints a set of constraints to apply to this event
 * @returns {Object|null} return performed event Data with the given constraints or null if the event is blacklisted or should be discard
 */
Constraints.prototype.applyConstraintTreatments = function applyConstraints(eventData, constraints) {
    if (constraints === undefined) {
        // constraintsForEvent returns null for none of constraints.
        try {
            constraints = this.constraintsForEvent(eventData);
        } catch (e) {
            this.system.logger.warn('An error occupied while applying constraints: ' + e.message || e);
            return null;
        }
    }
    return this._getConstraintGenerator().treatment.applyConstraints(eventData, constraints);
};

var info = { "version": "7.3.0", "name": "mt-metricskit" };

/*
 *  src/metrics/utils/delegate_extension.js
 *  mt-metricskit
 *
 *  Copyright © 2016 Apple Inc. All rights reserved.
 *
 */
/*
 * Delegate info functions to be used by _utils.reflect.attachDelegate
 */
var delegateInfo = {
    /**
     * Returns the name of this repository
     * Used by _utils.reflect.attachDelegate to create
     * a delegate dependence tree for the optional
     * base field, xpDelegatesInfo
     * @returns {String} Name of this repository
     */
    mtName: function mtName() {
        return info.name;
    },
    /**
     * Returns version of this repo
     * Used by _utils.reflect.attachDelegate to create
     * a delegate dependence tree for the optional
     * base field, xpDelegatesInfo
     * @returns {String} Version of this repo
     */
    mtVersion: function mtVersion() {
        return info.version;
    }
};

/**
 * Delegate-related functions (intended to eventually contain
 * all needed functions to be delegateable, like 'setDelegate')
 * @constructor
 */
var delegateExtension = {
    /**
     * Adds delegate info methods to the target (delegateable) object
     * @param {Object} targetObj Delegateable object to attach info methods to
     */
    attachDelegateInfo: function attachDelegateInfo(targetObj) {
        reflect$1.extend(targetObj, delegateInfo);
    }
};

/*
 *  src/merics/config.js
 *  mt-metricskit
 *
 *  Copyright © 2015-2016 Apple Inc. All rights reserved.
 *
 */

// attach metrics convenience functions to the Config singleton
reflect$1.attachMethods(Config, config, Config);

/**
 * Extend the metrics config instance with convenience functions and delegate info
 * This should be done for every config instance that MetricsKit uses:
 * once for the default config, and once for the topic-specific config if metrics.init() is used
 * @param {Config} configInstance
 */
var _initializeConfig = function _initializeConfig(configInstance) {
    reflect$1.attachMethods(configInstance, config, configInstance);
    connectConstraintConfig(configInstance);
    delegateExtension.attachDelegateInfo(configInstance);
};

/**
 *
 * @param topicConfig
 * @param options The properties of config class. All props are optional.
 *  {
 *      configSourcesFn,
 *      onSuccessHandler,
 *      onFailureHandler
 *      delegates: {
 *          environment,
 *          network,
 *          logger
 *      }
 *  }
 */
function initializeConfig(topicConfig, options) {
    options = options || {};
    var delegates = options.delegates || {};
    var configSourcesFn = options.configSourcesFn;
    var onSuccessHandler = options.onSuccessHandler;
    var onFailureHandler = options.onFailureHandler;
    var environmentDelegate = delegates.environment;
    var networkDelegate = delegates.network;
    var loggerDelegate = delegates.logger;

    // TODO mt-client-config v1.x does not support set below delegates. We have to delegate them to the static corresponding objects.
    Config.environment.setDelegate(environmentDelegate);
    Config.logger.setDelegate(loggerDelegate);
    Config.network.setDelegate(networkDelegate);
    _initializeConfig(topicConfig);

    topicConfig.init(configSourcesFn, onSuccessHandler, onFailureHandler);
}

function cleanupConfig(topicConfig) {
    Config.cleanupConfig(topicConfig.topic());
    // these objects will become instance objects in mt-client-config v2.0 and will be taken care in the config.cleanup()
    reflect$1.detachMethods(Config.environment);
    reflect$1.detachMethods(Config.logger);
    reflect$1.detachMethods(Config.network);
}

/*
 *  src/metrics/utils/constants.js
 *  mt-metricskit
 *
 *  Copyright © 2019 Apple Inc. All rights reserved.
 *
 */

// These constants are used internally but not exposed publicly
var constants = {
    FIELD_NAMES: {
        CLIENT_EVENT_ID: 'clientEventId',
        CONSUMER_ID: 'consumerId',
        CONSUMER_NS: 'consumerNs',
        DELEGATE_APP: 'delegateApp',
        EVENT_VERSION: 'eventVersion',
        STOREFRONT_COUNTRY_CODE: 'storeFrontCountryCode'
    },
    REQUIRED_ENVIRONMENT_BASE_FIELD_NAMES: ['app', 'appVersion', 'capacityData', 'capacityDataAvailable', 'capacityDisk', 'capacitySystem', 'capacitySystemAvailable', 'connectionType', 'dsId', 'hostApp', 'osVersion', 'pageUrl', 'pixelRatio', 'resourceRevNum', 'screenHeight', 'screenWidth', 'storeFrontHeader', 'userAgent', 'userType', 'windowInnerHeight', 'windowInnerWidth', 'windowOuterHeight', 'windowOuterWidth'],
    OPTIONAL_ENVIRONMENT_BASE_FIELD_NAMES: ['consumerId', 'consumerNs', 'cookie', 'delegateApp', 'environmentInstance', 'hardwareBrand', // Consider adding an exception in the next major version.
    'hardwareFamily', // Consider adding an exception in the next major version.
    'hardwareModel', // Consider adding an exception in the next major version.
    'hostAppVersion', 'os', // Consider adding an exception in the next major version.
    'osBuildNumber', // Consider adding an exception in the next major version.
    'osLanguages', // Consider adding an exception in the next major version.
    'parentPageUrl', 'storeFrontCountryCode' // Consider adding an exception in the next major version.
    ]
};

/*
 *  src/metrics/system/environment.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

var exceptionString = string$1.exceptionString;
var REQUIRED_ENVIRONMENT_BASE_FIELD_NAMES = constants.REQUIRED_ENVIRONMENT_BASE_FIELD_NAMES;
var OPTIONAL_ENVIRONMENT_BASE_FIELD_NAMES = constants.OPTIONAL_ENVIRONMENT_BASE_FIELD_NAMES;
var _prototypeInitialized = false;
var noOp = function noOp() {};

/**
 * Provides a set of environment-specific (platform-specific) functions which can be individually overridden for the needs
 * of the particular environment, or replaced en masse by providing a single replacement environment delegate object
 * The functionality in this class is typically replaced via a delegate.
 * DEFAULT implementation: console logging
 * @see setDelegate
 * @delegatable
 * @constructor
 */
var Environment$3 = function Environment() {
    if (!_prototypeInitialized) {
        _prototypeInitialized = true;
        REQUIRED_ENVIRONMENT_BASE_FIELD_NAMES.forEach(function (fieldName) {
            Environment.prototype[fieldName] = function () {
                throw exceptionString('metrics.system.environment', fieldName);
            };
        });

        OPTIONAL_ENVIRONMENT_BASE_FIELD_NAMES.forEach(function (fieldName) {
            Environment.prototype[fieldName] = noOp;
        });
    }
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Environment$3.prototype.setDelegate = function setDelegate(delegate) {
    // This is a bit of a cheat, but it allows us to not force our users to have a whole delegate just for cookies...
    // we let them merge it in with their environment delegate:
    cookies.setDelegate(delegate);
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * The app identifier of the binary app
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "com.apple.appstore" or "com.apple.gamecenter"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.app = function app() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The version number of this application
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "1.0", "5.43", etc.
 * @returns {String}
 * @overridable
 * @defaultimpl navigator.appVersion
 */
// Environment.prototype.appVersion = function appVersion() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The total data capacity of the system, without regard for what's already been used or not.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @returns {number}
 * @overridable
 */
// Environment.prototype.capacityData = function capacityData() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The total available data capacity of the system.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @returns {number}
 * @overridable
 */
// Environment.prototype.capacityDataAvailable = function capacityDataAvailable() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The total disk capacity of the system, without regard for what's already been used or not.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @returns {number}
 * @overridable
 */
// Environment.prototype.capacityDisk = function capacityDisk() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The total system capacity, without regard for what's already been used or not.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @returns {number}
 * @overridable
 */
// Environment.prototype.capacitySystem = function capacitySystem() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The total available system capacity of the system.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @api public
 * @overridable
 */
// Environment.prototype.capacitySystemAvailable = function capacitySystemAvailable() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * Type of internet connection.
 * Only applicable to devices
 * Beware that users on WiFi may actually be receiving 3G speeds (i.e. if device is tethered to a portable hotspot.)
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "WiFi, "3G, etc.
 * @returns {String}
 * @overridable
 */
// Environment.prototype.connectionType = function connectionType() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * A user identifier that can be mapped to a DSID
 * consumerId and consumerNs are only required for platforms (e.g. web) that cannot report DSID
 * NO DEFAULT IMPLEMENTATION... HOWEVER: these fields are not required, so an exception will not be thrown if they
 * are omitted.
 * @example 'c683765738654a23ae34ab09d6f06a0c003'
 * @returns {String}
 * @overridable
 */
// Environment.prototype.consumerId = function consumerId() {
//     // Optional field value
// };

/**
 * The namespace of the consumer ID
 * consumerId and consumerNs are only required for platforms (e.g. web) that cannot report DSID
 * NO DEFAULT IMPLEMENTATION... HOWEVER: these fields are not required, so an exception will not be thrown if they
 * are omitted.
 * @example 'TV'
 * @returns {String}
 * @overridable
 */
// Environment.prototype.consumerNs = function consumerNs() {
//     // Optional field value
// };

/**
 * The object that owns "cookies", e.g. "document" (standard browser), "iTunes" (iTunes desktop), "itms" (itml app)'
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * DEFAULT: an attempt will be made to try to find a "cookie" object off of "iTunes", "itms", and "document"
 * @returns {Object}
 * @overridable
 */
// Environment.prototype.cookieOwnerObject = function cookieOwnerObject() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };


/**
 * The identifier of the process generating the event, if different from “app”, or blank otherwise.
 * NO DEFAULT IMPLEMENTATION... HOWEVER: these fields are not required, so an exception will not be thrown if they
 * are omitted.
 * @example 'web-experience-app'
 * @returns {String}
 * @overridable
 */
// Environment.prototype.delegateApp = function delegateApp() {
//     // Optional field value
// };

/**
 * The id of this user ("directory service id").
 * This id will get anonymized on the server prior to being saved.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 659261189
 * @returns {String}
 * @overridable
 */
// Environment.prototype.dsId = function dsId() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The running application instance number of the software on the server that served the page data for the current page.
 * This field helps to analyze idiosyncracies of user behavior based on server data, as well as to identify  anomolies based on server info.
 * Though this data is page-specific, it is convenient to incorporate it until all events as a "base field" for
 * simpler analyses. This may change in the future.
 * These values can be found in the Store "Bag" but those values really describe the MZInit instance that served
 * the bag, not the server that served the current page data, so this method should be overwritten by a delegate.
 * NOTE: In the future, these names may change to begin with the more understandable prefix of "server", per <rdar://problem/23082819> Rename various Figaro Fields
 * NO DEFAULT IMPLEMENTATION... HOWEVER: these fields are not required, so an exception will not be thrown if they
 * are omitted.
 * @example 1006
 * @returns {String}
 * @overridable
 */
// Environment.prototype.environmentInstance = function environmentInstance() {
//     // Optional field value
// };

/**
 * The hardware brand of the device. Not required for Apple devices.
 * @example "Samsung", "LG", "Google"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.hardwareBrand = function hardwareBrand() {
//     // Don't throw an exception to avoid breaking minor version backwards compatibility.
//     // Consider adding an exception in the next major version.
// };


/**
 * The hardware family of the device
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "iPhone", "Macbook Pro"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.hardwareFamily = function hardwareFamily() {
//     // Don't throw an exception to avoid breaking minor version backwards compatibility.
//     // Consider adding an exception in the next major version.
// };

/**
 * The model of the device
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "iPhone10,2", "MacbookPro11,5"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.hardwareModel = function hardwareModel() {
//     // Don't throw an exception to avoid breaking minor version backwards compatibility.
//     // Consider adding an exception in the next major version.
// };

/**
 * App that is hosting the storesheet or app
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example com.rovio.AngryBirds
 * @returns {String}
 * @overridable
 */
// Environment.prototype.hostApp = function hostApp() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * Version of the app that is hosting the storesheet or app
 * NO DEFAULT IMPLEMENTATION... HOWEVER: these fields are not required, so an exception will not be thrown if they
 * are omitted.
 * @example "1.0.1"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.hostAppVersion = function hostAppVersion() {
//     // Optional field value
// };

/**
 * The name of the OS
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "ios", "macos", "windows"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.os = function os() {
//     // Don't throw an exception to avoid breaking minor version backwards compatibility.
//     // Consider adding an exception in the next major version.
// };

/**
 * The build number of the OS
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "15D60", "17E192"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.osBuildNumber = function osBuildNumber() {
//     // Don't throw an exception to avoid breaking minor version backwards compatibility.
//     // Consider adding an exception in the next major version.
// };

/**
 * A string array of language IDs, ordered in descending preference
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example ["en-US", "fr-CA"]
 * @returns {Array}
 * @overridable
 */
// Environment.prototype.osLanguages = function osLanguages() {
//     // Don't throw an exception to avoid breaking minor version backwards compatibility.
//     // Consider adding an exception in the next major version.
// };

/**
 * The full OS version number
 * In ITML, the value can be retrieved via Device.systemVersion
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "8.2.1" (iOS) "10.10.3" (Desktop)
 * @returns {String}
 * @overridable
 */
// Environment.prototype.osVersion = function osVersion() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The URL that represents this page.
 * Typically this is a "deep link" type URL.
 * If no URL is available, this field may be omitted.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewGrouping?cc=us&mt=8"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.pageUrl = function pageUrl() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The URL of the parent page, if the app is embedded in a parent context.
 * Typically this is a "deep link" type URL.
 * If no URL is available, or if the app is not embedded, this field may be omitted.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED IF THE APP IS EMBEDDED IN A PARENT CONTEXT
 * @example "https://www.apple.com/blog/top-tracks.html"
 * @returns {String}
 * @overridable
 */
// Environment.prototype.parentPageUrl = function parentPageUrl() {
//     // Value only required if the app is embedded in a parent context
// };

/**
 * Pixel multiplier factor
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 2
 * @returns {number}
 * @overridable
 */
// Environment.prototype.pixelRatio = function pixelRatio() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * HTML resources revision number
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 2C97 or 8.4.0.0.103
 * @returns {String}
 * @overridable
 */
// Environment.prototype.resourceRevNum = function resourceRevNum() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * Client screen height in pixels
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 568
 * @returns {number}
 * @overridable
 */
// Environment.prototype.screenHeight = function screenHeight() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * Client screen width in pixels
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 320
 * @returns {number}
 * @overridable
 */
// Environment.prototype.screenWidth = function screenWidth() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * ISO 3166 Country Code. Apps that cannot provide a storeFrontHeader should provide a storeFrontCountryCode instead
 * NO DEFAULT IMPLEMENTATION... Either this method or storeFrontHeader must be replaced.
 * @example US
 * @param {Map} callerSuppliedEventFields
 * @returns {String} the store front country code
 * @overridable
 */
// Environment.prototype.storeFrontCountryCode = function storeFrontCountryCode() {
//     // Don't throw an exception to avoid breaking minor version backwards compatibility.
//     // Consider adding an exception in the next major version.
// };

/**
 * The value contained in the X-Apple-Store-Front header value at the time the event is being created.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example K143441-1,29 ab:rSwnYxS0
 * @returns {String}
 * @overridable
 */
// Environment.prototype.storeFrontHeader = function storeFrontHeader() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * Client’s user agent string.  If the "app field is not provided, "userAgent may be used to derive the value of the "app field
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example AppStore/2.0 iOS/8.3 model/iPhone7,2 build/12F70 (6; dt:106)
 * @returns {String}
 * @overridable
 */
// Environment.prototype.userAgent = function userAgent() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * The type of subscriber this user is.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example subscribed, notSubscribed, unknown, needsAuthentication
 * @returns {String}
 * @overridable
 */
// Environment.prototype.userType = function userType() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * App viewport height in pixels.  Does not include window “chrome”, status bars, etc.
 * Typically only available on desktop windowing systems.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 1920
 * @returns {number/undefined}
 * @overridable
 */
// Environment.prototype.windowInnerHeight = function windowInnerHeight() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * App viewport width in pixels.  Does not include window “chrome”, status bars, etc.
 * Typically only available on desktop windowing systems.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 1080
 * @returns {number/undefined}
 * @overridable
 */
// Environment.prototype.windowInnerWidth = function windowInnerWidth() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * Height in pixels of containing window, encompassing app viewport as well as window chrome, status bars, etc.
 * Typically only available on desktop windowing systems.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 1080
 * @returns {number/undefined}
 * @overridable
 */
// Environment.prototype.windowOuterHeight = function windowOuterHeight() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * Width in pixels of containing window, encompassing app viewport as well as window chrome, status bars, etc.
 * Typically only available on desktop windowing systems.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example 1920
 * @returns {number/undefined}
 * @overridable
 */
// Environment.prototype.windowOuterWidth = function windowOuterWidth() {
//     // Don't wrap this in a helper function or the backtrace won't be as nice.
//     exceptionStringTemplate[1] = reflect.functionName();
//     throw exceptionStringTemplate.join("");
// };

/**
 * Some clients have platform-specific implementations of these objects (e.g. iTunes.sessionStorage), so we cover them in case they need to be overridden.
 */
Environment$3.prototype.localStorageObject = storage.localStorageObject;
Environment$3.prototype.sessionStorageObject = storage.sessionStorageObject;

/*
 *  src/metrics/system/event_recorder.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Provides a replaceable "recordEvent" function to enqueue events to be sent to the metrics server.
 * The functionality in this class is typically replaced via a delegate.
 * DEFAULT implementation: error logged via logger.
 * @see setDelegate
 * @delegatable
 * @constructor
 */
var EventRecorder = function EventRecorder() {};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
EventRecorder.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Enqueues a JSON an event as JSON
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @param {String} topic defines the Figaro "topic" that this event should be stored under
 * @param {Object} eventFields a JavaScript object which will be converted to a JSON string and enqued for sending to Figaro according to the postFrequency schedule.
 * @returns {Object} the recorded event, or "null" if no object was recorded (e.g. if "eventFields" is null, or "disabled" is true, eventFields.eventType is one of the blacklistedEvents, etc.)
 * @overridable
 */
EventRecorder.prototype.recordEvent = function recordEvent(topic, eventFields$$1) {
    // Don't wrap this in a helper function or the backtrace won't be as nice.
    throw string$1.exceptionString('metrics.system.event_recorder', 'recordEvent');
};

/**
 * The methodology being used to send batches of events to the server
 * This field should be hardcoded in the client based on what method it is using to encode and send its events to Figaro.
 * The three typical values are:
 *      "itms" - use this value when/if JavaScript code enqueues events for sending via the "itms.recordEvent()" method in ITML.
 *      "itunes" - use this value when/if JavaScript code enqueues events by calling the "iTunes.recordEvent()" method in Desktop Store apps.
 *      "javascript" - use this value when/if JavaScript code enqueues events for sending via the JavaScript eventQueue management. This is typically only used by older clients which don't have the built-in functionality of itms or iTunes available to them.
 * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
 * @example "itms", "itunes", "javascript"
 * @returns {String}
 * @overridable
 */
EventRecorder.prototype.sendMethod = function sendMethod() {
    // Don't wrap this in a helper function or the backtrace won't be as nice.
    throw string$1.exceptionString('metrics.system.event_recorder', 'sendMethod');
};

/**
 * Sends any remaining events in the queue, then clears it
 * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED IF THE DELEGATE ENVIRONMENT SUPPORTS IT
 * @param {Boolean} appIsExiting - if events are being flushed due to your app exiting (or page going away for web-apps), pass "true".
 *                  This allows MetricsKit to modify its flush strategy to attempt to post events prior to actual termination.
 *                  In cases where appIsExiting==false, the parameter may be omitted.
 */
EventRecorder.prototype.flushUnreportedEvents = function flushUnreportedEvents(appIsExiting) {};

/*
 *  src/metrics/system/logger.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */
var logger = loggerNamed('mt-metricskit');

/*
 *  src/metrics/system/index.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

var System = function System() {
    this.environment = new Environment$3();
    this.eventRecorder = new EventRecorder();
    this.logger = logger;

    for (var key in this) {
        delegateExtension.attachDelegateInfo(this[key]);
    }
};

/*
 *  src/metrics/event_handlers/account.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Account = function Account(metricsKit) {
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Account.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @example a "hint", "related" click, "filter" click, etc.
 * If this event is representing a plain typed account, this field's value may be null
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, element, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}; someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Account.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    return this._metricsKit.eventHandlers.base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Account.prototype.knownFields = function knownFields() {
    var knownFields = ['eventType', 'eventVersion', 'type'];

    return knownFields;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Account.prototype.eventType = function (callerSuppliedEventFields) {
    return 'account';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Account.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 1;
};

/*
 *  src/metrics/event_handlers/base.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

var FIELD_NAMES$1 = constants.FIELD_NAMES;

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the "base" fields common to all metrics events.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Base$1 = function Base$1(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Base$1.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the "base" fields required by Figaro
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each *known* field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.base.metricsData(appData.pageId, appData.pageType, appData.pageContext, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}; someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all "page" fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Base$1.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var argumentsArray = Array.prototype.slice.call(arguments);
    var configBaseFields = this._metricsKit.config.value('metricsBase');
    if (configBaseFields) {
        argumentsArray.push(configBaseFields);
    }
    return this.processMetricsData.apply(this, argumentsArray);
};

/**
 * All of the various eventHandlers invoke this method to generate their metrics data
 * The data is a simple map object (dictionary) with all the fields required by Figaro for that event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * This function expects to be called with the correct context (eg base.processMetricsData.apply(this, arguments))
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * This method will check for any disabled/blacklisted events or fields, add base fields, and process/merge all data
 * @returns {Object} key/value pairs of all "page" fields + "base" fields required by Figaro
 * WARNING: May return "null" if metrics and/or the specific eventType for this handler is disabled, or on error.
 */
Base$1.prototype.processMetricsData = function processMetricsData(pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs) */) {
    var eventFields$$1 = null;
    var eventType = typeof this.eventType == 'function' ? this.eventType() : null;
    var config$$1 = this._metricsKit.config;
    var base = this._metricsKit.eventHandlers.base;
    var utils$$1 = this._metricsKit.utils;
    var constraints = this._metricsKit._constraints;

    if (!config$$1.metricsDisabledOrBlacklistedEvent(eventType)) {
        var externalHandler = this !== base;
        var includeBaseFields = typeof this.mtIncludeBaseFields == 'function' ? this.mtIncludeBaseFields() : true;
        var callerSuppliedEventFieldsMapsArray = Array.prototype.slice.call(arguments, 3);

        // Add in our base fields before we process our data, in case any of our accessor methods needs base field info (like the value of "page").
        // Make sure to add the base fields before adding any other fields, so the base fields get overridden by any identically named page fields
        // If we are not being called by the base event handler, we will recursively call ourselves to get the base fields
        if (externalHandler && includeBaseFields) {
            var baseFields = base.metricsData.apply(base, arguments);
            callerSuppliedEventFieldsMapsArray = [baseFields].concat(callerSuppliedEventFieldsMapsArray);
        }
        eventFields$$1 = utils$$1.eventFields.processMetricsData(this, this.knownFields(), pageId, pageType, pageContext, callerSuppliedEventFieldsMapsArray);
        if (externalHandler) {
            // only apply these filters once
            eventFields$$1 = constraints.applyConstraintTreatments(eventFields$$1);
            config$$1.removeBlacklistedFields(eventFields$$1);
            config$$1.applyDeRes(eventFields$$1);
        }
    }

    return eventFields$$1;
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Base$1.prototype.knownFields = function knownFields() {
    var knownFields = ['app', 'appVersion', 'baseVersion', 'capacityData', 'capacityDataAvailable', 'capacityDisk', 'capacitySystem', 'capacitySystemAvailable', 'connection', 'constraintProfile', 'constraintProfiles', FIELD_NAMES$1.CONSUMER_ID, FIELD_NAMES$1.CONSUMER_NS, FIELD_NAMES$1.CLIENT_EVENT_ID, 'clientId', FIELD_NAMES$1.DELEGATE_APP, 'dsId', 'environmentInstance', 'eventTime', 'isSignedIn', 'hardwareBrand', 'hardwareFamily', 'hardwareModel', 'hostApp', 'hostAppVersion', 'os', 'osBuildNumber', 'osVersion', 'page', 'pageContext', 'pageDetails', 'pageId', 'pageType', 'pageUrl', 'parentPageUrl', 'pixelRatio', 'resourceRevNum', 'screenHeight', 'screenWidth', FIELD_NAMES$1.STOREFRONT_COUNTRY_CODE, 'storeFrontHeader', 'timezoneOffset', 'userAgent', 'userType', 'windowInnerHeight', 'windowInnerWidth', 'windowOuterHeight', 'windowOuterWidth', 'xpPostFrequency', 'xpSendMethod', 'xpVersionMetricsKit', 'xpDelegatesInfo'];

    return knownFields;
};

// ********************* ACCESSOR FUNCTIONS *********************
/**
 * We create accessor functions for every data field because:
 * 1. Cleans/simplifies all methods that use it.
 * 2. Facilitates writing test case shims
 * 3. Allows specific feature suppliers to be overridden (via setDelegate()))
 */

/**
 * The app identifier of the binary app
 * This method is typically called from the "metricsData()" method.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} The app identifier of the binary app
 * @example "com.apple.appstore" or "com.apple.gamecenter"
 * @overridable
 */
Base$1.prototype.app = function app(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.app || environment.app();
};

/**
 * The version number of this application
 * @example "1.0", "5.43", etc.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the version number of this application
 * @overridable
 */
Base$1.prototype.appVersion = function appVersion(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.appVersion || environment.appVersion();
};

/**
 * The version of the set of base data to be sent up
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the version of the set of base data to be sent up
 * @overridable
 */
Base$1.prototype.baseVersion = function baseVersion(callerSuppliedEventFields) {
    return 1;
};

/**
 * The total data capacity of the system, without regard for what's already been used or not.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the total data capacity of the system, without regard for what's already been used or not
 * @overridable
 */
Base$1.prototype.capacityData = function capacityData(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.capacityData || environment.capacityData();
};

/**
 * The total available data capacity of the system.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the total available data capacity of the system
 * @overridable
 */
Base$1.prototype.capacityDataAvailable = function capacityDataAvailable(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.capacityDataAvailable || environment.capacityDataAvailable();
};

/**
 * The total disk capacity of the system, without regard for what's already been used or not.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the total disk capacity of the system, without regard for what's already been used or not
 * @overridable
 */
Base$1.prototype.capacityDisk = function capacityDisk(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.capacityDisk || environment.capacityDisk();
};

/**
 * The total system capacity, without regard for what's already been used or not.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the total system capacity, without regard for what's already been used or not.
 * @overridable
 */
Base$1.prototype.capacitySystem = function capacitySystem(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.capacitySystem || environment.capacitySystem();
};

/**
 * The total available system capacity of the system.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the total available system capacity of the system
 * @overridable
 */
Base$1.prototype.capacitySystemAvailable = function capacitySystemAvailable(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.capacitySystemAvailable || environment.capacitySystemAvailable();
};

/**
 * Type of internet connection.
 * Only applicable to devices
 * Beware that users on WiFi may actually be receiving 3G speeds (i.e. if device is tethered to a portable hotspot.)
 * @example "WiFi, "3G, etc.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} type of internet connection
 * @overridable
 */
Base$1.prototype.connection = function connection(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.connection || environment.connectionType();
};

/**
 * The name of the constraint profile used to apply constraints to fields within an event.
 * @example "strict"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String}
 * @overridable
 */
Base$1.prototype.constraintProfile = function constraintProfile(callerSuppliedEventFields) {
    var config$$1 = this._metricsKit.config;
    return callerSuppliedEventFields && callerSuppliedEventFields.constraintProfile || config$$1.constraintProfile();
};

/**
 * The names of the constraint profiles used to apply constraints to fields within an event.
 * NOTE: This method returns the constraint profiles that are used for Constraints v2 syntax. The constraintProfile() returns the profile that is used for Constraints v1 syntax
 * @example "[strict]"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String}
 * @overridable
 */
Base$1.prototype.constraintProfiles = function constraintProfiles(callerSuppliedEventFields) {
    var config$$1 = this._metricsKit.config;
    return callerSuppliedEventFields && callerSuppliedEventFields.constraintProfiles || config$$1.constraintProfiles();
};

/**
 * A user identifier that can be mapped to a DSID
 * consumerId and consumerNs are only required for platforms (e.g. web) that cannot report DSID
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @example 'c683765738654a23ae34ab09d6f06a0c003'
 * @returns {String}
 * @overridable
 */
Base$1.prototype.consumerId = function consumerId(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields[FIELD_NAMES$1.CONSUMER_ID] || environment.consumerId();
};

/**
 * The namespace of the consumer ID
 * consumerId and consumerNs are only required for platforms (e.g. web) that cannot report DSID
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @example 'TV'
 * @returns {String}
 * @overridable
 */
Base$1.prototype.consumerNs = function consumerNs(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields[FIELD_NAMES$1.CONSUMER_NS] || environment.consumerNs();
};

/**
 * A unique identifier for each event
 * @returns {String}
 * @overridable
 */
Base$1.prototype.clientEventId = function clientEventId(callerSuppliedEventFields) {
    var eventId = callerSuppliedEventFields && callerSuppliedEventFields[FIELD_NAMES$1.CLIENT_EVENT_ID];
    if (!eventId) {
        if (string$1.cryptoRandomBase62String) {
            eventId = string$1.cryptoRandomBase62String(true);
        }
        if (!eventId) {
            eventId = string$1.uuid();
        }
    }
    return eventId;
};

/**
 * Return the value of the "xp_ci" cookie
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the value of the "xp_ci" cookie
 * @overridable
 */
Base$1.prototype.clientId = function clientId(callerSuppliedEventFields) {
    var clientId;
    var config$$1 = this._metricsKit.config;

    if (callerSuppliedEventFields && callerSuppliedEventFields.clientId) {
        clientId = callerSuppliedEventFields.clientId;
    } else if (!config$$1.value('ignoreClientIdCookie')) {
        clientId = cookies.get('xp_ci');
    }

    return clientId;
};

/**
 * The identifier of the process generating the event, if different from “app”, or blank otherwise.
 * @example 'web-experience-app'
 * @returns {String}
 * @overridable
 */
Base$1.prototype.delegateApp = function delegateApp(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields[FIELD_NAMES$1.DELEGATE_APP] || environment.delegateApp();
};

/**
 * The id of this user ("directory service id").
 * This id will get anonymized on the server prior to being saved.
 * @example 659261189
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the id of this user ("directory service id").
 * @overridable
 */
Base$1.prototype.dsId = function dsId(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.dsId || environment.dsId();
};

/**
 * Whether or not the user is signed in
 * @example true, false
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {boolean} true if the user is signed in (app has access to dsid), false if not
 * @overridable
 */
Base$1.prototype.isSignedIn = function isSignedIn(callerSuppliedEventFields) {
    return callerSuppliedEventFields && 'isSignedIn' in callerSuppliedEventFields ? callerSuppliedEventFields.isSignedIn : !!this.dsId(callerSuppliedEventFields);
};

/**
 * The time (UTC) in milliseconds at which this event happened.
 * This field is central to determining the sequence of user events
 * Use online epoch converter to test your values.
 * @example 1437356433388 (http://www.epochconverter.com converts that to:  July 19, 2015 at 6:40:33 PM PDT GMT-7:00 DST)
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the time (UTC) in milliseconds at which this event happened
 * @overridable
 */
Base$1.prototype.eventTime = function eventTime(callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventTime || Date.now();
};

/**
 * The hardware brand of the device. Not required for Apple devices.
 * @example "Samsung", "LG", "Google"
 * @param {Map} callerSuppliedEventFields
 * @returns {String}
 * @overridable
 */
Base$1.prototype.hardwareBrand = function hardwareBrand(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.hardwareBrand || environment.hardwareBrand();
};

/**
 * The hardware family of the device
 * @example "iPhone", "Macbook Pro"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the hardware family of the device
 * @overridable
 */
Base$1.prototype.hardwareFamily = function hardwareFamily(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.hardwareFamily || environment.hardwareFamily();
};

/**
 * The model of the device
 * @example "iPhone10,2", "MacbookPro11,5"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the hardware family of the device
 * @overridable
 */
Base$1.prototype.hardwareModel = function hardwareModel(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.hardwareModel || environment.hardwareModel();
};

/**
 * The application that is hosting the page or store sheet
 * @example com.rovio.angrybirds
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String}
 * @overridable
 */
Base$1.prototype.hostApp = function hostApp(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.hostApp || environment.hostApp();
};

/**
 * The version of the application that is hosting the page or store sheet
 * @example "1.0.1"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String}
 * @overridable
 */
Base$1.prototype.hostAppVersion = function hostAppVersion(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.hostAppVersion || environment.hostAppVersion();
};

/**
 * The name of the OS
 * @example "ios", "macos", "windows"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the OS name
 * @overridable
 */
Base$1.prototype.os = function os(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.os || environment.os();
};

/**
 * The build number of the OS
 * @example "15D60", "17E192"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the build number of the OS
 * @overridable
 */
Base$1.prototype.osBuildNumber = function osBuildNumber(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.osBuildNumber || environment.osBuildNumber();
};

/**
 * The full OS version number
 * In ITML, the value can be retrieved via Device.systemVersion
 * @example "8.2.1" (iOS) "10.10.3" (Desktop)
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the full OS version number
 * @overridable
 */
Base$1.prototype.osVersion = function osVersion(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.osVersion || environment.osVersion();
};

/**
 * A unique descriptor for the page.
 * Usually [pageType_pageId]
 * If no pageId exists, "page" may be a textual identifier (e.g. "NewStation_Genres", "LearnMore_HD").
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app),
 * then this field would be generated by the client.
 * @example Genre_168577
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} a unique descriptor for the page
 * @overridable
 */
Base$1.prototype.page = function page(callerSuppliedEventFields) {
    if (callerSuppliedEventFields) {
        if (callerSuppliedEventFields.page) {
            return callerSuppliedEventFields.page;
        } else if (this.pageType(callerSuppliedEventFields) && this.pageId(callerSuppliedEventFields)) {
            var config$$1 = this._metricsKit.config;
            return this.pageType(callerSuppliedEventFields) + config$$1.value('compoundSeparator') + this.pageId(callerSuppliedEventFields);
        }
    } else {
        throw "No data provided to event_handlers/base page function";
    }
};

/**
 * The context within which a page is viewed.  Contexts usually provide independent streams of activity.
 * Many implementations return the tab that a user is currently on.
 * @example
 * iTunes Desktop: "InTheStore" or "Main"
 * iOS iTunes apps: tab name (e.g. "Featured", "TopCharts", etc)
 * iOS Store sheets:  "Sheet" (e.g. AppStore page launched as a sheet within Mail, Springboard’s "Near Me", Maps’ "Nearby Apps")
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the context within which a page is viewed.  Contexts usually provide independent streams of activity
 * @overridable
 */
Base$1.prototype.pageContext = function pageContext(callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.pageContext;
};

/**
 * IMPORTANT: This field cannot be deduced by this class, so either:
 *              a. this method needs to be overridden by the caller,
 *              b. the caller should pass this in as part of the key/value in the "callerSuppliedEventFieldsMapN(varargs)" parameter on the metricsData() call
 * User-readable details describing page.
 * May contain localized values (e.g. "Alicia Keys-Girl On Fire", "MusicMain").
 * Max length 25 characters.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app),
 * then this field would be generated by the client, if needed.
 * @example "Top Paid iPhone Apps_Mobile Software Applications"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} user-readable details describing page
 * @overridable
 */
Base$1.prototype.pageDetails = function pageDetails(callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.pageDetails;
};

/**
 * IMPORTANT: This field cannot be deduced by this class, so either:
 *              a. this method needs to be overridden by the caller,
 *              b. the caller should pass this in as part of the key/value in the "callerSuppliedEventFieldsMapN(varargs)" parameter on the metricsData() call
 * String ID of the page’s content.
 * Used to concatenate with the "pageType" param using the "compoundSeparator" config value (typically "_") to produce "page" values of the form: pageType_pageId
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally the identifier in some persistent store.
 * Search Results pages may have a pageId which refers to their specific dataSet, otherwise known as dataSetId.
 * If the page is better identified by a descriptive string rather than a content ID, this field may be hard-coded, but it should be unique within the set of pages displayable by the app
 * the descriptive string may appear in the "page" field instead.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app),
 * then this field would be generated by the client.
 * @example 168577, 1, "Welcome", etc.
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} string ID of the page’s content
 * @overridable
 */
Base$1.prototype.pageId = function pageId(callerSuppliedEventFields) {
    // TODO:KBERN: add screamer here if this is not provided?
    return callerSuppliedEventFields && callerSuppliedEventFields.pageId;
};

/**
 * IMPORTANT: This field cannot be deduced by this class, so either:
 *              a. this method needs to be overridden by the caller,
 *              b. the caller should pass this in as part of the key/value in the "callerSuppliedEventFieldsMapN(varargs)" parameter on the metricsData() call
 * Name for the group of pages this page is (e.g. "Album" or "Grouping").
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app),
 * then this field would be generated by the client.
 * Used to concatenate with the "pageId" param using the "compoundSeparator" config value (typically "_") to produce "page" values of the form: pageType_pageId
 * @example "Genre", "Album", "Grouping", "Picker", "Recommendations", "Feed", "Search", "Subscribe", etc.)
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} name for the group of pages this page is (e.g. "Album" or "Grouping").
 * @overridable
 */
Base$1.prototype.pageType = function pageType(callerSuppliedEventFields) {
    // TODO:KBERN: add screamer here if this is not provided?
    return callerSuppliedEventFields && callerSuppliedEventFields.pageType;
};

/**
 * The URL that represents this page.
 * Typically this is a "deep link" type URL.
 * If no URL is available, this field may be omitted.
 * @example
 *      https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewGrouping?cc=us&id=168577
 *      https://search.itunes.apple.com/WebObjects/MZSearchHints.woa/wa/trends
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the URL to the page or null if there is none
 * @overridable
 */
Base$1.prototype.pageUrl = function pageUrl(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.pageUrl || environment.pageUrl();
};

/**
 * The URL of the parent page, if the app is embedded in a parent context.
 * Typically this is a "deep link" type URL.
 * If no URL is available, or if the app is not embedded, this field may be omitted.
 * @example
 *      https://www.apple.com/blog/top-tracks.html
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the URL of the parent page or null if there is none
 * @overridable
 */
Base$1.prototype.parentPageUrl = function parentPageUrl(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.parentPageUrl || environment.parentPageUrl();
};

/**
 * The pixel multiplier factor
 * @example 2
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the pixel multiplier factor
 * @overridable
 */
Base$1.prototype.pixelRatio = function pixelRatio(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.pixelRatio || environment.pixelRatio();
};

/**
 * The HTML resources revision number
 * @example 2C97 or 8.4.0.0.103
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the HTML resources revision number
 * @overridable
 */
Base$1.prototype.resourceRevNum = function resourceRevNum(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.resourceRevNum || environment.resourceRevNum();
};

/**
 * The client screen height in pixels
 * @example 568
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the client screen height in pixels
 * @overridable
 */
Base$1.prototype.screenHeight = function screenHeight(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.screenHeight || environment.screenHeight();
};

/**
 * The client screen width in pixels
 * @example 320
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the client screen width in pixels
 * @overridable
 */
Base$1.prototype.screenWidth = function screenWidth(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.screenWidth || environment.screenWidth();
};

/**
 * ISO 3166 Country Code. Apps that cannot provide a storeFrontHeader should provide a storeFrontCountryCode instead
 * @example US
 * @param {Map} callerSuppliedEventFields
 * @returns {String} the store front country code
 * @overridable
 */
Base$1.prototype.storeFrontCountryCode = function storeFrontCountryCode(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields[FIELD_NAMES$1.STOREFRONT_COUNTRY_CODE] || environment.storeFrontCountryCode();
};

/**
 * The value contained in the X-Apple-Store-Front header value at the time the event is being created.
 * @example K143441-1,29 ab:rSwnYxS0
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the value contained in the X-Apple-Store-Front header value at the time the event is being created
 * @overridable
 */
Base$1.prototype.storeFrontHeader = function storeFrontHeader(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.storeFrontHeader || environment.storeFrontHeader();
};

/**
 * The difference, in minutes, between GMT (UTC) and timezone of event origin ("local time).
 * This means that the offset is positive if the local timezone is behind UTC and negative if it is ahead.
 * Daylight saving time prevents this value from being a constant, even for a given locale
 * @example 420 (PST, not -420) or -600 (Australian Eastern Standard Time, UTC+10)
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the difference, in minutes, between GMT (UTC) and timezone of event origin ("local time).
 * @overridable
 */
Base$1.prototype.timezoneOffset = function timezoneOffset(callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.timezoneOffset || new Date().getTimezoneOffset();
};

/**
 * The client’s user agent string.  If the "app field is not provided, "userAgent may be used to derive the value of the "app field
 * @example AppStore/2.0 iOS/8.3 model/iPhone7,2 build/12F70 (6; dt:106)
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the client’s user agent string.  If the "app field is not provided, "userAgent may be used to derive the value of the "app field
 * @overridable
 */
Base$1.prototype.userAgent = function userAgent(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.userAgent || environment.userAgent();
};

/**
 * The type of subscriber this user is.
 * @example subscribed, notSubscribed, unknown, needsAuthentication
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the type of subscriber this user is
 * @overridable
 */
Base$1.prototype.userType = function userType(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.userType || environment.userType();
};

/**
 * The app viewport height in pixels.  Does not include window “chrome”, status bars, etc.
 * Typically only available on desktop windowing systems.
 * @example 1920
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number/undefined} the app viewport height in pixels.  Does not include window “chrome”, status bars, etc
 * @overridable
 */
Base$1.prototype.windowInnerHeight = function windowInnerHeight(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.windowInnerHeight || environment.windowInnerHeight();
};

/**
 * The app viewport width in pixels.  Does not include window “chrome”, status bars, etc.
 * Typically only available on desktop windowing systems.
 * @example 1080
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number/undefined} the app viewport width in pixels.  Does not include window “chrome”, status bars, etc
 * @overridable
 */
Base$1.prototype.windowInnerWidth = function windowInnerWidth(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.windowInnerWidth || environment.windowInnerWidth();
};

/**
 * The height in pixels of containing window, encompassing app viewport as well as window chrome, status bars, etc.
 * Typically only available on desktop windowing systems.
 * @example 1080
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number/undefined} the height in pixels of containing window, encompassing app viewport as well as window chrome, status bars, etc
 * @overridable
 */
Base$1.prototype.windowOuterHeight = function windowOuterHeight(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.windowOuterHeight || environment.windowOuterHeight();
};

/**
 * The width in pixels of containing window, encompassing app viewport as well as window chrome, status bars, etc.
 * Typically only available on desktop windowing systems.
 * @example 1920
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number/undefined} the width in pixels of containing window, encompassing app viewport as well as window chrome, status bars, etc
 * @overridable
 */
Base$1.prototype.windowOuterWidth = function windowOuterWidth(callerSuppliedEventFields) {
    var environment = this._metricsKit.system.environment;
    return callerSuppliedEventFields && callerSuppliedEventFields.windowOuterWidth || environment.windowOuterWidth();
};

/**
 * How often, in milliseconds, batches of events should get sent to the server.
 * This field should be based on the client's most recent config value of "postFrequency".
 * This is valuable for problem analysis because it indicates if and how clients are honoring the "postFrequency" value
 * they were supplied with.
 * This cannot be a "passthrough" field, because it can change (via new config) during program execution, so the value
 * in effect at event creation time is what is needed.
 * @example 60000
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} wow often, in milliseconds, batches of events should get sent to the server
 * @overridable
 */
Base$1.prototype.xpPostFrequency = function xpPostFrequency(callerSuppliedEventFields) {
    var config$$1 = this._metricsKit.config;
    return callerSuppliedEventFields && callerSuppliedEventFields.xpPostFrequency || config$$1.value('postFrequency');
};

/**
 * The percentage, from 0 to 1, that an item should be on screen before being considered impressionable
 * This field should be based on the client's most recent config value of "viewablePercentage".
 * This is valuable for problem analysis because it indicates if and how clients are honoring the "viewablePercentage" value
 * they were supplied with.
 * This cannot be a "passthrough" field, because it can change (via new config) during program execution, so the value
 * in effect at event creation time is what is needed.
 * @example 0.5
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {number} the percentage, from 0 to 1, that an item should be on screen before being considered impressionable
 * @overridable
 */
Base$1.prototype.xpViewablePercentage = function xpViewablePercentage(callerSuppliedEventFields) {
    var config$$1 = this._metricsKit.config;
    return callerSuppliedEventFields && callerSuppliedEventFields.xpViewablePercentage || config$$1.value('impressions.viewablePercentage');
};

/**
 * The methodology being used by the eventRecorder to send batches of events to the server
 * This field should be hardcoded in the client based on what method it is using to encode and send its events to Figaro.
 * The three typical values are:
 *      "itms" - use this value when/if JavaScript code enqueues events for sending via the "itms.recordEvent()" method in ITML.
 *      "itunes" - use this value when/if JavaScript code enqueues events by calling the "iTunes.recordEvent()" method in Desktop Store apps.
 *      "javascript" - use this value when/if JavaScript code enqueues events for sending via the JavaScript eventQueue management. This is typically only used by older clients which don't have the built-in functionality of itms or iTunes available to them.
 * @example "itms", "itunes", "javascript"
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {String} the methodology being used by the eventRecorder to send batches of events to the server
 * @overridable
 */
Base$1.prototype.xpSendMethod = function xpSendMethod(callerSuppliedEventFields) {
    var system = this._metricsKit.system;
    return callerSuppliedEventFields && callerSuppliedEventFields.xpSendMethod || system.eventRecorder.sendMethod();
};
/**
 * The version of MetricsKit being used
 * Pulled from the version in the package.json via
 * the dynamically created info.js
 * @example "0.1.3", "2.0.1"
 * @returns {String} version of MetricsKit being used
 * @overridable //this should be changed to not be overridable
 */
Base$1.prototype.xpVersionMetricsKit = function xpVersionMetricsKit() {
    return info.version;
};
/**
 * The versions and names, and delegate dependencies of delegates attached to MetricsKit
 * @example
 *  // If a delegate with the same name/version value is added
 *  // to the same target multiple times, (such as a case where
 *  // portions of one delegate are attached separately to a target)
 *  // each delegate is only represented
 *  // once per 'level' of delegate children
 *  [{
 *      version: '1.2.3',
 *      name: '@amp-metrics/mt-metricskit-delegates-itml'
 *   }
 *   {
 *      version: '3.2.1',
 *      name: '@amp-metrics/mt-metricskit-delegates-html',
 *      delegates:[{
 *          version: '2.1.3',
 *          name: '@amp-metrics/mt-metricskit-delegates-html-ios'
 *      }]
 *  }]
 * @returns {Array} Info of delegates attached to MetricsKit
 * @overridable //this should be changed to not be overridable
 */
Base$1.prototype.xpDelegatesInfo = function xpDelegatesInfo() {
    var delegateTree = delegates_info.getStoredDelegateObject(this);
    var delegateChildren = delegateTree && delegateTree.delegates;
    // If no delegates have been attached to MetricsKit,
    // return undefined so the field is removed from the event
    return delegateChildren ? delegateChildren : undefined;
};

/*
 *  src/metrics/event_handlers/buyConfirmed.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * <p>
 * PLEASE READ:
 * What follows is an important discussion of how buys operate in iTunes Stores, and how to accurately collect metrics data during that flow.
 * <p>
 * The typical flow of a "buy" in an iTunes Store is:
 * <ol>
 *     <li>User performs some "buy" action (e.g. click a "buy" button or a "subscribe" button)
 *     <li>JavaScript code then creates some "buyData" (including some "buyParams") needed by the Finance servers in order to execute the buy.
 *     <li>JavaScript code then invokes a native "buy" call such as itms.buy(buyData) or itunes.buy(buyData).
 *     <li>In response to the "buy()" call, the native code returns immediately, making the rest of the procedure asynchronous to the JavaScript code.
 *     <li>Native code then makes an HTTP request to the Finance servers with the buyData
 *     <li>Finance servers then reply with a "success" or "failure" response.
 *     <li>When Finance response comes back from Finance, the native code will invoke a JavaScript callback such as "onBuy(buyInfo)".
 *     <li>The "buyInfo" parameter may contain a "result" value (buyInfo.result).
 *     <li>JavaScript code checks buyInfo.return and if present and non-zero/non-null typically invokes (or publishes) a "buyConfirmed" JavaScript event, and if not, invokes (or publishes) a "buyFailed" event.
 *     <li>Within that "buyConfirmed" callback function (perhaps subscribed to), is where the metrics "buyConfirmed" event should be created a and recorded.
 * </ol>
 * </p>
 * That is the <i>typical</i> flow. But things can go wrong.
 * The Finance servers can, for example, in the response to the "buy" request, instruct the native client code to "detour" the user through a Finance flow such as credit card validation, terms of service agreement, etc.
 * When that occurs, the native code <i>will invoke the JavaScript "onBuy" function with a result value indicating buy failure!</i>.
 * However, the buy may not have "really" failed... after the user completes the Finance flow, the "buy" request might eventually succeed, in which case the native code is notified and it will call the JavaScript client's "onBuy" callback with a <i>success</i> return value (causing the "buyConfirmed" to be published), even though it has already called it with a failure code!
 * <p>
 * Due to this special case, the metrics code needs to stash away the metrics data in place at the time the user requests the "buy" and then use that data later (perhaps much later) when/if the "buyConfirmed" actually occurs.
 * In order to marry the metrics data from the time of the "buy", to the event returned in any given "buyConfirmed" (remember, it's all asynchronous), the client creates a "clientBuyId" and uses that as a key to store metrics data.
 * It also passes that key as a query param on the "buy" request so that...
 * When/if the "buyConfirmed" callback is finally called, it will contain the "clientBuyId" value which the metrics code can then use to look up the metrics data that was in place at the time of the "buy".
 * <p>
 * This "detoured" "edge case" of users being redirected through Finance flows can happen a significant percentage of the time (possibly 10-20%) so it has to be handled for accurate metrics.
 * <p>
 * MetricsKit attempts to hide as much of this edge-case craziness as possible, and aid in facilitating the handling of it.
 * <p>
 * <b>To properly instrument buyConfirmed events, JavaScript clients should:</b>
 * <ol>
 *     <li>at <b>"buy"</b> time
 *         <ol>
 *             <li> Create a "clientBuyId" via a call to:
 *                  <br><b><i>metrics.eventHandlers.buyConfirmed.createClientBuyId()</i></b>.
 *                  <br>NOTE: each successive call to this function will return a different clientBuyId
 *             <li> Include that value with the "buyParams" via a call to:
 *                  <br><b><i>metrics.eventHandlers.buyConfirmed.clientBuyIdQueryParamString(clientBuyId)</i></b>
 *             <li> Cache all metrics data needed for the (ulitmate) "buyConfirmed" event, keying off that clientBuyId, via a call to:
 *                  <br><b><i>metrics.eventHandlers.buyConfirmed.cacheMetricsBuyData(clientBuyId, metricsBuyData)</i></b>
 *                  <br>Caching the data here ensures that the metrics buy data accurately reflects the user state at the time of the "buy" vs. their state when the asynchronous "buyConfirmed" callback is received.
 *             <li> Invoke the native "itms/iTunes.buy(buyData)" function.
 *             <br>The clientBuyId will be passed through all the subsequent Finance calls, and eventually be returned to the client when the buy finally succeeds or fails.
 *         </ol>
 *     <li>at <b>"buyFailed"</b> time (which will only happen if user gets "detoured" through a Finance flow)
 *         <ol>
 *             <li> notify MetricsKit that the buy may be detoured via a call to:
 *                  <br><b><i>metrics.eventHandlers.buyConfirmed.buyFailureOccurred(clientBuyId)</i></b> (MetricsKit will add a "detoured" flag to the stashed data)
 *         </ol>
 *     <li>at <b>"buyConfirmed"</b> time (regardless of whether or not it previously failed)
 *         <ol>
 *             <li> retrieve the clientBuyId from the buyData included with the "buyConfirmed" native callback, e.g.:
 *             <br>     var clientBuyId = buyInfo.options.clientBuyId;
 *             <br> This is the same clientBuyId that was supplied as a query parameter during the initial itms/iTunes.buy() call and is plumbed through any Finance flows that occurred.
 *             <li> retrieve the cached metrics data via a call to:
 *                  <br><b><i>metrics.eventHandlers.buyConfirmed.uncacheMetricsBuyData(clientBuyId)</i></b>.
 *                  <br><b>IMPORTANT</b>: If cached data is successfully retrieved for the supplied clientBuyId, that data will be removed in order to keep the cache size under control
 *             <li> prepare the data required by the "buyConfirmed" event (be sure to include the "detoured" flag, if present)
 *             <li> create the "buyConfirmed" metrics event via a call to:
 *                  <br><b><i>metrics.eventHandlers.buyConfirmed.metricsData()</i></b>, including the retrieved cached metrics data.
 *         </ol>
 * </ol>
 *
 * JavaScript clients should
 *
 * @delegatable
 * @constructor
 */
var BuyConfirmed = function BuyConfirmed(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} delegate Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
BuyConfirmed.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @example a "hint", "related" click, "filter" click, etc.
 * If this event is representing a plain typed buyConfirmed, this field's value may be null
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, element, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}; someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns {map} key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
BuyConfirmed.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    return base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @returns {array} all the fields that this eventHandler knows about
 */
BuyConfirmed.prototype.knownFields = function knownFields() {
    var knownFields = ['eventType', 'eventVersion'];

    return knownFields;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
BuyConfirmed.prototype.eventType = function (callerSuppliedEventFields) {
    return 'buyConfirmed';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
BuyConfirmed.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 1;
};

/**
 * <i>NOTE: Please read the full description of the "buy" process at the top of this page before attempting to utilize these methdos</i>
 * Called at the time a user initiates a "buy" (e.g. typically immediately before the itms/iTunes.buy(buyData) calls)
 * This function is used as a cacheKey to store metrics data when the user initiates a "buy" and to retrieve that information if the buy "fails" by virtue of the user
 * being forced through, e.g., a Finance flow (CC validation, TOS acceptance, etc.), and then later a "buySuccess" (buyConfirmed) comes through, this value allows
 * the client application to bind to the metrics data that would have been included if the buy had initially succeeded.
 * @returns {number} returns a unique integer value with each call. The uniqueness only last for a single JavaScript "session" (it is merely an incremented value)
 */
BuyConfirmed.prototype.createClientBuyId = function () {
    var newClientId = null;
    var environment = this._metricsKit.system.environment;
    var previousClientBuyId = environment.sessionStorageObject().getItem('mtMetricsKit_previousClientBuyId');

    // May coerce type of previousClientBuyId to Number, NaN result should be reset to 1
    newClientId = ++previousClientBuyId;
    if (!previousClientBuyId) {
        this._metricsKit.system.logger.warn("Metrics: buyConfirmed.createClientBuyId: clientBuyId did not exist or was of incorrect type, reset to 1.");
        newClientId = 1;
    }
    // We use sessionStorage in case our page/JS context goes away and then comes back, we continue where we left off.
    environment.sessionStorageObject().setItem('mtMetricsKit_previousClientBuyId', newClientId);

    return newClientId;
};

// NOTE: I know this method is a trivial convenience and is not so helpful to callers, but what it *does* do is that its existence makes it explicit to callers that clientBuyId needs to be added to their buParams query parameters
//       It also leaves the name of that query param under our control, preventing errors and allowing for transparent changes in the future.
/**
 * <i>NOTE: Please read the full description of the "buy" process at the top of this page before attempting to utilize these methdos</i>
 * Called at the time a user initiates a "buy" (e.g. typically immediately before the itms/iTunes.buy(buyData) calls)
 * Convenience method for creating the appropriate query param string to include with the "buyParams" on a typical "itms/iTunes.buy(buyInfo)" call
 * @param {number} clientBuyId is the value returned by the "createClientBuyId()". Remember to only call that method once, as it returns a different value each time.
 * @returns {String} a query param string with "clientBuyId" as a key and the value of the passed-in "clientBuyId" as a value, e.g. "&clientBuyId=2"
 * <br>NOTE: The returned string is always prefaced with an ampersand (&), never a question mark (?)
 * @example
 *     var clientBuyId = metrics.eventHandlers.buyConfirmed.createClientBuyId();
 *     buyData.offers[i].buyParams = buyData.offers[i].buyParams + "&someBuyParam=" + someBuyParamValue + metrics.eventHandlers.buyConfirmed.clientBuyIdQueryParamString(clientBuyId(clientBuyId);
 */
BuyConfirmed.prototype.clientBuyIdQueryParamString = function (clientBuyId) {
    return '&clientBuyId=' + clientBuyId;
};

/**
 * <i>NOTE: Please read the full description of the "buy" process at the top of this page before attempting to utilize these methods</i>
 * <i>NOTE: This code is not actually used in the generation of "buyConfirmed" events, but still seems like the best home for it.</i>
 * Called at the time a user initiates a "buy" (e.g. typically immediately before the itms/iTunes.buy(buyData) calls)
 * Convenience method for creating the appropriate query param string to include with the "buyParams" on a typical "itms/iTunes.buy(buyInfo)" call
 * @param {String} pageId is the pageId of the page where the buy originated.
 * @param {String} pageType is the pageType of the page where the buy originated.
 * @param {String} pageContext is the pageContext of the page where the buy originated.
 * @param {String} (optional) topic is the topic that will be used to send "dialog" events to if dialogs are presented as a result of the "buy()" call. If omitted, it will default to "xp_its_main"
 * @param {varargs} (optional) callerSuppliedBuyParamsMapsN a variable number of Object arguments from 0-N,
 *                             each containing key/value pairs representing buy parameters to include in
 *                             the returned string
 * @returns {String} an unescaped query param string with 'mt' prefixed keys and the value of the passed-in parameters, plus 'mtPrevPage', derived from the
 * MetricsKit-cached pageHistory (see page event documentation)
 * - mtPrevPage (The previous page, using the pageHistory field)
 * - mtPageType (The pageType field of the page from which the purchase occurs)
 * - mtPageId (The pageId field of the page from which the purchase occurs).  Figaro can use this to ensure that the app being purchased shares an ID with the product page.
 * - mtPageContext (The pageContext field of the page from which the purchase occurs)
 * - mtTopic (The context of an event (e.g. “xp_its_main”).)
 * - mtRequestId (A client generated UUID for every request, to be used in visit stitching to stitch client side event together with server side buy.)
 * Refer to base field documentation for undocumented fields below
 * - mtApp
 * - mtEventTime
 * - mtClientId
 * e.g. "&mtPrevPage=Picker_Welcome&mtPageId=Subscribe&pageType=Picker&pageContext=ForYou"
 * <br>NOTE: The returned string is always prefaced with an ampersand (&), never a question mark (?)
 * @example
 *     var metricsBuyParamsString = metrics.eventHandlers.buyConfirmed.metricsBuyParamsString(pageId, pageType, pageContext, "xp_its_main", { mtHardwareModel: "iPhone", extRefApp2: "com.apple.Mail" });
 *     buyData.offers[i].buyParams = buyData.offers[i].buyParams + "&someBuyParam=" + someBuyParamValue + "&" + metricsBuyParamsString;
 */
BuyConfirmed.prototype.metricsBuyParamsString = function (pageId, pageType, pageContext, topic /*, callerSuppliedBuyParamsMapsN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    var page = this._metricsKit.eventHandlers.page;
    var callerSuppliedBuyParamsMapsArray = Array.prototype.slice.call(arguments, 4);
    var pageHistory = page.pageHistory();
    var clientId = base.clientId();
    var mtPrevPage;
    var buyParams;

    if (Array.isArray(pageHistory)) {
        if (pageHistory.length >= 2) {
            mtPrevPage = pageHistory[pageHistory.length - 2];
        }
    } else {
        this._metricsKit.system.logger.warn("MetricsKit: metricsBuyParamsString: pageHistory is not an Array");
    }

    buyParams = {
        mtApp: base.app(),
        mtEventTime: Date.now(),
        mtHardwareBrand: base.hardwareBrand(),
        mtHardwareFamily: base.hardwareFamily(),
        mtHardwareModel: base.hardwareModel(),
        mtHostApp: base.hostApp(),
        mtHostAppVersion: base.hostAppVersion(),
        mtOs: base.os(),
        mtOsBuildNumber: base.osBuildNumber(),
        mtOsVersion: base.osVersion(),
        mtPageId: pageId,
        mtPageType: pageType,
        mtPageContext: pageContext,
        mtTopic: topic || 'xp_its_main',
        mtPrevPage: mtPrevPage,
        mtRequestId: string$1.uuid(),
        mtClientId: clientId
    };

    reflect$1.extend.apply(reflect$1, [buyParams].concat(callerSuppliedBuyParamsMapsArray));

    // NOTE: if any of these fields are null or "undefined",
    // they will be omittedin the "paramString()" function.
    return string$1.paramString(buyParams);
};

/**
 * <i>NOTE: Please read the full description of the "buy" process at the top of this page before attempting to utilize these methdos</i>
 * <i><b>IMPORTANT</b>: If this method successfully retrieves data for the supplied clientBuyId, that data will be removed in order to keep the cache size under control
 * Called at the time a user initiates a "buy" (e.g. typically immediately before the itms/iTunes.buy(buyData) calls)
 * This function is used to serialize (to string) and cache metrics data when the user initiates a "buy".
 * This data will be retrieved later during the "buyConfirmed" native callback (via the "uncacheMetricsBuyData()" function) and ensures that the metrics buy data accurately reflects the user state at the time of the "buy" vs. their state when the asynchronous "buyConfirmed" callback is received.
 * For example, the user may have been forced through a Finance flow (CC validation, TOS acceptance, etc.) and then later a "buySuccess" (buyConfirmed) comes through.
 * @param {number} clientBuyId is the value returned by the "createClientBuyId()". Remember to only call that method once, as it returns a different value each time.
 * @param {object} metricsBuyData is the value returned by the "createClientBuyId()". Remember to only call that method once, as it returns a different value each time.
 */
BuyConfirmed.prototype.cacheMetricsBuyData = function (clientBuyId, metricsBuyData) {
    var environment = this._metricsKit.system.environment;
    // Since these methods are similarly named, let's just help out the caller by checking...
    if (arguments.length != 2) {
        this._metricsKit.system.logger.error("buyConfirmed.cacheMetricsBuyData(): function invoked with incorrect number of parameters. Perhaps you meant to retrieve cached data instead of setting it, which would be a call to uncacheMetricsBuyData(clientBuyId)?");
    } else {
        // sessionStorage only accepts string values...
        var serializedData = JSON.stringify(metricsBuyData);
        environment.sessionStorageObject().setItem('mtMetricsKit_metricsBuyData_for_clientBuyId_' + clientBuyId, serializedData);
    }
};

/**
 * <i>NOTE: Please read the full description of the "buy" process at the top of this page before attempting to utilize these methdos</i>
 * Called at the time JavaScript receives a "buyConfirmed" callback from the native code.
 * This function is used to deserialize (from string) and return the metrics data that was cached when the user initiated the "buy" via the cacheMetricsBuyData() function.
 * This data should be the data used to include when creating the buyConfirmed event via the metrics.eventHandlers.buyConfirmed.metricsData() function.
 * @param {number} clientBuyId is retrieved from the buyData included with the "buyConfirmed" native callback, e.g.:
 * <br>     var clientBuyId = buyInfo.options.clientBuyId;
 * <br> This is the same clientBuyId that was supplied as a query parameter during the initial itms/iTunes.buy() call and is plumbed through any Finance flows that occurred.
 * @returns {object} the same data that was initially stored with this clientBuyId at itms/iTunes.buy() time via the call to: "cacheMetricsBuyData()"
 * If no data is found for this clientBuyId, "null" will be returned (typically that should never happen)
 */
BuyConfirmed.prototype.uncacheMetricsBuyData = function (clientBuyId) {
    var returnValue = null;
    var environment = this._metricsKit.system.environment;

    // Since these methods are similarly named, let's just help out the caller by checking...
    if (arguments.length != 1) {
        this._metricsKit.system.logger.error("buyConfirmed.uncacheMetricsBuyData(): function invoked with incorrect number of parameters. Perhaps you meant to set cached data instead of retrieving it, which would be a call to cacheMetricsBuyData(clientBuyId, metricsBuyData)?");
    } else {
        // sessionStorage only accepts string values...
        var serializedData = environment.sessionStorageObject().getItem('mtMetricsKit_metricsBuyData_for_clientBuyId_' + clientBuyId);

        if (serializedData) {
            returnValue = JSON.parse(serializedData);
            environment.sessionStorageObject().removeItem('mtMetricsKit_metricsBuyData_for_clientBuyId_' + clientBuyId);
        }
    }
    return returnValue;
};

/**
 * <i>NOTE: Please read the full description of the "buy" process at the top of this page before attempting to utilize these methdos</i>
 * Called at the time JavaScript receives a "buyFailed" callback from the native code.
 * This function is used to flag "buys" that have been "detoured" through a Finance flow with the "detoured=true" flag.
 * If a buy fails (which is why "buyFailed" would be called) but then later succeeds (after a Finance detour), we will have set the "detoured" flag by virtue of this call.
 * @param {number} clientBuyId is retrieved from the buyData included with the "buyFailed" native callback, e.g.:
 * <br>     var clientBuyId = buyInfo.options.clientBuyId;
 * <br> This is the same clientBuyId that was supplied as a query parameter during the initial itms/iTunes.buy() call and is plumbed through any Finance flows that occurred.
 */
BuyConfirmed.prototype.buyFailureOccurred = function (clientBuyId) {
    var uncacheMetricsBuyData = this.uncacheMetricsBuyData(clientBuyId);

    if (uncacheMetricsBuyData) {
        uncacheMetricsBuyData.detoured = true;
        // Put it back, since a) we added a field and b) asking for it removed it.
        this.cacheMetricsBuyData(clientBuyId, uncacheMetricsBuyData);
    }
};

/*
 *  src/metrics/event_handlers/click.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

// TODO: move to utils-private
var safeJSONParse = function safeJSONParse(text) {
    var returnValue = null;

    try {
        returnValue = JSON.parse(text);
    } catch (e) {
        logger.error('MetricsKit: error parsing click data - ' + e);
    }

    return returnValue;
};

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Click = function Click(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Click.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @param {Object} targetElement The element from which the click event originated
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, element, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * @overridable
 */
Click.prototype.metricsData = function (pageId, pageType, pageContext, targetElement /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var argumentsArray = [pageId, pageType, pageContext];
    var base = this._metricsKit.eventHandlers.base;
    var utils$$1 = this._metricsKit.utils;

    if (targetElement) {
        argumentsArray.push({ location: utils$$1.eventFields.buildLocationStructure(targetElement, this.locationDataForElement) });
        argumentsArray.push(this.dataForElement(targetElement) || {});
    }

    argumentsArray = argumentsArray.concat(Array.prototype.slice.call(arguments, 4));

    return base.processMetricsData.apply(this, argumentsArray);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Click.prototype.knownFields = function knownFields() {
    var knownFields = ['actionContext', 'actionDetails', 'actionType', 'actionUrl', 'eventType', 'eventVersion', 'impressions', 'location', 'targetId', 'targetType', 'positionX', 'positionY', 'xpViewablePercentage'];

    return knownFields;
};

/**
 * The parsed click data that was attached to a clicked element
 * @param {Object} targetElement The clicked element
 * @return {Object} the parsed click data that was attached to the element as a data attribute, if present and valid, otherwise null
 * @overridable
 */
Click.prototype.dataForElement = function dataForElement(element) {
    var returnValue = null;

    if (element && reflect$1.isFunction(element.hasAttribute) && reflect$1.isFunction(element.getAttribute)) {
        var clickDataAttribute = this.dataAttribute();
        if (element.hasAttribute(clickDataAttribute)) {
            returnValue = safeJSONParse(element.getAttribute(clickDataAttribute));
        }
    }

    return returnValue;
};

/**
 * The data attribute used to attach click data to DOM-like elements in the view model
 * @returns {String}
 * @overridable
 */
Click.prototype.dataAttribute = function dataAttribute() {
    return 'data-metrics-click';
};

/**
 * The relevant location dictionary for an element
 * @param {Object} element an element in the view heirarchy
 * @return {Object} the location data for the element, if present and valid, otherwise null
 *     The default implementation looks for a data attribute called 'data-metrics-location'
 *     and, if present, parses the attribute into a dictionary, and adds the elements' position
 *     within its parent container as a field called 'locationPosition'
 * @overridable
 */
Click.prototype.locationDataForElement = function locationDataForElement(element) {
    var parentNode = element.parentNode;
    var position = 0;
    var location = null;

    var siblingElements;
    var sibling;
    var siblingLocationInfo;
    var siblingLocationType;

    // if this element has a location type defined (in other words, it has a semantic value from the end user
    // point of view like shelf, lockup etc) then add it to the location stack otherwise don't.
    // for ex. we may have a bunch of <section> elements in our dom tree but there is no point in including
    // them in the location stack
    if (element.hasAttribute && element.hasAttribute('data-metrics-location')) {
        location = safeJSONParse(element.getAttribute('data-metrics-location'));
        if (location.locationType) {
            if (parentNode) {
                // determine our location in the children array of our parent
                siblingElements = parentNode.childNodes;
                for (var i = 0; i < siblingElements.length; i++) {
                    // ITML childNodes list uses .item(i) accessor instead of [i]
                    sibling = typeof siblingElements.item === 'function' && siblingElements.item(i) || siblingElements[i];
                    siblingLocationInfo = sibling.hasAttribute && sibling.hasAttribute('data-metrics-location') ? safeJSONParse(sibling.getAttribute('data-metrics-location')) : undefined;
                    siblingLocationType = siblingLocationInfo ? siblingLocationInfo.locationType : undefined;
                    if (siblingLocationType) {
                        if (sibling === element) {
                            // we now know the position of the element, so stop here
                            break;
                        } else {
                            // we consider all siblings that have the data-metrics-location attribute and the same parent container as the target element
                            // for calculating position. for ex. on a grouping page, we may have 2 swooshes, followed by a title text div and then
                            // one more swoosh. We count the preceding swooshes and the title text div sibling element when calculating the position
                            // of the 3rd swoosh. The position of the last swoosh should be '3' (with '0' based index).
                            position++;
                        }
                    }
                }
            }
            location.locationPosition = position;
        }
    }

    return location;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Click.prototype.eventType = function (callerSuppliedEventFields) {
    return 'click';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Click.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 4;
};

/**
 * A list of flattened impression objects for this event
 * Default behavior assumes the impressions have already been flattened and just returns them, but clients can override this with their own flattening implementation
 * @returns {Array} an array of impression objects, or undefined if no event fields were provided by the caller
 * @overridable
 */
Click.prototype.impressions = function impressions(callerSuppliedEventFields) {
    return callerSuppliedEventFields ? callerSuppliedEventFields.impressions : undefined;
};

/**
 * The percentage, from 0 to 1, that an item should be on screen before being considered impressionable
 * This field should be based on the client's most recent config value of "viewablePercentage".
 * @returns {number} the percentage, from 0 to 1, that an item should be on screen before being considered impressionable
 * @overridable
 */
Click.prototype.xpViewablePercentage = function xpViewablePercentage(callerSuppliedEventFields) {
    var base = this._metricsKit.eventHandlers.base;
    return base.xpViewablePercentage(callerSuppliedEventFields);
};

/*
 *  src/metrics/event_handlers/dialog.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Dialog = function Dialog(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Dialog.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @example a "hint", "related" click, "filter" click, etc.
 * If this event is representing a plain typed dialog, this field's value may be null
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, element, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Dialog.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    return base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Dialog.prototype.knownFields = function knownFields() {
    var knownFields = ['buttons', 'code', 'details', 'message', 'type', 'eventType', 'eventVersion', 'type'];

    return knownFields;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Dialog.prototype.eventType = function (callerSuppliedEventFields) {
    return 'dialog';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Dialog.prototype.eventVersion = function (callerSuppliedEventFields) {
    // Since these have an additional field "type" beyond eventVersion 1 (sent via server-requested "GET" URL ping in MXPFailure.java)
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 2;
};

/*
 *  src/metrics/event_handlers/enter.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Enter = function Enter(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Enter.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @example a "hint", "related" click, "filter" click, etc.
 * If this event is representing a plain typed enter, this field's value may be null
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, element, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Enter.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    return base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Enter.prototype.knownFields = function knownFields() {
    var knownFields = ['eventType', 'eventVersion', 'extRefUrl', 'osLanguages', 'refApp', 'type'];

    return knownFields;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Enter.prototype.eventType = function (callerSuppliedEventFields) {
    return 'enter';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Enter.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 1;
};

/**
 * OS language preferences; a string array of language IDs, ordered in descending preference
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke its accessor, if one is available, in case *its* value is derived or massaged.
 * @returns {Array} a list of preferred languages (strings) e.g. ['en-US', 'fr-CA']
 * @overridable
 */
Enter.prototype.osLanguages = function osLanguages(callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.osLanguages || this._metricsKit.system.environment.osLanguages();
};

/*
 *  src/metrics/event_handlers/exit.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Exit = function Exit(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Exit.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @example a "hint", "related" click, "filter" click, etc.
 * If this event is representing a plain typed exit, this field's value may be null
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, element, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Exit.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    return base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Exit.prototype.knownFields = function knownFields() {
    var knownFields = ['destinationUrl', 'eventType', 'eventVersion', 'type'];

    return knownFields;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Exit.prototype.eventType = function (callerSuppliedEventFields) {
    return 'exit';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Exit.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 1;
};

/*
 *  src/metrics/event_handlers/flexible.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Flexible = function Flexible(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Flexible.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary)
 * @param {String} eventType required for all event creation.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.flexible.metricsData('anEventType', {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields, merged and cleaned (removes keys that are typeof 'function', keys with 'null' values, keys with 'undefined' values)
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Flexible.prototype.metricsData = function (eventType /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var eventData = [undefined, undefined, undefined]; // leave page fields undefined
    var base = this._metricsKit.eventHandlers.base;

    // include eventType so it gets processed
    eventData.push({ eventType: eventType });

    var callerSuppliedEventFieldsMapsArray = Array.prototype.slice.call(arguments, 1);
    eventData = eventData.concat(callerSuppliedEventFieldsMapsArray);

    return base.processMetricsData.apply(this, eventData);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Flexible.prototype.knownFields = function knownFields() {
    var knownFields = ['eventTime', 'eventType'];

    return knownFields;
};

/**
 * A flag indicating whether this event should include base fields. Defaults to false for flexible events.
 * @returns {Boolean}
 * @overridable
 */
Flexible.prototype.mtIncludeBaseFields = function mtIncludeBaseFields() {
    return false;
};

/**
 * The time (UTC) in milliseconds at which this event happened.
 * This field is central to determining the sequence of user events
 * Use online epoch converter to test your values.
 * @example 1437356433388 (http://www.epochconverter.com converts that to:  July 19, 2015 at 6:40:33 PM PDT GMT-7:00 DST)
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke it's accessor, if one is available, in case *it's* value is derived or massaged.
 * @returns {number} the time (UTC) in milliseconds at which this event happened
 * @overridable
 */
Flexible.prototype.eventTime = function eventTime(callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventTime || Date.now();
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Flexible.prototype.eventType = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventType || undefined;
};

/*
 *  src/metrics/event_handlers/impressions.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Impressions = function Impressions(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Impressions.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, element, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Impressions.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    return base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Impressions.prototype.knownFields = function knownFields() {
    var knownFields = ['eventType', 'eventVersion', 'impressions', 'xpViewablePercentage', 'xpViewableThreshold'];

    return knownFields;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Impressions.prototype.eventType = function (callerSuppliedEventFields) {
    return 'impressions';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Impressions.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 3;
};

/**
 * A list of flattened impression objects for this event
 * Default behavior assumes the impressions have already been flattened and just returns them, but clients can override this with their own flattening implementation
 * @returns {Array} an array of impression objects, or undefined if no event fields were provided by the caller
 * @overridable
 */
Impressions.prototype.impressions = function impressions(callerSuppliedEventFields) {
    return callerSuppliedEventFields ? callerSuppliedEventFields.impressions : undefined;
};

/**
 * The percentage, from 0 to 1, that an item should be on screen before being considered impressionable
 * This field should be based on the client's most recent config value of "viewablePercentage".
 * @returns {number} the percentage, from 0 to 1, that an item should be on screen before being considered impressionable
 * @overridable
 */
Impressions.prototype.xpViewablePercentage = function xpViewablePercentage(callerSuppliedEventFields) {
    var base = this._metricsKit.eventHandlers.base;
    return base.xpViewablePercentage(callerSuppliedEventFields);
};

/**
 * The continuous duration, in milliseconds, that an item should be on screen before being considered impressed
 * This field should be based on the client's most recent config value of "viewableThreshold".
 * This is valuable for problem analysis because it indicates if and how clients are honoring the "viewableThreshold" value
 * they were supplied with.
 * This cannot be a "passthrough" field, because it can change (via new config) during program execution, so the value
 * in effect at event creation time is what is needed.
 * @example 1000
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke it's accessor, if one is available, in case *it's* value is derived or massaged.
 * @returns {number} the continuous duration, in milliseconds, that an item should be on screen before being considered impressed
 * @overridable
 */
Impressions.prototype.xpViewableThreshold = function xpViewableThreshold(callerSuppliedEventFields) {
    var config$$1 = this._metricsKit.config;
    return callerSuppliedEventFields && callerSuppliedEventFields.xpViewableThreshold || config$$1.value('impressions.viewableThreshold');
};

/*
 *  src/metrics/event_handlers/media.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

var FIELD_NAMES = constants.FIELD_NAMES;

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the "media" fields + all of the "base" events common to all metrics events.
 * To override any functionality in this class, use the "utils.override() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Media = function Media(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Media.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.media.metricsData(appData.pageId, appData.pageType, appData.pageContext, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Media.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    return base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Media.prototype.knownFields = function knownFields() {
    var knownFields = ['eventType', FIELD_NAMES.EVENT_VERSION, 'id', 'idType', 'type', 'typeDetails', 'actionType', 'actionDetails', 'url', 'duration', 'position'];
    return knownFields;
};

// ********************* ACCESSOR FUNCTIONS *********************
/**
 * We create accessor functions for every data field because:
 * 1. Cleans/simplifies all methods that use it.
 * 2. Facilitates writing test case shims
 * 3. Allows specific feature suppliers to be overridden (via setDelegate())
 */

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Media.prototype.eventType = function (callerSuppliedEventFields) {
    return 'media';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Media.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 1;
};

/*
 *  src/metrics/event_handlers/page.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the "page" fields + all of the "base" events common to all metrics events.
 * To override any functionality in this class, use the "utils.override() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Page = function Page(metricsKit) {
    // @private
    this._metricsKit = metricsKit;

    // @private
    this.pageHistoryCache = [];
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Page.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Page.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    return base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Page.prototype.knownFields = function knownFields() {
    var knownFields = ['eventType', 'eventVersion', 'extRefUrl', 'hostApp', 'refApp', 'refUrl', 'requestStartTime', 'responseStartTime', 'responseEndTime', 'pageHistory', 'pageLoadTime', 'pageRenderTime', 'searchFilters', 'searchTerm'];

    return knownFields;
};

// ********************* ACCESSOR FUNCTIONS *********************
/**
 * We create accessor functions for every data field because:
 * 1. Cleans/simplifies all methods that use it.
 * 2. Facilitates writing test case shims
 * 3. Allows specific feature suppliers to be overridden (via setDelegate())
 */

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Page.prototype.eventType = function (callerSuppliedEventFields) {
    return 'page';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Page.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 1;
};

/**
 * If a value for this accessor's field exists in "callerSuppliedEventFields", the accessor may want to honor the caller's desire and return that, iff no massaging is needed.
 * Returns an array of the past <= 5 values of 'page' fields from prior page events,
 * storing the current value for use in the next request
 * @param {Map} callerSuppliedEventFields - NOTE: If you want to use one of these fields to help derive *this* eventField, you should
 * invoke it's accessor, if one is available, in case *it's* value is derived or massaged.
 * @return {Array} The past 5 or fewer page event's 'page' fields, *not including* the current page.
 */
Page.prototype.pageHistory = function pageHistory(callerSuppliedEventFields) {
    var returnValue;

    callerSuppliedEventFields = callerSuppliedEventFields || {};
    if (callerSuppliedEventFields.pageHistory) {
        returnValue = callerSuppliedEventFields.pageHistory;
    } else {
        returnValue = this.pageHistoryCache.slice(0); // returns a clone
        var currentPageName = callerSuppliedEventFields.page;

        if (currentPageName) {
            if (this.pageHistoryCache.length >= 5) {
                this.pageHistoryCache.shift();
            }
            this.pageHistoryCache.push(currentPageName);
        }
    }
    return returnValue;
};

/*
 *  src/metrics/event_handlers/search.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Search = function Search(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Search.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. pageId, pageType, pageContext)
 * @param {String} pageId required for all event creation. Indicates the id of the page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * The type of ID may vary (e.g. adam id, grouping id, result id, etc), but is generally
 * the identifier in some persistent store. Search Results pages may have a pageId which refers to their specific dataSet,
 * otherwise known as dataSetId. If the page is better identified by a descriptive string rather than a content ID,
 * this field may be hard-coded, but it should be unique within the set of pages displayable by the app.
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client.
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageType required for all event creation. Indicates the type of page this event took place on.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * This value should represent the group of pages (e.g. "Genre", “Album”, “Grouping”, "Picker", "Recommendations", "Feed",
 * "Search", "Subscribe", etc.).
 * If an application is not client/server "page" oriented (where the client needs to request data from the server for each "page" of the app), then
 * this field would be generated by the client (potentially being hard-coded).
 * Note: A unique "page" value will created by concatenating pageType+"_"+pageId
 * @param {String} pageContext required for all event creation. Indicates the context within which a page is viewed.
 * This value *will* be overridden if found in any of the provided callerSuppliedEventFieldsMapN dictionaries, which is consistent with later dictionary fields overriding earlier ones.
 * Contexts usually provide independent streams of activity and can typically appear as UI "tab" elements or primary navigation elements.
 * @example: iTunes Desktop: “InTheStore” or “Main”.
 * @example: iOS iTunes apps: tab name (e.g. “Featured”, “TopCharts”, etc)
 * @example: iOS Store sheets:  “Sheet” (e.g. AppStore page launched as a sheet within Mail, Springboard’s “Near Me”, Maps’ “Nearby Apps”)
 * @example a "hint", "related" click, "filter" click, etc.
 * If this event is representing a plain typed search, this field's value may be null
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the known page fields will be included
 * @example metrics.eventHandlers.page.metricsData(appData.pageId, appData.pageType, appData.pageContext, element, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Search.prototype.metricsData = function (pageId, pageType, pageContext /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var base = this._metricsKit.eventHandlers.base;
    // TODO:ATHOMPSON: Add back in with ability to add/not add targetElement param
    return base.processMetricsData.apply(this, arguments);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Search.prototype.knownFields = function knownFields() {
    var knownFields = ['actionDetails', 'actionType', 'actionUrl', 'eventType', 'eventVersion', 'filters', 'location', 'targetId', 'targetType', 'term'];

    return knownFields;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Search.prototype.eventType = function (callerSuppliedEventFields) {
    return 'search';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Search.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 2;
};

/*
 *  src/metrics/event_handlers/transaction.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Creates and returns an object (key/value data map (dictionary)) containing all of the fields needed for this metrics event.
 * To override any functionality in this class, use the "setDelegate() method in order to override the specific functions that need customization.
 * @delegatable
 * @constructor
 */
var Transaction$1 = function Transaction(metricsKit) {
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Transaction$1.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Creates a simple map object (dictionary) with all the fields required by Figaro for this event
 * Some fields can be derived by this class itself.
 * Some fields need to be provided by callers (e.g. the transaction fields and values)
 * @param {Map<String:Any>} transactionMetrics key/value pairs associated with this transaction; typically provided in the response from the buyProduct endpoint
 * @param {varargs} callerSuppliedEventFieldsMapN a variable number of Object arguments from 0-N, each containing key/value pairs representing event fields to include with the returned metricsData
 * All event fields will be merged.
 * An attempt will be made to invoke an accessor method for each field, providing the caller the opportunity to override accessor methods.
 * If no accessor method is found, the event field value will be included in the returned metricsData as-is.
 * Later objects take precedence over earlier ones, overriding any field value that may have already been there.
 * If this parameter is null or omitted, only the transaction metrics will be included
 * @example metrics.eventHandlers.transaction.metricsData(buyProductResponseMetrics, {some:"some", known:"known", eventFieldValues:"eventFieldValues"}, someOtherKnownEventValues, appData.someAdditionalBaseFieldValues);
 * @returns key/value pairs of all event fields + "base" fields required by Figaro.
 * WARNING: May return "null" if metrics are disabled via the metrics.disabled config source value, or on error.
 * @overridable
 */
Transaction$1.prototype.metricsData = function metricsData(transactionMetrics /*, callerSuppliedEventFieldsMapN(varargs)*/) {
    var argsArray = [null, null, null].concat(Array.prototype.slice.call(arguments));
    return this._metricsKit.eventHandlers.base.processMetricsData.apply(this, argsArray);
};

/**
 * Returns all the fields that this eventHandler knows about.
 * The eventHandler may have accessor functions which derive some of these fields.
 * The "metricsData()" method will use this list of fields to attempt to invoke accessor methods to get field values.
 * Therefore, if callers override this function, and add additional values, and provide accessors for those values, then
 * the "metricsData()" function will ultimately call those accessors as well.
 * @return all the fields that this eventHandler knows about
 */
Transaction$1.prototype.knownFields = function knownFields() {
    var knownFields = ['eventType', 'eventVersion'];

    return knownFields;
};

/**
 * The type of event this is
 * @returns {String}
 * @overridable
 */
Transaction$1.prototype.eventType = function (callerSuppliedEventFields) {
    return 'transaction';
};

/**
 * The version of the set of data to be sent up
 * @returns {number}
 * @overridable
 */
Transaction$1.prototype.eventVersion = function (callerSuppliedEventFields) {
    return callerSuppliedEventFields && callerSuppliedEventFields.eventVersion || 1;
};

/*
 *  src/metrics/event_handlers/index.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

var EventHandlers = function EventHandlers(metricsKitInstance) {
    this.account = new Account(metricsKitInstance);
    this.base = new Base$1(metricsKitInstance);
    this.buyConfirmed = new BuyConfirmed(metricsKitInstance);
    this.click = new Click(metricsKitInstance);
    this.dialog = new Dialog(metricsKitInstance);
    this.enter = new Enter(metricsKitInstance);
    this.exit = new Exit(metricsKitInstance);
    this.flexible = new Flexible(metricsKitInstance);
    this.impressions = new Impressions(metricsKitInstance);
    this.media = new Media(metricsKitInstance);
    this.page = new Page(metricsKitInstance);
    this.search = new Search(metricsKitInstance);
    this.transaction = new Transaction$1(metricsKitInstance);

    delegateExtension.attachDelegateInfo(this.account);
    delegateExtension.attachDelegateInfo(this.base);
    delegateExtension.attachDelegateInfo(this.buyConfirmed);
    delegateExtension.attachDelegateInfo(this.click);
    delegateExtension.attachDelegateInfo(this.enter);
    delegateExtension.attachDelegateInfo(this.exit);
    delegateExtension.attachDelegateInfo(this.flexible);
    delegateExtension.attachDelegateInfo(this.impressions);
    delegateExtension.attachDelegateInfo(this.media);
    delegateExtension.attachDelegateInfo(this.page);
    delegateExtension.attachDelegateInfo(this.search);
    delegateExtension.attachDelegateInfo(this.transaction);
};

/*
 *  src/metrics/utils/event_fields.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Removes duplicate impressions from an array of sibling impressions (i.e. impressions with the same parent) based on whether its index is unique
 * This is needed because the impressions spec:
 *      https://connectme.apple.com/docs/DOC-240953
 * states that:
 *      iii. If items come into view, then go out of view, then come back, they are not counted twice.
 * So, if a user scrolls a swoosh away from a lockup, and then back, so that the lockup is in view again, it will appear twice (with the same index-within-parent) in the impressions-object-tree
 * returned from ITMLKit, but we don't want it included twice, so we remove the dupes here.
 * NOTE: This should never happen with an impressions list retrieved via "itms.snapshotImpressions()" but for caller-simplicity, and since our caller is typically walking the tree already, some of our callers may invoke it even when unnecessary.
 * @param  {Array} impressions An array of impressions to dedupe
 * @return {Array} A set of unique impressions
 */
var dedupeSiblingImpressions = function dedupeSiblingImpressions(impressions) {
    var uniqueIndices = {};
    var dedupedSiblingImpressions = [];
    var currentIndex;
    if (impressions && impressions[0] && impressions[0].index !== undefined) {
        for (var i = 0; i < impressions.length; ++i) {
            currentIndex = impressions[i].index;
            if (!uniqueIndices[currentIndex]) {
                uniqueIndices[currentIndex] = true;
                dedupedSiblingImpressions.push(impressions[i]);
            }
        }
    }
    return dedupedSiblingImpressions;
};

/**
 * These routines are useful for clients to create and access Metrics data and config
 * @constructor
 */
var EventFields$1 = function EventFields$1(metricsKit) {
    // @private
    this._metricsKit = metricsKit;
};

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */
/**
 * Uses the provided id to generate its idType
 * @param {String} idString The id to generate a type for
 * @return {String} The idType of the provided id
 */
EventFields$1.prototype.getIdType = function (idString) {
    var config$$1 = this._metricsKit.config;
    var defaultPrefix = 'its';
    var prefixSeparatorIndex = idString.indexOf('.');
    var separator = config$$1.value('compoundSeparator');
    var prefix = prefixSeparatorIndex !== -1 ? idString.substring(0, prefixSeparatorIndex) : defaultPrefix;

    return prefix + separator + 'id';
};

/**
 * This method is the workhorse of all the various eventHandlers.
 * It will take all of the parameters of the callers "metricsData()" method, merge them together,
 * invoke accessors on their known fields, and return the resultant map.
 * @param eventHandler the calling eventHandler
 * @param knownFields the calling eventHandler's list (array) of strings that are that handler's known field values.
 * If the caller has accessors to be invoked, they must be present in the "knownFields" array
 * @returns {Arguments} all of the arguments that the calling eventHandler received.
 * @example:
 * Page.prototype.metricsData = function(pageId, pageType, pageContext, eventFieldsMapN(varargs))
 *      {return utils.eventFields.processMetricsData(this, arguments);
 */
EventFields$1.prototype.processMetricsData = function (eventHandler, knownFields, pageId, pageType, pageContext, callerSuppliedEventFieldsMapsArray) {
    // Combine all passed-in fields...
    var combinedFieldsMapsArray = [{
        pageId: pageId,
        pageType: pageType,
        pageContext: pageContext
    }];
    if (reflect$1.isArray(callerSuppliedEventFieldsMapsArray)) {
        combinedFieldsMapsArray = combinedFieldsMapsArray.concat(callerSuppliedEventFieldsMapsArray);
    }

    return event_fields.processMetricsData(eventHandler, knownFields, true, combinedFieldsMapsArray);
};
/**
 * Returns an object containing the intersection of properties in
 * data and matching string values in the fieldMap property corresponding to 'sectionName'
 * ( e.g. fieldMap.custom[sectionName] is an object containing arrays of strings which
 * correspond to the keys desired in the mappedFields object )
 * @param {Object} data The model data corresponding to element we're mapping fields for
 * @param {String} sectionName Specifies which custom fieldMap to use (eg: 'impressions', 'location', or 'custom')
 * @return {Object} Contains intersection of data and fieldsMap values
 * @example
 * // where impressionFieldsMapSection = {
 * //   impressionType: ['type', 'impressionType'],
 * //   id: ['targetId', 'id']
 * //};
 * applyFieldsMap({type: 'button', id: '123', name: 'playbutton'}, 'impressions')
 * // returns {impressionType: 'button', id: '123'}
 */
EventFields$1.prototype.applyFieldsMap = function (data, sectionName) {
    var fieldsMap;
    var fieldsMapSection;
    var mappedFields;
    var config$$1 = this._metricsKit.config;

    if (data && sectionName) {
        mappedFields = {};
        fieldsMap = config$$1.value('fieldsMap') || {};
        fieldsMapSection = key_value.valueForKeyPath(sectionName, fieldsMap, fieldsMap.custom);
        if (fieldsMapSection) {
            var i;
            if (Array.isArray(fieldsMapSection)) {
                for (i = 0; i < fieldsMapSection.length; ++i) {
                    if (data[fieldsMapSection[i]]) {
                        mappedFields[fieldsMapSection[i]] = data[fieldsMapSection[i]];
                    }
                }
            } else if ((typeof fieldsMapSection === 'undefined' ? 'undefined' : _typeof(fieldsMapSection)) === 'object') {
                for (var key in fieldsMapSection) {
                    for (i = 0; i < fieldsMapSection[key].length; ++i) {
                        var test = key_value.valueForKeyPath(fieldsMapSection[key][i], data);
                        if (test) {
                            mappedFields[key] = test;
                            break;
                        }
                    }
                }
            } else {
                this._metricsKit.system.logger.error('mt-metricskit: incorrect data type provided to applyFieldsMap (only accepts objects and Arrays)');
            }
        } else {
            this._metricsKit.system.logger.error('mt-metricskit: unable to get fieldsMap from config-source');
        }
    } else {
        if (!data) {
            this._metricsKit.system.logger.error('mt-metricskit: No data provided to applyFieldsMap');
        }
        if (!sectionName) {
            this._metricsKit.system.logger.error('mt-metricskit: No sectionName provided to applyFieldsMap');
        }
    }
    return mappedFields;
};
/**
 * Creates a deduped & flattened representation of the list of impressions tree nodes provided
 * reassigns some impressions values for use with metrics processing
 * @param {Array} impressions Array of IKJSImpressions objects
 * @param {number} currentId The index at which to increment impresionId off of
 * @return {Array} impressionsArray array of Objects corresponding to and created from
 *                                  data in impressions
 */
EventFields$1.prototype.flattenImpressions = function (impressions, currentId) {
    var impressionsArray = [];
    var anImpression;
    var impressionData;
    var childrenArray;
    var decodedData;
    var impressionId = currentId || 1;

    if (impressions) {
        impressions = dedupeSiblingImpressions(impressions);
        for (var i = 0; i < impressions.length; i++) {
            anImpression = impressions[i];
            if (typeof anImpression.data === 'string') {
                try {
                    impressionData = JSON.parse(anImpression.data);
                } catch (anException) {
                    // Lets' see if the exception happened because someone put URIEncoded data in the impression...
                    decodedData = decodeURIComponent(anImpression.data);
                    try {
                        impressionData = JSON.parse(decodedData);
                    } catch (anotherException) {
                        // So, the error is not [necessarily] due to encoding. Let's not kill the app here by letting this exception propogate, throw the original exception.
                        // (see the discussion about catching exceptions here in this radar: <rdar://problem/23810404> Metricskit: JSON parse error in flattenImpressions
                        this._metricsKit.system.logger.error('mt-metricskit: non-JSON serialized data found on impression object. Cannot parse.', anException);
                    }
                }
            } else {
                impressionData = anImpression;
            }
            if (impressionData) {
                impressionData.impressionTimes = anImpression.timestamps;
                impressionData.impressionIndex = anImpression.index;
                if (impressionData.id && !impressionData.idType) {
                    if (anImpression.kind === 'genre') {
                        // Remove when server provides genre id prefixes
                        var config$$1 = this._metricsKit.config;
                        impressionData.idType = 'label' + config$$1.value('compoundSeparator') + 'id';
                    } else {
                        impressionData.idType = this.getIdType(impressionData.id.toString());
                    }
                }
                if (anImpression.parent && anImpression.parent.impressionId !== undefined) {
                    // if no parent, parent === null
                    impressionData.impressionParentId = anImpression.parent.impressionId;
                }
                impressionData.impressionId = impressionId;
                anImpression.impressionId = impressionId; // saves this value for use as parentId
                ++impressionId;
                impressionsArray.push(impressionData);
                if (key_value.valueForKeyPath('children.length', anImpression) > 0) {
                    childrenArray = this.flattenImpressions(anImpression.children, impressionId);
                    impressionsArray = impressionsArray.concat(childrenArray);
                    impressionId += childrenArray.length;
                }
            }
        }
    } else {
        this._metricsKit.system.logger.warn('Fuse-Metrics: No impressions provided to to flattenImpressions');
    }
    return impressionsArray;
};

/**
 * Returns a flat array representing the location of the clicked element
 * @param {Object} targetElement The clicked element, requires attribute data-metrics-location with obj key of locationType
 * @param {Function} locationFn a function that takes an element as an argument and calculates
 *     the location dictionary for that element
 * @return {Array} A flat array representing the location of the target element
 */
EventFields$1.prototype.buildLocationStructure = function buildLocationStructure(targetElement, locationFn) {
    var currentElement = targetElement;
    var locationStack = [];
    var location;

    //loop and add element locations to the the location stack to be returned
    while (currentElement) {
        location = locationFn.call(locationFn, currentElement);
        if (location) {
            locationStack.push(location);
        }

        currentElement = currentElement.parentNode;
    }
    return locationStack;
};

/*
 *  src/network.js
 *  mt-metricskit
 *
 *  Copyright © 2018 Apple Inc. All rights reserved.
 *
 */

/**
 * Network request methods exposed so delegate callers can override
 * @constructor
 */
var Network = function Network() {};

/**
 * Allows replacement of one or more of this class' functions
 * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
 * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
 * Your delegate can be a true object instance, an anonymous object, or a class object.
 * Your delegate is free to have as many additional non-matching methods as it likes.
 * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
 *
 * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
 * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
 * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
 * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
 * but override the "appVersion" method again, this time with their own supplied delegate.
 *
 * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
 * This allows the delegate to, essentially, call "super" before or after it does some work.
 * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
 * @example:
 * To override one or more methods, in place:
 *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
 * To override one or more methods with a separate object:
 *      eventRecorder.setDelegate(eventRecorderDelegate);
 *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
 *                                       sendMethod: 'itms'};
 * To override one or more methods with an instantiated object from a class definition:
 *      eventRecorder.setDelegate(new EventRecorderDelegate());
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
 *                                                          return 'itms';
 *                                                      };
 * To override one or more methods with a class object (with "static" methods):
 *      eventRecorder.setDelegate(EventRecorderDelegate);
 *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
 *          function EventRecorderDelegate() {
 *         }
 *         EventRecorderDelegate.recordEvent = itms.recordEvent;
 *         EventRecorderDelegate.sendMethod = function sendMethod() {
 *                                                return 'itms';
 *                                            };
 * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
 * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
 * otherwise returns false.
 */
Network.prototype.setDelegate = function setDelegate(delegate) {
    return reflect$1.attachDelegate(this, delegate);
};

/**
 * Covers private util network functions for delegation
 */
Network.prototype.makeAjaxRequest = network.makeAjaxRequest;

/*
 *  src/metrics/utils/reflect.js
 *  mt-metricskit
 *
 *  Copyright © 2015 Apple Inc. All rights reserved.
 *
 */

/**
 * Object Reflection Primitive Methods (e.g. "Map" type methods)
 * copied from private utils so delegate callers can use them
 * @constructor
 */
var reflect$$1 = {
    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */
    /**
     * Replace any "target" methods found on "delegate" with the delegate's version of the method.
     * The replacement function will actually be our own wrapper function with the original function attached as a property called origFunction
     * in case the delegate's replacement method wants to, essentially, call "super"
     * We do delegation this way, vs. checking each time a "target" function is called, because this way we don't pollute the implementation
     * of all the target's functions.
     * Subsequent calls to "attachDelegate" will then replace whatever methods *they* match, including methods that have already been replaced.
     * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
     * NOTE: Only methods present on "target" will be replaced. If a delegate method is not found on target, "false" will be returned.
     * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
     * @param target
     * @param delegate
     * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
     */
    attachDelegate: function attachDelegate(target, delegate) {
        return reflect$1.attachDelegate(target, delegate);
    },

    /**
     * Adds all the fields of the objects in the varargs to the fields in the first parameter, "obj".
     * *All* "hasOwnProperty" fields will be added, including functions and fields with no values.
     * @param {Object} targetObject an object with keys and values. If only one parameter is provided, the return value will be the non-null values of that single object.
     * @param {varargs} sourceObjectN a variable number of Object arguments from 0-N. Each object's fields will be copied into targetObject. Later objects take precedence over earlier ones.
     * @return targetObject (*not* a clone) with the additional fields added..
     */
    extend: function extend(targetObject /* , ...sourceObjectN(varargs) */) {
        return reflect$1.extend.apply(reflect$1, arguments);
    },

    /**
     * Bind the execution context of the methods of given Object to itself.
     * NOTE: Only bind the functions that are owned by the parameter object
     * @param {Object} targetObject an object with keys and values.
     */
    bindFunctionsContext: function bindFunctionsContext(targetObject) {
        if (targetObject) {
            for (var key in targetObject) {
                if (typeof targetObject[key] === 'function') {
                    targetObject[key] = targetObject[key].bind(targetObject);
                }
            }
        }
    }
};

/*
 *  src/metrics/utils/string.js
 *  mt-metricskit
 *
 *  Copyright © 2015-2017 Apple Inc. All rights reserved.
 *
 */

/**
 * String related util methods
 * copied from private utils so delegate callers can use them
 * @constructor
 */
var string$$1 = {
    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */
    /**
     * Parses a user agent string for a particular product name and returns its version
     * @param {String} userAgent that conforms with RFC 7231 section 5.5.3 regarding User-Agents
     * @param {String} (optional) productName the name of a product identifier to search for e.g. 'iTunes'; if omitted, defaults to the first identifier
     * @return {String} the version of the product, or null if none found
     * @example
     *      productVersionFromUserAgent('iTunes/12.6 (Macintosh; OS X 10.12.4) AppleWebKit/603.1.30.0.34') returns '12.6'
     *      productVersionFromUserAgent('iTunes/12.6 (Macintosh; OS X 10.12.4) AppleWebKit/603.1.30.0.34', 'AppleWebKit') returns '603.1.30.0.34'
     *      productVersionFromUserAgent('iTunes/12.6 (Macintosh; OS X 10.12.4) AppleWebKit/603.1.30.0.34', 'Macintosh') returns null
     *          (strings contained in parentheses are counted as comments, not product identifiers)
     */
    versionStringFromUserAgent: function versionStringFromUserAgent(userAgent, productName) {
        return string$1.versionStringFromUserAgent(userAgent, productName);
    }
};

/*
 *  src/metrics/utils/index.js
 *  mt-metricskit
 *
 *  Copyright © 2015-2016 Apple Inc. All rights reserved.
 *
 */

var Utils = function Utils(mtkitInstance) {
    // TODO if no client is using it, maybe it could be removed from Utils class
    this.delegateExtension = delegateExtension;
    // assign new eventFields instance to utils, to give eventFields the metricsKit instance context.
    this.eventFields = new EventFields$1(mtkitInstance);
    // bind the context to eventHandlers to avoid losing the runtime context if the client assign function to a variable.
    reflect$$1.bindFunctionsContext(this.eventFields);

    // copy keyValue from private utils for historical reasons in case clients are using it
    // this can probably be removed with more research
    // TODO if no client is using it, maybe it could be removed from Utils class
    this.keyValue = key_value;
    this.network = new Network();
    // TODO if no client is using it, maybe it could be removed from Utils class
    this.reflect = reflect$$1;
    // TODO if no client is using it, maybe it could be removed from Utils class
    this.string = string$$1;
};

/*
 *  src/utils/event_field_accessors/base.js
 *  mt-metricskit
 *
 *  Copyright © 2021 Apple Inc. All rights reserved.
 *
 */

var Base = function Base(metricsKit) {
    // @private
    this._metricsKit = metricsKit;

    // @private
    // create a subclass instance of Base class to trigger the constraints in base.processMetricsData()
    this._baseEventHandler = Object.create(this._metricsKit.eventHandlers.base);
};

/**
 ************************************ PUBLIC METHODS ************************************
 */

/**
 * Return the corresponding clientId with the giving status
 * @param {Object} qualifiers
 * @param {Boolean} qualifiers.isSignedIn - A boolean value indicating the returned clientId is for signed-in status or signed-out status.
 * @returns {String|null} the clientId, will return null if
 *      1. config has not been initialized
 *      2. the entire event is denied by config
 *      3. the clientId is a denied field
 */
Base.prototype.clientId = function clientId(qualifiers) {
    if (!this._metricsKit.config.initialized()) {
        this._metricsKit.system.logger.error('Unable to load topic config, please invoke clientId() after MetricsKit is initialized.');
        return null;
    }
    var eventFields$$1 = this._baseEventHandler.metricsData(null, null, null, qualifiers);
    return eventFields$$1 ? eventFields$$1.clientId : null;
};

/*
 *  src/event_fields/index.js
 *  mt-metricskit
 *
 *  Copyright © 2021 Apple Inc. All rights reserved.
 *
 */

var EventFields = function EventFields(metricsKitInstance) {
    this.base = new Base(metricsKitInstance);
};

/*
 *  src/metrics/clickstream_processor.js
 *  mt-metricskit
 *
 *  Copyright © 2020 Apple Inc. All rights reserved.
 *
 */

// @private
var _getSanitizedOptions = function _getSanitizedOptions(metricsKitInstance, options) {
    options = options || {};
    var sanitizedOptions = {
        onSuccessHandler: null,
        onFailureHandler: null,
        configSourcesFn: null
    };
    sanitizedOptions.configSourcesFn = options.configSourcesFn;
    sanitizedOptions.onSuccessHandler = options.onSuccessHandler;
    sanitizedOptions.onFailureHandler = options.onFailureHandler;
    return sanitizedOptions;
};

/**
 * Supplies a JavaScript entrypoint to metrics functionality
 * Since JavaScript is prototype-based and not class-based, and  doesn't provide an "official" object model, this API is presented as a functional API, but still retains the ability to
 * override and customize functionality via the "setDelegate()" method. In this way, it doesn't carry with it the spare baggage of exposing a bolt-on object model which may
 * differ from a bolt-on (or homegrown) object model already existing in the app.
 * @module src/metrics
 * @param {String} topic - Defines the AMP Analytics "topic" that this event should be stored under
 * @param {Object}  delegates - The below interface will be generated by Metrics delegates(mt-metricskit-delegates-*). Clients don't have to generate it by themselves
 *                               For more details, please reference the respective document of mt-metricskit-delegates-*
 * @constructor
 */
var ClickstreamProcessor = function ClickstreamProcessor(topic, delegates) {

    /**
     ************************************ PRIVATE IVARS ************************************
     */

    // @private
    this._initCalled = false;

    // @private
    this._delegatePackage = delegates;

    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */

    /**
     * Access the various "system" classes defined in ClickstreamProcessor.
     * These classes are typically system/platform specific
     * These classes can have their functionality replaced either en masse or piecemeal via the setDelegate() method.
     * Available system classes are:
     *      environment
     *      eventRecorder
     *      logger
     * @example: metrics.system.environment.setDelegate(myEnvironmentFunctions)
     * @see setDelegate()
     */
    this.system = new System();

    /**
     * Access the various configuration values.
     * These are basically pretty wrappers on config fields retrieved via the "configValue" method.
     * Note: Must be created in the constructor in order for a client to set a debug source before fetching config with init()
     * @example: metrics.config.isDisabled()
     */
    this.config = Config.getConfig(topic);

    /**
     * Sub-library providing access to all the various eventHandlers of ClickstreamProcessor.
     */
    this.eventHandlers = new EventHandlers(this);

    /**
     * Sub-library providing access to all the various eventFields of ClickstreamProcessor.
     */
    this.eventFields = new EventFields(this);

    /**
     * Sub-library providing various utility functions which are useful when interacting with ClickstreamProcessor
     */
    this.utils = new Utils(this);

    this._constraints = null;

    if (!reflect$1.isDefined(topic)) {
        this.system.logger.error('No topic is provided to ClickstreamProcessor.');
    }

    if (!reflect$1.isDefinedNonNull(delegates)) {
        this.system.logger.error('No delegate is provided to ClickstreamProcessor');
    }
};

/**
 * Initialize ClickstreamProcessor - will register, fetch config, set delegates, etc.
 * NOTE: This API should not be called more than once. Subsequent calls will have no effect (no-op).
 * NOTE 2: This function initializes metrics config values which are required for proper event generation.
 *         This initialization will be asynchronous unless a configSourcesFn is provided.
 *         Events that are generated before initialization have completed will use config defaults.
 *         If clients want to ensure that config is fetched before events are generated,
 *         they can do one of the following when calling clickstreamProcessor.init():
 *                (1) provide a configSourcesFn; in existing clients the config sources function is provided via the metrics.config.setDelegate() API
 *                (2) wait until the init() callback completes before generating and recording any events (Note that when using this method,
 *                    any user actions that occured before the callback completes will have later eventTimes than when they actually occured)
 *
 * ADDITIONAL DESIGN NOTES:
 * Promise/PubSub:
 *     These would require some polyfill or additional module support, which we do not want to bake into our framework.
 *     We will expect that clients will honor the init() contract by not calling it more than once, and we provide a completion callback.
 * Deferring event generation:
 *     We could store a queue of events to generate once we have config. However, this is complex and error prone, and requires
 *     the eventRecorder to have special knowledge that this is happening and knowledge about how to properly generate those events
 *     (for example, the eventTime should reflect the time the deferred event was queued, not the time it was later generated).
 * Using defaults:
 *     Most config values are common to the majority of apps and do not change very much, so in the interest of simplicity,
 *     we choose to fall back to default config values for any events generated before config resolves.
 *     The ingestion server will enrich clientId on events in a batch missing clientId.
 *     As an additional fallback, we store the most recently fetched config in localStorage for any future visits from the same browser.
 *
 * @param {Object} options (optional)
 *  {
 *      onSuccessHandler (optional), - function to execute on success, the function won't be invoked if the ClickstreamProcessor instance has been initialized
 *      onFailureHandler (optional), - function to execute on failure
 *      configSourcesFn (optional) - a function that returns an array of key/value objects (dictionaries) for all of the config sources
 *                                     (e.g. the bag, the page, the control parent, etc.).
 *  }
 */
ClickstreamProcessor.prototype.init = function init(options) {
    if (!this._initCalled) {
        this._initCalled = true;
        options = _getSanitizedOptions(this, options);
        // Init config
        initializeConfig(this.config, {
            configSourcesFn: options.configSourcesFn,
            onSuccessHandler: options.onSuccessHandler, // TODO need to provide a callback to onConfigLoad, and call delegates.onSuccessHandler when 1. config is loaded, 2. ClickstreamProcessor initializing completed. (Maybe when working on Promise feature)
            onFailureHandler: options.onFailureHandler, // TODO need to provide a callback to onConfigLoadFailure, and call delegates.onFailureHandler when 1. load config failed, 2. failed to initialize ClickstreamProcessor. (Maybe when working on Promise feature)
            delegates: {
                environment: this.system.environment,
                logger: this.system.logger,
                network: this.utils.network
            }
        });

        this._constraints = new Constraints(this.config, {
            environment: this.system.environment
        });

        // set any provided delegates
        if (this._delegatePackage) {
            reflect$1.setDelegates(this.eventHandlers, this._delegatePackage);
            reflect$1.setDelegates(this.system, this._delegatePackage);
            reflect$1.setDelegates(this.utils, this._delegatePackage);
        }
    }
};

/**
 * Release resources from MetricsKit
 */
ClickstreamProcessor.prototype.cleanup = function cleanup() {
    if (this._delegatePackage && reflect$1.isFunction(this._delegatePackage.cleanup)) {
        // cleanup delegate before cleanup config, in case the cleanup method of delegate uses the config
        this._delegatePackage.cleanup();
    }
    cleanupConfig(this.config);
    reflect$1.resetDelegates(this.eventHandlers);
    reflect$1.resetDelegates(this.system);
    reflect$1.resetDelegates(this.utils);
    this.config = null;
    this.system = null;
    this.eventHandlers = null;
    this.utils = null;
    this._delegatePackage = null;
    this._constraints = null;
    this._initCalled = false;
};

/*
 *  src/environment.js
 *  mt-event-queue
 *
 *  Copyright © 2016-2019 Apple Inc. All rights reserved.
 *
 */

var attachDelegate$2$1 = reflect$1.attachDelegate;
var environment$2 = {

    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */

    /**
     * Allows replacement of one or more of this class' functions
     * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
     * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
     * Your delegate can be a true object instance, an anonymous object, or a class object.
     * Your delegate is free to have as many additional non-matching methods as it likes.
     * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
     *
     * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
     * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
     * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
     * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
     * but override the "appVersion" method again, this time with their own supplied delegate.
     *
     * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
     * This allows the delegate to, essentially, call "super" before or after it does some work.
     * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
     * @example:
     * To override one or more methods, in place:
     *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
     * To override one or more methods with a separate object:
     *      eventRecorder.setDelegate(eventRecorderDelegate);
     *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
     *                                       sendMethod: 'itms'};
     * To override one or more methods with an instantiated object from a class definition:
     *      eventRecorder.setDelegate(new EventRecorderDelegate());
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
     *                                                          return 'itms';
     *                                                      };
     * To override one or more methods with a class object (with "static" methods):
     *      eventRecorder.setDelegate(EventRecorderDelegate);
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.sendMethod = function sendMethod() {
     *                                                return 'itms';
     *                                            };
     * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
     * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
     * otherwise returns false.
     */
    setDelegate: function setDelegate(delegate) {
        return attachDelegate$2$1(this, delegate);
    },

    /**
     * An object that conforms to the WindowOrWorkerGlobalScope API:
     * https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope
     * @return {WindowOrWorkerGlobalScope}
     */
    globalScope: function globalScope() {
        return global;
    }
};

/*
 *  src/utils/constants.js
 *  mt-event-queue
 *
 *  Copyright © 2019 Apple Inc. All rights reserved.
 *
 */

// These constants are exposed publicly

/**
* Possible send method types to record events
*/
var SEND_METHOD = {
    AJAX: "ajax",
    AJAX_SYNCHRONOUS: "ajaxSynchronous",
    IMAGE: "image"
};

/*
 *  src/event_recorder/base.js
 *  mt-event-queue
 *
 *  Copyright © 2016-2019 Apple Inc. All rights reserved.
 *
 */

var metricsDisabledOrBlacklistedEvent$1 = config.metricsDisabledOrBlacklistedEvent;
var removeBlacklistedFields$1 = config.removeBlacklistedFields;
// TODO stop having two property caches when this class, queued_event_recorder, immediate_event_recorder and event queue stops being a singleton.
var topicPropsCache = {};
var IDENTIFIABLE_FIELDS = ['dsId', 'consumerId'];

/**
 * Records an event as JSON
 * @param {Function} recordEventHandler a method that, when invoked, will record an event
 * @param {String} topic defines the AMP Analytics "topic" that this event should be stored under
 * @param {Object} eventFields a JavaScript object which will be converted to a JSON string and sent to AMP Analytics immediately.
 * @returns {Object} the recorded event, or "null" if no object was recorded (e.g. if "eventFields" is null, or "disabled" is true, eventFields.eventType is one of the blacklistedEvents, etc.)
 */
function recordEvent(recordEventHandler, topic, eventFields$$1) {
    var returnValue = null;

    // NOTE: Typically all event_handlers will check for this as well because that way if a client overrides "recordEvent", these checks will still take effect.
    //       We also test it here in case someone creates their own event_handler, we'd still want to exclude what needs to be excluded, in case they don't.
    if (eventFields$$1 && !metricsDisabledOrBlacklistedEvent$1.call(Config, eventFields$$1.eventType, topic)) {
        removeBlacklistedFields$1.call(Config, eventFields$$1, topic);
        _removeIdentifiableFieldsForTopic(topic, eventFields$$1);
        recordEventHandler.apply(null, Array.prototype.slice.call(arguments, 1));
        returnValue = eventFields$$1;
    }
    return returnValue;
}

/**
 * The methodology being used to send batches of events to the server
 * This field should be hardcoded in the client based on what method it is using to encode and send its events to Figaro.
 * The three typical values are:
 *      "itms" - use this value when/if JavaScript code enqueues events for sending via the "itms.recordEvent()" method in ITML.
 *      "itunes" - use this value when/if JavaScript code enqueues events by calling the "iTunes.recordEvent()" method in Desktop Store apps.
 *      "javascript" - use this value when/if JavaScript code enqueues events for sending via the JavaScript eventQueue management. This is typically only used by older clients which don't have the built-in functionality of itms or iTunes available to them.
 * @example "itms", "itunes", "javascript"
 * @returns {String}
 */
function sendMethod() {
    return 'javascript';
}

/**
 * Set related properties for the giving topic
 * @param {String} topic defines the Figaro "topic" that this event should be stored under
 * @param {Object} properties the properties for the topic
 * @param {Boolean} properties.anonymous true if sending all events for the topic with credentials omitted(no cookies, no PII fields)
 */
function setProperties(topic, properties) {
    topicPropsCache[topic] = topicPropsCache[topic] || {};
    topicPropsCache[topic] = properties;
}

/**
 * release resources
 */
function cleanup$1() {
    topicPropsCache = {};
}

/**
 * Remove identify fields from the eventFields based on the topic properties
 * @param {String} topic defines the Figaro "topic" that this event should be stored under
 * @param {Object} eventFields a JavaScript object which will be converted to a JSON string and sent to AMP Analytics immediately.
 * @private
 */
function _removeIdentifiableFieldsForTopic(topic, eventFields$$1) {
    topicPropsCache[topic] = topicPropsCache[topic] || {};
    if (topicPropsCache[topic].anonymous) {
        IDENTIFIABLE_FIELDS.forEach(function (field) {
            delete eventFields$$1[field];
        });
    }
}

/*
 *  src/network.js
 *  mt-event-queue
 *
 *  Copyright © 2017 Apple Inc. All rights reserved.
 *
 */

var attachDelegate$1$2 = reflect$1.attachDelegate;
var makeAjaxRequest$2 = network.makeAjaxRequest;

/**
 * Network request methods exposed so delegate callers can override
 * @constructor
 */
var network$2 = {
    /**
     * Allows replacement of one or more of this class' functions
     * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
     * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
     * Your delegate can be a true object instance, an anonymous object, or a class object.
     * Your delegate is free to have as many additional non-matching methods as it likes.
     * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
     *
     * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
     * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
     * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
     * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
     * but override the "appVersion" method again, this time with their own supplied delegate.
     *
     * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
     * This allows the delegate to, essentially, call "super" before or after it does some work.
     * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
     * @example:
     * To override one or more methods, in place:
     *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
     * To override one or more methods with a separate object:
     *      eventRecorder.setDelegate(eventRecorderDelegate);
     *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
     *                                       sendMethod: 'itms'};
     * To override one or more methods with an instantiated object from a class definition:
     *      eventRecorder.setDelegate(new EventRecorderDelegate());
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
     *                                                          return 'itms';
     *                                                      };
     * To override one or more methods with a class object (with "static" methods):
     *      eventRecorder.setDelegate(EventRecorderDelegate);
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.sendMethod = function sendMethod() {
     *                                                return 'itms';
     *                                            };
     * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
     * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
     * otherwise returns false.
     */
    setDelegate: function setDelegate(delegate) {
        return attachDelegate$1$2(this, delegate);
    },
    /**
     * Covers private util network functions for delegation
     */
    makeAjaxRequest: makeAjaxRequest$2
};

/*
 *  src/event_queue.js
 *  mt-event-queue
 *
 *  A low-level, cross-platform, metrics batcher and emitter.
 *  Adapted from Jingle (its.MetricsQueue)
 *
 *  Copyright © 2016-2017 Apple Inc. All rights reserved.
 *
 */

var isString$2 = reflect$1.isString;
var isFunction$1 = reflect$1.isFunction;
var configDisabled = config.disabled;

/**
 * Some ugly user agent detection, because iOS browsers refuse to send image pings onpagehide
 * @return {Boolean} true if this browser is running on an iOS device
 */
function _isIOS() {
    var userAgent = navigator.userAgent;

    // IE for Windows Phone 8.1 contains the string 'iPhone', so we have to check for that too...
    // https://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx
    return (/iPad|iPhone|iPod/.test(userAgent) && userAgent.indexOf('IEMobile') == -1
    );
}

function _logger() {
    return loggerNamed('mt-event-queue');
}

var CONSTANTS$1 = {
    DEFAULT_REQUEST_TIMEOUT: 10000, // TODO: move to config
    EVENTS_KEY: "events",
    EVENT_DELIVERY_VERSION: "1.0",
    MAX_PERSISTENT_QUEUE_SIZE: 100, // TODO: move to config
    RETRY_EXPONENT_BASE: 2, // TODO: move to config
    SEND_METHOD: SEND_METHOD,
    URL_DELIVERY_VERSION: 2,
    PROPERTIES_KEY: 'properties'
};

var _eventQueue = {
    /**
     * A dictionary of event queues by topic
     * Each topic queue is an object that holds an array of the events themselves and information about send attempts for that topic (postIntervalToken, retryAttempts)
     * We use an in-memory queue for two reasons:
     * 1) We expect all remaining events to get sent on app exit via flushUnreportedEvents (ignoring the failed send case)
     * 2) Stringifying and writing is expensive - as much as 5ms to write 100 events to localStorage on an older (2013) mobile device,
     *    and that would have to happen each time we did an event insertion, since localStorage only allows the saving of stringified (serialized) data.
     */
    eventQueues: {},

    /**
     * Determines whether events will be sent via a post interval.
     * If this value is false then the client must perform flushing manually and events will not be scheduled or sent automatically.
     */
    postIntervalEnabled: true,

    /**
     * Enqueue an event to a particular topic queue
     * @param {String} topic defines the Figaro "topic" that this event should be stored under
     * @param {Object} eventFields a JavaScript object which will be converted to a JSON string and enqued for sending to Figaro according to the postFrequency schedule
     * @return {Object} the current event, if it was successfully queued, otherwise null
     */
    enqueueEvent: function enqueueEvent(topic, eventFields$$1) {
        var enqueuedEvent = null;

        if (topic && eventFields$$1) {
            _eventQueue.eventQueues = _eventQueue.eventQueues || {};
            _eventQueue.eventQueues[topic] = _eventQueue.eventQueues[topic] || {};
            _eventQueue.eventQueues[topic][CONSTANTS$1.EVENTS_KEY] = _eventQueue.eventQueues[topic][CONSTANTS$1.EVENTS_KEY] || [];
            _eventQueue.eventQueues[topic][CONSTANTS$1.EVENTS_KEY].push(eventFields$$1); // Add the new event to the end of our eventQueue
            enqueuedEvent = eventFields$$1;

            var maxQueueSize = Config.value('maxPersistentQueueSize', topic) || CONSTANTS$1.MAX_PERSISTENT_QUEUE_SIZE;
            _eventQueue.trimEventQueues(_eventQueue.eventQueues, maxQueueSize);
        }

        return enqueuedEvent;
    },

    /**
     * Currently this just ensures that each queue is <= maxEventsPerQueue, but in the future we could remove oldest events in a queue-independent way
     * @param {Object} eventQueues a dictionary of event queues (arrays) by topic
     * @param {int} maxEventsPerQueue
     */
    trimEventQueues: function trimEventQueues(eventQueues, maxEventsPerQueue) {
        var topics = Object.keys(eventQueues);
        if (topics.length) {
            topics.forEach(function (topic) {
                var events = eventQueues[topic][CONSTANTS$1.EVENTS_KEY];
                if (events && events.length && events.length > maxEventsPerQueue) {
                    _logger().warn("eventQueue overflow, deleting LRU events: size is: " + events.length + " which is over max size: " + maxEventsPerQueue);
                    eventQueues[topic][CONSTANTS$1.EVENTS_KEY] = events.slice(-maxEventsPerQueue);
                }
            });
        }
    },

    /**
     * Clears an event queue for a topic
     * @param {String} topic defines the Figaro "topic" queue that should be cleared
     */
    resetTopicQueue: function resetTopicQueue(topic) {
        if (_eventQueue.eventQueues[topic]) {
            _eventQueue.eventQueues[topic][CONSTANTS$1.EVENTS_KEY] = null;
        }
    },

    /**
     * Resets the retry attempt counter for a topic, called when a send for that topic is successful
     * @param {String} topic defines the Figaro "topic" queue whose counter should be cleared
     */
    resetTopicRetryAttempts: function resetTopicRetryAttempts(topic) {
        if (_eventQueue.eventQueues[topic]) {
            _eventQueue.eventQueues[topic].retryAttempts = 0;
        }
    },

    /**
     * Increments the retry attempt counter for a topic, called when a send for that topic results in a 5XX response
     * Sets the next send time for the topic according to an exponential backoff strategy
     * @param {String} topic defines the Figaro "topic" queue whose counter should be incremented
     */
    scheduleNextTopicRetryAttempt: function scheduleNextTopicRetryAttempt(topic) {
        if (_eventQueue.eventQueues[topic] && this.postIntervalEnabled) {
            _eventQueue.eventQueues[topic].retryAttempts = _eventQueue.eventQueues[topic].retryAttempts || 0;
            _eventQueue.eventQueues[topic].retryAttempts++;

            var nextSendTime = Math.pow(CONSTANTS$1.RETRY_EXPONENT_BASE, _eventQueue.eventQueues[topic].retryAttempts) * Config.value('postFrequency', topic);
            _eventQueue.resetTopicPostInterval(topic);
            _eventQueue.setTopicPostInterval(topic, nextSendTime);
        }
    },

    /**
     * Send queued events to the ingestion server
     * If a particular topic send has previously failed, RETRY_BACKOFF_SKIP_COUNT_KEY will be nonzero, indicating we should skip sending that number of times
     * @param {String} sendMethod "image" or "ajax" (default) or "ajaxSynchronous"
     * @param {Boolean} postNow will be true when clients force a send outside of the regular postFrequency interval
     */
    sendEvents: function sendEvents(sendMethod, postNow) {
        for (var topic in _eventQueue.eventQueues) {
            _eventQueue.sendEventsForTopic(topic, sendMethod, postNow);
        }
    },

    /**
     * Send events for a single topic queue
     * @param {String} topic defines the Figaro "topic" queue
     * @param {String} sendMethod "image" or "ajax" (default) or "ajaxSynchronous"
     * @param {Boolean} postNow will be true when clients force a send outside of the regular postFrequency interval
     */
    sendEventsForTopic: function sendEventsForTopic(topic, sendMethod, postNow) {
        var topicQueue = _eventQueue.eventQueues[topic];
        var testExponentialBackoff = Config.value('testExponentialBackoff', topic);
        var metricsUrl = Config.value('metricsUrl', topic);
        var topicDisabled = configDisabled.call(Config, topic);

        if (topicQueue && metricsUrl && !topicDisabled && !testExponentialBackoff) {
            // Do not send if we are trying to postNow in the middle of a backoff
            if (!(topicQueue.retryAttempts && postNow)) {
                // The rule is "we post every postFrequency milliseconds", so even if it's been less than that (e.g. postNow), we reset
                _eventQueue.resetTopicPostInterval(topic);
                _eventQueue.setTopicPostInterval(topic, Config.value('postFrequency', topic));

                switch (sendMethod) {
                    case CONSTANTS$1.SEND_METHOD.IMAGE:
                        _eventQueue.sendEventsViaImage(topic);
                        break;
                    case CONSTANTS$1.SEND_METHOD.AJAX_SYNCHRONOUS:
                        _eventQueue.sendEventsViaAjax(topic, false);
                        break;
                    case CONSTANTS$1.SEND_METHOD.AJAX: /* falls through */
                    default:
                        _eventQueue.sendEventsViaAjax(topic, true);
                        break;
                }
            }
        }

        // Fail automatically if test flag present
        if (testExponentialBackoff) {
            _eventQueue.scheduleNextTopicRetryAttempt(topic);
        }
    },

    /**
     * Makes one image ping per event in a queue of events, then clears the queue
     * This is typically called on page / app close when the JS context is about to disappear and thus we will not know if the events made it to the server
     * Current testing shows that browsers support 100+ image pings sent onpagehide, but we may need to alter our approach if this becomes unreliable
     * (For example, we could send multiple events in a single ping instead, but there might be URL length issues in IE)
     * @param {String} topic defines the Figaro "topic" to send to
     */
    sendEventsViaImage: function sendEventsViaImage(topic) {
        if (_eventQueue.eventQueues[topic]) {
            var topicUrl = metricsUrlForTopic(topic);
            var qpSeparator = topicUrl.indexOf('?') == -1 ? '?' : '&';
            var imageBaseUrl = topicUrl + qpSeparator + 'responseType=image';

            var events = _eventQueue.eventQueues[topic][CONSTANTS$1.EVENTS_KEY];
            if (events && events.length) {
                events.forEach(function (event) {
                    var imageParams = _eventQueue.createQueryParams(event);
                    if (imageParams) {
                        var imgUrl = imageBaseUrl + '&' + imageParams;
                        var imgObject = new Image();
                        var properties = _eventQueue.eventQueues[topic][CONSTANTS$1.PROPERTIES_KEY];
                        if (properties && properties.anonymous) {
                            imgObject.setAttribute('crossOrigin', 'anonymous');
                        }
                        imgObject.src = imgUrl;
                    }
                });
            }

            _eventQueue.resetTopicQueue(topic);
        }
    },

    /**
     * Convert an event object into a query parameter string, without a leading separator
     * Guaranteed to return "null" if there are no event fields
     * @param {Object} event key/value pairs containing event data
     */
    createQueryParams: function createQueryParams(event) {
        var val;
        var stringVal;
        var returnValue = '';
        Object.keys(event).forEach(function (key, index, eventKeys) {
            val = event[key];
            // do not double-encode strings otherwise they will be reported as: '<value>'
            stringVal = isString$2(val) ? val : JSON.stringify(val);
            returnValue += key + '=' + encodeURIComponent(stringVal);
            if (index < eventKeys.length - 1) {
                // don't add a trailing ampersand
                returnValue += '&';
            }
        });
        return returnValue.length ? returnValue : null;
    },

    /**
     * Makes one AJAX request per topic and clears the queue for that topic on success
     * If any queue fails, retry using an exponential backoff strategy for that queue
     * Refer to Metrics documentation for more details
     * @param {String} topic defines the Figaro "topic" to send to
     * @param {Boolean} async - send asynchronously
     */
    sendEventsViaAjax: function sendEventsViaAjax(topic, async) {
        if (_eventQueue.eventQueues[topic] && _eventQueue.eventQueues[topic][CONSTANTS$1.EVENTS_KEY]) {
            var jsonEventsString = enrichAndSerializeEvents(_eventQueue.eventQueues[topic][CONSTANTS$1.EVENTS_KEY]);
            if (jsonEventsString) {
                var topicUrl = metricsUrlForTopic(topic);
                var requestTimeout = requestTimeoutForTopic(topic);
                var resetQueue = function resetQueue() {
                    // Per the Metrics documentation, *any* 2XX return code
                    // tells us that we are to clear our queue.
                    _eventQueue.resetTopicQueue(topic);
                    _eventQueue.resetTopicRetryAttempts(topic);
                };
                var onAjaxFailure = function onAjaxFailure(error, statusCode) {
                    // We're being told not to keep resending these events.
                    if (statusCode >= 400 && statusCode < 500) {
                        resetQueue();
                    } else {
                        _eventQueue.scheduleNextTopicRetryAttempt(topic);
                    }
                };
                var eventQueueProps = _eventQueue.eventQueues[topic][CONSTANTS$1.PROPERTIES_KEY] || {};
                var options = {
                    async: async,
                    timeout: requestTimeout
                };

                if (eventQueueProps.anonymous) {
                    options.withCredentials = false;
                }

                network$2.makeAjaxRequest(topicUrl, 'POST', jsonEventsString, resetQueue, onAjaxFailure, options);
            }
        }
    },

    /**
     * If no postInterval is currently set, sets postInterval to "postInterval"
     * Note: Currently, only _sendEvents calls this function, but in the future, if other callers wanted to set a new interval due to, say, a config change,
     *       then events enqueued under the old postFrequency time will now have to wait (or be expedited) to the new time. To fix this, when any old
     *       interval fires, the callback can check to see if the interval passed in is different than _eventQueue.postIntervalToken and if so, it will tear down its timer.
     * @param {String} topic
     * @param {int} postInterval in ms
     */
    setTopicPostInterval: function setTopicPostInterval(topic, postInterval) {
        if (_eventQueue.eventQueues[topic] && postInterval && this.postIntervalEnabled) {
            this.resetTopicPostInterval(topic);
            _eventQueue.eventQueues[topic].postIntervalToken = environment$2.globalScope().setInterval(function onPostIntervalTrigger() {
                _logger().debug('MetricsKit: triggering postIntervalTimer for ' + topic + ' at ' + new Date().toString());
                _eventQueue.sendEventsForTopic.call(_eventQueue, topic);
            }, postInterval);
        }
    },

    resetTopicPostInterval: function resetTopicPostInterval(topic) {
        if (_eventQueue.eventQueues[topic]) {
            environment$2.globalScope().clearInterval(_eventQueue.eventQueues[topic].postIntervalToken);
            _eventQueue.eventQueues[topic].postIntervalToken = null;
        }
    },

    resetQueuePostIntervals: function resetQueuePostIntervals() {
        for (var topic in _eventQueue.eventQueues) {
            _eventQueue.resetTopicPostInterval(topic);
        }
    },

    setQueuePostIntervals: function setQueuePostIntervals() {
        for (var topic in _eventQueue.eventQueues) {
            var events = _eventQueue.eventQueues[topic][CONSTANTS$1.EVENTS_KEY];
            if (events && events.length) {
                _eventQueue.setTopicPostInterval(topic, Config.value('postFrequency', topic));
            }
        }
    },

    /**
     * Determines whether the object contains the provided value.
     * Note that values that are functions will be ignored.
     * @param {Object} object the object whose values will be evaluated
     * @param {Any} value the requested value to search for on the provided object
     * @returns {Boolean} whether the object contains the value
     * TODO: consider moving to utils
     */
    objectContainsValue: function objectContainsValue(object, value) {
        var result = false;
        for (var property in object) {
            var aValue = object[property];
            if (object.hasOwnProperty(property) && !isFunction$1(aValue) && aValue === value) {
                result = true;
                break;
            }
        }
        return result;
    },

    /**
     * Set event queue related properties for the giving topic
     * @param {String} topic defines the Figaro "topic" that this event should be stored under
     * @param {Object} properties the event queue properties for the topic
     * @param {Boolean} properties.anonymous true if sending all events for the topic with credentials omitted(no cookies, no PII fields)
     */
    setProperties: function setProperties(topic, properties) {
        _eventQueue.eventQueues = _eventQueue.eventQueues || {};
        _eventQueue.eventQueues[topic] = _eventQueue.eventQueues[topic] || {};
        _eventQueue.eventQueues[topic][CONSTANTS$1.PROPERTIES_KEY] = properties;
    }
};

/**
 ************************************ PSEUDO-PRIVATE METHODS/IVARS ************************************
 * These functions need to be accessible for ease of testing, but should not be used by clients
 */
function _utQueue() {
    return _eventQueue;
}

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * Adds all the supplemental fields like "postTime", etc.
 * Guaranteed to return "null" if there are no events
 * @param {Array} eventQueue a list of events to send
 * @return A stringified version of our eventQueue as a batch, including supplementary top-level fields, all ready to deliver in a ping
 */
function enrichAndSerializeEvents(eventQueue) {
    var eventsBatchString = null;

    if (eventQueue && eventQueue.length) {
        var eventsDict = {};
        eventsDict["deliveryVersion"] = CONSTANTS$1.EVENT_DELIVERY_VERSION;
        eventsDict["postTime"] = Date.now();
        eventsDict[CONSTANTS$1.EVENTS_KEY] = eventQueue;
        try {
            eventsBatchString = JSON.stringify(eventsDict);
        } catch (e) {
            _logger().error('Error stringifying events as JSON: ' + e);
        }
    }
    return eventsBatchString;
}

function enrichAndSerializeEvent(event) {
    return enrichAndSerializeEvents([event]);
}

/**
 * @param {String} topic
 * @return {String} the metrics URL for this topic
 */
function metricsUrlForTopic(topic) {
    var baseMetricsUrl = Config.value('metricsUrl', topic) + '/' + CONSTANTS$1.URL_DELIVERY_VERSION + '/';
    return baseMetricsUrl + topic;
}

/**
 * @param {String} topic
 * @return {Number} the request timeout for this topic
 * Defaults to CONSTANTS.DEFAULT_REQUEST_TIMEOUT
 */
function requestTimeoutForTopic(topic) {
    var requestTimeout = Config.value('requestTimeout', topic) || CONSTANTS$1.DEFAULT_REQUEST_TIMEOUT;
    requestTimeout = Math.min(requestTimeout, Config.value('postFrequency', topic));

    return requestTimeout;
}

/**
 * Determines whether events will be sent via a post interval.
 * If this value is false then the client must perform flushing manually and events will not be scheduled or sent automatically.
 * @param {Bool} enabled whether the postInterval is enabled or not
 */
function setPostIntervalEnabled(enabled) {
    _eventQueue.postIntervalEnabled = enabled;
    if (enabled) {
        _eventQueue.setQueuePostIntervals();
    } else {
        _eventQueue.resetQueuePostIntervals();
    }
}

/**
 * Enqueues events to be sent to the server in batches after "postFrequency" milliseconds since the previous send.
 * The queue is stored in memory, and will retry on failed sends for as long as the session is open.
 * Immediately before a page turn/tab close (usually onpagehide), clients can call flushUnreportedEvents() to send up any events still left in the queue.
 *
 * Flow:
 *      1. Normal:
 *          a. [recordEvent()} Events posted to in-memory eventQueue via "recordEvent() (this method)".
 *             NOTE1: Only remember the most recent MAX_PERSISTENT_QUEUE_SIZE events per queue so we don't eat up all browser memory if we can't send for a very long time.
 *             NOTE2: We could have another set of "waitingForAck" queues which was also in-memory, but then
 *                    we'd need code to merge two queues on re-tries (since _sendEvents() already merges in previously-queued events before attempting to [re]send)
 *                    Since the send failure case is a rare case anyway, we err on the side of not adding code complexity to deal with it.
 *          b. [_sendEvents()] Wait "_postFrequency()" milliseconds before attempting actual "_sendEvents()"
 *          c. Set a timeout for the send which should be the lower of "_postFrquency()" or config.requestTimeout (which defaults to DEFAULT_REQUEST_TIMEOUT).
 *             This guarantees that only one send attempt per topic is pending at any given time.
 *          d. Wait for status=200 response ack, and clear event queue when received (see "Edge Cases", below)
 *      2. Unsent due to ingestion server problem (5XX response):
 *          a. Continue gathering events, adding to in-memory eventQueue
 *          b. Use an exponential back-off strategy by waiting 2^1 = times "_postFrequency()" milliseconds before attempting another "_sendEvents()", as in "Normal" case, above
 *          c. If the ingestion server responds with another 5XX code, wait 2^2 = 4 times "_postFrequency()" milliseconds before attempting another send, and so on
 *          d. Continue as in 1c, above
 *      3. Unsent due to failed conection or other error:
 *          a. Continue gathering events, adding to in-memory eventQueue
 *          b. Wait "_postFrequency()" milliseconds before attempting another "_sendEvents()", as in "Normal" case, above
 *          c. Continue as in 1c, above
 *
 * Edge Cases: Here are the small edge-case windows of failure in the in-memory event queue facility:
 *          1. If two batches of events are sent out before the first one returns and clears the queue, the second one will try to send any queued events as well.
 *             For this to happen, we'd have to be in a situation where we're not leaving the page, event sends are taking some time to respond,
 *             causing us to build up a queue, and then two "sends" are attempted back-to-back by a client calling recordEvent() with postNow=true or flushUnreportedEvents().
 *             It's so rare that the code complexity to try and prevent this case is not worth it (synchronous event posting is the most straightforward way to handle it).
 *          2. If we send a batch of events, the last of which causes, say, a page turn, and invokes flushUnreportedEvents(), we will never get the ack that the batch made it to the server
 *             so we just clear the queue and assume that they made it. During empirical testing, events did continue to get sent event after the browser is closed as long as there is a network connection.
 *          3. If the ingestion server is down, we would only retry as long as the session is open, and lose all events once the user leaves. Events are usually flushed on page turns
 *             without the opportunity to see if the send was successful (see 2 above) so if we wanted to preserve events in the case of ingestion server failure,
 *             we would have to a) keep track of the previous send attempts, b) not flush events on page turn, c) stash the events and the retry state in persistent storage,
 *             and d) fetch the events from persistent storage and restore the retry state, which we choose not to do in order to avoid all of this complexity for what is probably a rare scenario.
 *
 * Note: each topic has its own queue, and all of the above logic applies to each individual queue.
 * For example, exponential backoff works independently on a per-topic basis, in case the server tells us to back off of one topic, but not another.
 * Testing tips:
 * 1) A debug message is logged every time a postInterval timer is triggered, but the metricskit logger debug messages are off by default.
 *    They can be enabled in Web inspector via: metrics.system.logger.setLevel(metrics.system.logger.DEBUG);
 * 2) Exponential backoff can be tested by using a debug source with the 'testExpontentialBackoff' flag enabled.
 *    When this flag is enabled, the metrics queue will skip sending and instead schedule the next retry for _postFrequency() * RETRY_EXPONENT_BASE ^ n milliseconds
 *    where n is the current retry attempt. (see mt-metricskit docs for more details on using debug sources)
 *    To see this in action, you can enable debug logs as in (1) above, then set a debug source with testExponentialBackoff=true (and optionally, a lower postFrequency),
 *    then call recordEvent() to enqueue an event.
 *    You should see a debug message (which includes a timestamp) after postFrequency milliseconds, and then every postFrequency * 2^n milliseconds thereafter.
 *
 * @param {String} topic defines the Figaro "topic" that this event should be stored under
 * @param {Object} eventFields a JavaScript object which will be converted to a JSON string and enqued for sending to Figaro according to the postFrequency schedule
 * @param {Boolean} postNow - effectively forces an immediate send, along with any other messages that may be sitting in the queue
 */
function recordEvent$1(topic, eventFields$$1, postNow) {
    if (!configDisabled.call(Config, topic)) {
        if (Config.value('postFrequency', topic) === 0) {
            postNow = true;
        }

        // The "pagehide" event was tested and works reliably, so we only need to keep the queue in memory, and expect clients to clear the queue on app close
        _eventQueue.enqueueEvent(topic, eventFields$$1);

        if (postNow) {
            _eventQueue.sendEvents(CONSTANTS$1.SEND_METHOD.AJAX, true);
        } else if (!_eventQueue.eventQueues[topic].postIntervalToken && _eventQueue.postIntervalEnabled) {
            // Schedule the next send if the timer isn't already running
            _eventQueue.setTopicPostInterval(topic, Config.value('postFrequency', topic));
        }
    }
}

/**
 * Sends any remaining events in the queue, then clears it.
 * Events will be sent as individual image pings or as synchronous AJAX requests for iOS (these are the only send methods that actually
 * get through during a pagehide event). We expect clients to call this function before the app closes in order to clear the event queues,
 * otherwise any remaining events will be lost. We could theoretically add our own event listener so this call happens automatically,
 * but single page apps could be using history.pushState which triggers onpagehide, and in those cases they would not
 * need to flush until the app is actually closing.
 * Note: This is typically called on page / app close when the JS context is about to disappear and thus we will not know if the events made it to the server
 * @param {Boolean} appIsExiting - Pass true if events are being flushed due to your app exiting or page going away
 * (the send method will be different in order to attempt to post events prior to actual termination)
 * @param {String} appExitSendMethod (optional) the send method for how events will be flushed when the app is exiting.
 * Possible options are enumerated in the `eventRecorder.SEND_METHOD` object.
 * Note: This argument will be ignored if appIsExiting is false.
 */
function flushUnreportedEvents(appIsExiting, appExitSendMethod) {
    if (appIsExiting) {
        if (isString$2(appExitSendMethod) && _eventQueue.objectContainsValue(SEND_METHOD, appExitSendMethod)) {
            _eventQueue.sendEvents(appExitSendMethod, true);
        } else {
            // iOS browsers do not allow image pings to send onpagehide; use (deprecated) synchronous AJAX in those browsers
            if (_isIOS()) {
                _eventQueue.sendEvents(CONSTANTS$1.SEND_METHOD.AJAX_SYNCHRONOUS, true);
            } else {
                _eventQueue.sendEvents(CONSTANTS$1.SEND_METHOD.IMAGE, true);
            }
        }
    } else {
        _eventQueue.sendEvents(CONSTANTS$1.SEND_METHOD.AJAX, true);
    }
}

/*
 *  src/event_recorder.js
 *  mt-event-queue
 *
 *  Copyright © 2016-2017 Apple Inc. All rights reserved.
 *
 */

var attachDelegate$2$2 = reflect$1.attachDelegate;

/**
 * Provides a pre-built delegate to use against the metrics.system.eventRecorder delegate via metrics.system.eventRecorder.setDelegate()
 * If you want to use *most* of these methods, but not *all* of them, you can set this delegate and then create your own with whichever few methods you need to
 * customize additionally, and then setDelegate() *that* delegate, in order to override those methods.
 * @constructor
 *
 * NOTE: This class would ideally inherit from EventRecorder, but rollup will
 * include an entire subclass and all of its dependencies even if the class
 * is not used. Therefore we choose not to inherit from EventRecorder so that
 * the queue code isn't included if the queue isn't used.
 *
 * TODO: investigate alternative strategies to optimize tree shaking
 */
var queuedEventRecorder = {
    /**
     ************************************ PSEUDO-PRIVATE METHODS/IVARS ************************************
     * These functions need to be accessible for ease of testing, but should not be used by clients
     */
    _utResetQueue: function _utResetQueue() {
        for (var topic in _utQueue().eventQueues) {
            _utQueue().resetTopicPostInterval(topic);
        }
        _utQueue().eventQueues = {};
    },

    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */
    SEND_METHOD: SEND_METHOD,

    /**
     * Allows replacement of one or more of this class' functions
     * Any method on the passed-in object which matches a method that this class has will be called instead of the built-in class method.
     * To replace *all* methods of his class, simply have your delegate implement all the methods of this class
     * Your delegate can be a true object instance, an anonymous object, or a class object.
     * Your delegate is free to have as many additional non-matching methods as it likes.
     * It can even act as a delegate for multiple MetricsKit objects, though that is not recommended.
     *
     * "setDelegate()" may be called repeatedly, with the functions in the most-recently set delegates replacing any functions matching those in the earlier delegates, as well as any as-yet unreplaced functions.
     * This allows callers to use "canned" delegates to get most of their functionality, but still replace some number of methods that need custom implementations.
     * If, for example, a client wants to use the "canned" itml/environment delegate with the exception of, say, the "appVersion" method, they can set itml/environment as the delegate, and
     * then call "setDelegate()" again with their own delegate containing only a single method of "appVersion" as the delegate, which would leave all the other "replaced" methods intact,
     * but override the "appVersion" method again, this time with their own supplied delegate.
     *
     * NOTE: The delegate function will have a property called origFunction representing the original function that it replaced.
     * This allows the delegate to, essentially, call "super" before or after it does some work.
     * If a replaced method is overridden again with a subsequent "setDelegate()" call, the "origFunction" property will be the previous delegate's function.
     * @example:
     * To override one or more methods, in place:
     *      eventRecorder.setDelegate({recordEvent: itms.recordEvent});
     * To override one or more methods with a separate object:
     *      eventRecorder.setDelegate(eventRecorderDelegate);
     *      (where "eventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          var eventRecorderDelegate = {recordEvent: itms.recordEvent,
     *                                       sendMethod: 'itms'};
     * To override one or more methods with an instantiated object from a class definition:
     *      eventRecorder.setDelegate(new EventRecorderDelegate());
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.prototype.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.prototype.sendMethod = function sendMethod() {
     *                                                          return 'itms';
     *                                                      };
     * To override one or more methods with a class object (with "static" methods):
     *      eventRecorder.setDelegate(EventRecorderDelegate);
     *      (where "EventRecorderDelegate" might be defined elsewhere as, e.g.:
     *          function EventRecorderDelegate() {
     *         }
     *         EventRecorderDelegate.recordEvent = itms.recordEvent;
     *         EventRecorderDelegate.sendMethod = function sendMethod() {
     *                                                return 'itms';
     *                                            };
     * @param {Object} Object or Class with delegate method(s) to be called instead of default (built-in) methods.
     * @returns {Boolean} true if one or more methods on the delegate object match one or more methods on the default object,
     * otherwise returns false.
     */
    setDelegate: function setDelegate(delegate) {
        return attachDelegate$2$2(this, delegate);
    },

    /**
     * @param {String} topic defines the Figaro "topic" that this event should be stored under
     * @param {Object} eventFields a JavaScript object which will be converted to a JSON string and enqued for sending to Figaro according to the postFrequency schedule.
     * @param {Boolean} postNow - effectively forces an immediate send, along with any other messages that may be sitting in the queue
     * @returns {Object} the recorded event, or "null" if no object was recorded (e.g. if "eventFields" is null, or "disabled" is true, eventFields.eventType is one of the blacklistedEvents, etc.)
     * @overridable
     */
    recordEvent: function recordEvent$2(topic, eventFields$$1, postNow) {
        return recordEvent.apply(null, [recordEvent$1].concat(Array.prototype.slice.call(arguments)));
    },

    /**
     * The methodology being used to send batches of events to the server
     * This field should be hardcoded in the client based on what method it is using to encode and send its events to Figaro.
     * The three typical values are:
     *      "itms" - use this value when/if JavaScript code enqueues events for sending via the "itms.recordEvent()" method in ITML.
     *      "itunes" - use this value when/if JavaScript code enqueues events by calling the "iTunes.recordEvent()" method in Desktop Store apps.
     *      "javascript" - use this value when/if JavaScript code enqueues events for sending via the JavaScript eventQueue management. This is typically only used by older clients which don't have the built-in functionality of itms or iTunes available to them.
     * @example "itms", "itunes", "javascript"
     * @returns {String}
     */
    sendMethod: function sendMethod$1() {
        return sendMethod();
    },

    /**
     * Sends any remaining events in the queue, then clears it
     * This is typically called on page / app close when the JS context is about to disappear and thus we will
     * not know if the events made it to the server
     * @param {Boolean} appIsExiting - Pass true if events are being flushed due to your app exiting or page going away
     * (the send method will be different in order to attempt to post events prior to actual termination)
     * @param {String} appExitSendMethod (optional) the send method for how events will be flushed when the app is exiting.
     * Possible options are enumerated in the `eventRecorder.SEND_METHOD` object.
     * Note: This argument will be ignored if appIsExiting is false.
     */
    flushUnreportedEvents: function flushUnreportedEvents$1(appIsExiting, appExitSendMethod) {
        flushUnreportedEvents.apply(null, Array.prototype.slice.call(arguments));
    },

    /**
     * Set event queue related properties for the giving topic
     * @param {String} topic defines the Figaro "topic" that this event should be stored under
     * @param {Object} properties the event queue properties for the topic
     * @param {Boolean} properties.anonymous true if sending all events for the topic with credentials omitted(no cookies, no PII fields)
     */
    setProperties: function setProperties$1(topic, properties) {
        setProperties(topic, properties);
        _utQueue().setProperties(topic, properties);
    },

    /**
     * clear event queue's resources
     */
    cleanup: function cleanup$1() {
        cleanup$1();
        queuedEventRecorder._utResetQueue();
    }
};

/*
 *  src/immediate_event_recorder.js
 *  mt-event-queue
 *
 *  Copyright © 2016-2019 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PRIVATE METHODS/IVARS ************************************
 */
function _immediateRecordEvent(topic, eventFields$$1) {
    var jsonEventsString = enrichAndSerializeEvent(eventFields$$1);
    if (jsonEventsString) {
        var topicUrl = metricsUrlForTopic(topic);
        var requestTimeout = requestTimeoutForTopic(topic);
        var options = { timeout: requestTimeout };
        if (topicPropsCache[topic] && topicPropsCache[topic].anonymous) {
            options.withCredentials = false;
        }

        network$2.makeAjaxRequest(topicUrl, 'POST', jsonEventsString, null, null, options);
    }
}

/**
 * Provides a pre-built delegate to use against the metrics.system.eventRecorder delegate via metrics.system.eventRecorder.setDelegate()
 * If you want to use *most* of these methods, but not *all* of them, you can set this delegate and then create your own with whichever few methods you need to
 * customize additionally, and then setDelegate() *that* delegate, in order to override those methods.
 * @constructor
 */
var immediateEventRecorder$1 = {
    /**
     ************************************ PUBLIC METHODS/IVARS ************************************
     */

    /**
     * @param {String} topic defines the AMP Analytics "topic" that this event should be stored under
     * @param {Object} eventFields a JavaScript object which will be converted to a JSON string and sent to AMP Analytics immediately.
     */
    recordEvent: function recordEvent$1(topic, eventFields$$1) {
        return recordEvent.apply(null, [_immediateRecordEvent].concat(Array.prototype.slice.call(arguments)));
    },

    /**
     * The methodology being used to send batches of events to the server
     * This field should be hardcoded in the client based on what method it is using to encode and send its events to Figaro.
     * The three typical values are:
     *      "itms" - use this value when/if JavaScript code enqueues events for sending via the "itms.recordEvent()" method in ITML.
     *      "itunes" - use this value when/if JavaScript code enqueues events by calling the "iTunes.recordEvent()" method in Desktop Store apps.
     *      "javascript" - use this value when/if JavaScript code enqueues events for sending via the JavaScript eventQueue management. This is typically only used by older clients which don't have the built-in functionality of itms or iTunes available to them.
     * @example "itms", "itunes", "javascript"
     * @returns {String}
     */
    sendMethod: function sendMethod$1() {
        return sendMethod();
    },

    /**
     * Set properties for the giving topic
     * @param {String} topic defines the Figaro "topic" that this event should be stored under
     * @param {Object} properties the properties for the topic
     * @param {Boolean} properties.anonymous true if sending all events for the topic with credentials omitted(no cookies, no PII fields)
     */
    setProperties: setProperties,

    /**
     * clear resources
     */
    cleanup: cleanup$1
};

/*
 *  mt-event-queue/index.js
 *  mt-event-queue
 *
 *  Copyright © 2016-2017 Apple Inc. All rights reserved.
 *
 */

var logger$1 = /*#__PURE__*/loggerNamed('mt-event-queue');



var mtEventQueue_esm = Object.freeze({
	environment: environment$2,
	eventRecorder: queuedEventRecorder,
	immediateEventRecorder: immediateEventRecorder$1,
	logger: logger$1,
	network: network$2,
	setEventQueuePostIntervalEnabled: setPostIntervalEnabled
});

/*
 *  src/environment.js
 *  mt-metricskit-delegates-html
 *
 *  Copyright © 2015-2016 Apple Inc. All rights reserved.
 *
 */

/**
 * Provides a pre-built HTML delegate to use against the metrics.system.environment delegate via metrics.system.environment.setDelegate()
 * If you want to use *most* of these methods, but not *all* of them, you can set this delegate and then create your own with whichever few methods you need to
 * customize additionally, and then setDelegate() *that* delegate, in order to override those methods.
 * @constructor
 */
var environment$1 = {
  /**
   ************************************ PSEUDO-PRIVATE METHODS/IVARS ************************************
   * These functions need to be accessible for ease of testing, but should not be used by clients
   */
  _document: function _document() {
    if (typeof document != 'undefined') {
      return document;
    } else {
      throw "metricskit-delegates-html.environment HTML delegate 'document' object not found";
    }
  },

  _window: function _window() {
    if (typeof window != 'undefined') {
      return window;
    } else {
      throw "metricskit-delegates-html.environment HTML delegate 'window' object not found";
    }
  },

  /**
   ************************************ PUBLIC METHODS/IVARS ************************************
   */

  /**
   * The cookie string, e.g. "iTunes.cookie" (iTunes desktop), "iTunes.cookieForDefaultURL" (HTML iOS), "itms.cookie" (itml app), "document.cookie" (browser)
   * NOTE: Callers should override this method if they want to supply a different cookie.
   * @overridable
   */
  cookie: function cookie() {
    return environment$1._window().document.cookie;
  },

  /**
   * The URL that represents this page.
   * Typically this is a "deep link" type URL.
   * If no URL is available, this field may be omitted.
   * @example "https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewGrouping?cc=us&mt=8"
   * @returns {String}
   * @overridable
   */
  pageUrl: function pageUrl() {
    return environment$1._window().location.href;
  },

  /**
   * The URL of the parent page, if the app is embedded in a parent context.
   * Typically this is a "deep link" type URL.
   * If no URL is available, or if the app is not embedded, this field may be omitted.
   * @example "https://www.apple.com/blog/top-tracks.html"
   * @returns {String}
   * @overridable
   * Note: due to iframe sandbox rules, the parent window's location may not be accessible.
   * In that case, we fall back to document.referrer, which should be reliable if the app
   * within the iframe is a single page app (document.referrer changes on every page turn).
   * If the app in the iframe is not a single page app, we will have to persist the
   * original referrer from the first page across page turns via e.g. localStorage.
   * However, this use case is not currently needed by any client.
   */
  parentPageUrl: function parentPageUrl() {
    var windowObject = environment$1._window();
    var parentWindow = windowObject.parent;
    var parentPageUrl;

    if (parentWindow !== windowObject) {
      try {
        parentPageUrl = parentWindow.location.href;
      } catch (e) {
        parentPageUrl = environment$1._document().referrer;
      }
    }

    return parentPageUrl;
  },

  /**
   * Pixel multiplier factor
   * @example 2
   * @returns {number}
   * @overridable
   */
  pixelRatio: function pixelRatio() {
    return environment$1._window().devicePixelRatio;
  },

  /**
   * Client screen height in pixels
   * @example 568
   * @returns {number}
   * @overridable
   */
  screenHeight: function screenHeight() {
    return environment$1._window().screen.height;
  },

  /**
   * Client screen width in pixels
   * @example 320
   * @returns {number}
   * @overridable
   */
  screenWidth: function screenWidth() {
    return environment$1._window().screen.width;
  },

  /**
   * Client’s user agent string.  If the "app field is not provided, "userAgent may be used to derive the value of the "app field
   * @example AppStore/2.0 iOS/8.3 model/iPhone7,2 build/12F70 (6; dt:106)
   * @returns {String}
   * @overridable
   */
  userAgent: function userAgent() {
    return environment$1._window().navigator.userAgent;
  },

  /**
   * App viewport height in pixels.  Does not include window “chrome”, status bars, etc.
   * Typically only available on desktop windowing systems.
   * @example 1920
   * @returns {number/undefined}
   * @overridable
   */
  windowInnerHeight: function windowInnerHeight() {
    return environment$1._window().innerHeight;
  },

  /**
   * App viewport width in pixels.  Does not include window “chrome”, status bars, etc.
   * Typically only available on desktop windowing systems.
   * @example 1080
   * @returns {number/undefined}
   * @overridable
   */
  windowInnerWidth: function windowInnerWidth() {
    return environment$1._window().innerWidth;
  },

  /**
   * Height in pixels of containing window, encompassing app viewport as well as window chrome, status bars, etc.
   * Typically only available on desktop windowing systems.
   * @example 1080
   * @returns {number/undefined}
   * @overridable
   */
  windowOuterHeight: function windowOuterHeight() {
    return environment$1._window().outerHeight;
  },

  /**
   * Width in pixels of containing window, encompassing app viewport as well as window chrome, status bars, etc.
   * Typically only available on desktop windowing systems.
   * @example 1920
   * @returns {number/undefined}
   * @overridable
   */
  windowOuterWidth: function windowOuterWidth() {
    return environment$1._window().outerWidth;
  },

  /**
   * The offset between W3C timing entry timestamps (which are relative to the page lifecycle) and the epoch time
   * and the epoch time, in milliseconds
   * @return {Number}
   * @overridable
   * Note: this is only currently used by PerfKit
   * TODO: <rdar://problem/44976037> Refactor: Delegates: revisit HTML delegate packaging
   */
  timeOriginOffset: function timeOriginOffset() {
    var returnValue = null;
    var performance = environment$1._window().performance;

    if (performance && performance.timing) {
      returnValue = performance.timing.navigationStart;
    }

    return returnValue;
  },

  /**
   * THE FOLLOWING DATA ARE UNAVAILABLE IN A PURE WEB BROWSER CONTEXT,
   * BUT MAY BE IMPLEMENTED (VIA POTENTIALLY DIFFERENT APIS) IN VARIOUS HTML WEB VIEW CONTEXTS (iOS vs Desktop vs tvOS)
   * THEY ARE LEFT UNIMPLEMENTED FOR CONTEXT-SPECIFIC DELEGATES TO OVERWRITE IF APPLICABLE
   */

  /**
   * The app identifier of the binary app
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @example "com.apple.appstore" or "com.apple.gamecenter"
   * @returns {String}
   * @overridable
   */
  app: function app() {},

  /**
   * The version number of this application
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @example "1.0", "5.43", etc.
   * @returns {String}
   * @overridable
   * @defaultimpl navigator.appVersion
   */
  appVersion: function appVersion() {},

  /**
   * The total data capacity of the system, without regard for what's already been used or not.
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @returns {number}
   * @overridable
   */
  capacityData: function capacityData() {},

  /**
   * The total available data capacity of the system.
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @returns {number}
   * @overridable
   */
  capacityDataAvailable: function capacityDataAvailable() {},

  /**
   * The total disk capacity of the system, without regard for what's already been used or not.
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @returns {number}
   * @overridable
   */
  capacityDisk: function capacityDisk() {},

  /**
   * The total system capacity, without regard for what's already been used or not.
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @returns {number}
   * @overridable
   */
  capacitySystem: function capacitySystem() {},

  /**
   * The total available system capacity of the system.
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @api public
   * @overridable
   */
  capacitySystemAvailable: function capacitySystemAvailable() {},

  /**
   * Type of internet connection.
   * Only applicable to devices
   * Beware that users on WiFi may actually be receiving 3G speeds (i.e. if device is tethered to a portable hotspot.)
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @example "WiFi, "3G, etc.
   * @returns {String}
   * @overridable
   */
  connectionType: function connectionType() {},

  /**
   * The id of this user ("directory service id").
   * This id will get anonymized on the server prior to being saved.
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @example 659261189
   * @returns {String}
   * @overridable
   */
  dsId: function dsId() {},

  /**
   * The hardware brand of the device. Not required for Apple devices.
   * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
   * @example "Samsung", "LG", "Google"
   * @returns {String}
   */
  hardwareBrand: function hardwareBrand() {},

  /**
   * The hardware family of the device
   * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
   * @example "iPhone", "Macbook Pro"
   * @returns {String}
   */
  hardwareFamily: function hardwareFamily() {},

  /**
   * The model of the device
   * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
   * @example "iPhone10,2", "MacbookPro11,5"
   * @returns {String}
   */
  hardwareModel: function hardwareModel() {},

  /**
   * App that is hosting the storesheet or app
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @example com.rovio.AngryBirds
   * @returns {String}
   * @overridable
   */
  hostApp: function hostApp() {},

  /**
   * Version of the app that is hosting the storesheet or app
   * NO DEFAULT IMPLEMENTATION... HOWEVER: this field is optional
   * @example "1.0.1"
   * @returns {String}
   * @overridable
   */
  hostAppVersion: function hostAppVersion() {
    // Optional field value
  },

  /**
   * The name of the OS
   * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
   * @example "ios", "macos", "windows"
   * @returns {String}
   */
  os: function os() {},

  /**
   * The build number of the OS
   * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
   * @example "15D60", "17E192"
   * @returns {String}
   */
  osBuildNumber: function osBuildNumber() {},

  /**
   * A string array of language IDs, ordered in descending preference
   * NO DEFAULT IMPLEMENTATION... THIS METHOD MUST BE REPLACED
   * @example ["en-US", "fr-CA"]
   * @returns {Array}
   */
  osLanguages: function osLanguages() {},

  /**
   * The full OS version number
   * In ITML, the value can be retrieved via Device.systemVersion
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @example "8.2.1" (iOS) "10.10.3" (Desktop)
   * @returns {String}
   * @overridable
   */
  osVersion: function osVersion() {},

  /**
   * HTML resources revision number
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @example 2C97 or 8.4.0.0.103
   * @returns {String}
   * @overridable
   */
  resourceRevNum: function resourceRevNum() {},

  /**
   * ISO 3166 Country Code. Apps that cannot provide a storeFrontHeader should provide a storeFrontCountryCode instead
   * NO DEFAULT IMPLEMENTATION... Either this method or storeFrontHeader must be replaced.
   * @example US
   * @returns {String}
   * @overridable
   */
  storeFrontCountryCode: function storeFrontCountryCode() {},

  /**
   * The value contained in the X-Apple-Store-Front header value at the time the event is being created.
   * NO DEFAULT IMPLEMENTATION... Either this method or storeFrontCountryCode must be replaced.
   * @example K143441-1,29 ab:rSwnYxS0
   * @returns {String}
   * @overridable
   */
  storeFrontHeader: function storeFrontHeader() {},

  /**
   * The type of subscriber this user is.
   * NO DEFAULT IMPLEMENTATION... THIS METHOD SHOULD BE REPLACED
   * @example subscribed, notSubscribed, unknown, needsAuthentication
   * @returns {String}
   * @overridable
   */
  userType: function userType() {}
};

/*
 *  mt-metricskit-delegates-html/index.js
 *  mt-metricskit-delegates-html
 *
 *  Copyright © 2015-2016 Apple Inc. All rights reserved.
 *
 */

var eventRecorder$$1 = queuedEventRecorder;
var immediateEventRecorder$$1 = immediateEventRecorder$1;

// Clear the event queue and delete the interval timers
// @private
var cleanup = function _cleanup() {
  // TODO cleanup() is available since mt-event-queue v1.2.0
  // Checking the cleanup() for backward compatibility.
  // We chose not to include mt-metricskit-utils-private just for reflect.isFunction
  if (typeof eventRecorder$$1.cleanup === 'function') {
    eventRecorder$$1.cleanup();
  } else {
    eventRecorder$$1._utResetQueue();
  }
};



var mtkitDelegates = Object.freeze({
	eventQueue: mtEventQueue_esm,
	cleanup: cleanup,
	environment: environment$1,
	eventRecorder: eventRecorder$$1,
	immediateEventRecorder: immediateEventRecorder$$1
});

var browser = createCommonjsModule(function (module, exports) {
    'use strict';

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }

    var Browser = function () {
        function Browser() {
            var userAgent = arguments.length <= 0 || arguments[0] === undefined ? window.navigator.userAgent : arguments[0];

            _classCallCheck(this, Browser);

            var ua = userAgent.toLowerCase();
            // Need to test for Edge first of all because the agent string Edge provides includes chrome
            // and safari which leads to multiple regex matches when testing. By looking for 'edge'
            // first we can rule out all the other browsers.
            this.isEdge = /\sedge\//.test(ua);
            this.isChrome = !this.isEdge && /chrome/.test(ua);
            this.isSafari = !this.isEdge && !this.isChrome && /safari/.test(ua);
            this.isFirefox = !this.isEdge && !this.isChrome && !this.isSafari && /firefox/.test(ua);
            this.isIE = !this.isEdge && !this.isChrome && !this.isSafari && !this.isFirefox && /trident|msie/.test(ua);

            this.isMobile = /mobile/.test(ua);
            this.isAndroid = this.isMobile && /android/.test(ua);
            this.isiOS = this.isMobile && /iphone|ipad|ipod/.test(ua);

            this.isEdgeHTML = this.isEdge;
            this.isWebKit = !this.isEdgeHTML && /applewebkit/.test(ua) && !/edge/.test(ua);
            this.isTrident = !this.isEdgeHTML && !this.isWebKit && /trident/.test(ua);

            // Ordered last because other browsers tend to include “like Gecko”
            // in their user agent.
            this.isGecko = !this.isEdgeHTML && !this.isWebKit && !this.isTrident && /gecko/.test(ua);

            // Since Edge lists chrome, safari, and applewebkit in the agent string all the above
            // matches positive for chrome and webkit values making proper identification of the version
            // problematic. The regex matches against the 'chrome/39.x.x.x' string before reaching
            // 'edge/12.0'. Also, there is no browser version in the UA string, only the engine version:
            // https://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx
            if (this.isEdge) {
                this.engineVersion = ua.match(/(?:edge).(\d+)/);
            } else {
                this.version = ua.match(/(?:chrome|version|firefox|msie|rv).(\d+)\.(\d+)/);
                this.engineVersion = ua.match(/(?:applewebkit|gecko|trident).(\d+)/);
            }

            if (this.version) {
                this.majorVersion = parseInt(this.version[1], 10);
                this.minorVersion = parseInt(this.version[2], 10);
            }

            if (this.engineVersion) {
                this.engineMajorVersion = parseInt(this.engineVersion[1], 10);
            }

            this.isChromeOS = !this.isMobile && /CrOS/.test(ua);
            this.ismacOS = !this.isMobile && /macintosh/.test(ua);
            this.isLinux = !this.isMobile && /linux/.test(ua);
            this.isTizen = /tizen/.test(ua); // Tizen is both a mobile and non-mobile platform
            this.isWebOS = /web0s|webos/.test(ua); // webOS is both a mobile and non-mobile platform
            this.isWindows = !this.isMobile && /windows/.test(ua);
        }

        _createClass(Browser, [{
            key: 'couldSupportScheme',
            value: function couldSupportScheme(scheme) {
                var supported = false;

                switch (scheme) {
                    case 'apple-music':
                        supported = this.isAndroid;
                        break;
                    case 'itms':
                        supported = this.ismacOS || this.isWindows;
                        break;
                    case 'itms-books':
                        supported = this.ismacOS || this.isiOS;
                        break;
                    case 'itms-itunesu':
                        supported = this.isiOS;
                        break;
                    case 'itms-apps':
                    case 'itms-podcast':
                    case 'itms-messages':
                    case 'itms-watch':
                    case 'music':
                        supported = this.isiOS;
                        break;
                    case 'macappstore':
                        supported = this.ismacOS;
                        break;
                }

                return supported;
            }
        }]);

        return Browser;
    }();

    exports['default'] = Browser;
});

var _slicedToArray = function () {
    function sliceIterator(arr, i) {
        var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                _arr.push(_s.value);if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;_e = err;
        } finally {
            try {
                if (!_n && _i['return']) _i['return']();
            } finally {
                if (_d) throw _e;
            }
        }return _arr;
    }return function (arr, i) {
        if (Array.isArray(arr)) {
            return arr;
        } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
        } else {
            throw new TypeError('Invalid attempt to destructure non-iterable instance');
        }
    };
}();

var parseSearch_1 = parseSearch;
var parseURL_1 = parseURL;
var QUERY_REGEX = /([^?&=]+)=?([^&]*)/g;

function parseSearch() {
    var search = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

    var query = {};
    var params = search.match(QUERY_REGEX) || [];

    params.forEach(function (param) {
        var _param$split = param.split('=');

        var _param$split2 = _slicedToArray(_param$split, 2);

        var key = _param$split2[0];
        var value = _param$split2[1];

        query[key] = value;
    });

    return query;
}



function parseURL(url) {
    var anchor = document.createElement('a');
    anchor.href = url;

    return {
        hash: anchor.hash,
        hostname: anchor.hostname,
        pathname: anchor.pathname,
        protocol: anchor.protocol,
        search: anchor.search
    };
}



var url = {
    parseSearch: parseSearch_1,
    parseURL: parseURL_1
};

var scheme = createCommonjsModule(function (module, exports) {
    'use strict';

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }

    var MEDIA_TYPES = {
        app: ['8'],
        book: ['11', '13'],
        'mac-app': ['12'],
        podcast: ['2']
    };

    var PATH_REGEX = {
        book: /\/book\//,
        course: /\/course\//,
        'mac-app': /\/mac-app\//,
        music: /\/(album|artist|music-video|show|episode)\//,
        podcast: /\/podcast\//
    };

    var Scheme = function () {
        _createClass(Scheme, null, [{
            key: 'forURL',
            value: function forURL(url$$1) {
                var browser = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                var isAndroid = browser.isAndroid || false;
                var isMobile = browser.isMobile || false;

                var source = new this(url$$1);

                if (!/https?:/.test(source.protocol)) {
                    return source.protocol;
                }

                // TODO: itsradio, its-video
                if (isMobile) {
                    // Apps
                    if (source.isApps) {
                        return 'itms-apps';
                    }

                    if (source.isWatch) {
                        return 'itms-watch';
                    }

                    if (source.isPodcast) {
                        return 'itms-podcast';
                    }

                    if (source.isMessage) {
                        return 'itms-messages';
                    }

                    // Music
                    if (source.isMusic) {

                        // Android
                        if (isAndroid) {
                            return 'apple-music';
                        }

                        return 'music';
                    }
                }

                if (source.isBook) {
                    return 'itms-books';
                }

                if (source.isCobalt) {
                    return 'itms-itunesu';
                }

                if (source.isMacApp) {
                    return 'macappstore';
                }

                return 'itms';
            }
        }]);

        function Scheme(url$$1) {
            _classCallCheck(this, Scheme);

            var _parseURL = (0, url.parseURL)(url$$1);

            var pathname = _parseURL.pathname;
            var protocol = _parseURL.protocol;
            var search = _parseURL.search;

            this.pathname = pathname;
            this.protocol = protocol;
            this.query = (0, url.parseSearch)(search);
            this.url = url$$1;
        }

        _createClass(Scheme, [{
            key: '_is',
            value: function _is(key) {
                var appMatch = this.query.app && this.query.app === key;
                var mtMatch = false;
                var pathMatch = false;

                if (MEDIA_TYPES[key]) {
                    mtMatch = MEDIA_TYPES[key].indexOf(this.query.mt) !== -1;
                }

                if (PATH_REGEX[key]) {
                    pathMatch = PATH_REGEX[key].test(this.pathname);
                }

                return appMatch || mtMatch || pathMatch;
            }
        }, {
            key: 'isApps',
            get: function get() {
                return MEDIA_TYPES.app.indexOf(this.query.mt) !== -1 && !this.isMessages && !this.isWatch;
            }
        }, {
            key: 'isBook',
            get: function get() {
                return this._is('book');
            }
        }, {
            key: 'isCobalt',
            get: function get() {
                return this._is('course');
            }
        }, {
            key: 'isMacApp',
            get: function get() {
                return this._is('mac-app');
            }
        }, {
            key: 'isMessages',
            get: function get() {
                return this._is('messages');
            }
        }, {
            key: 'isMusic',
            get: function get() {
                return this._is('music');
            }
        }, {
            key: 'isPodcast',
            get: function get() {
                return this._is('podcast');
            }
        }, {
            key: 'isWatch',
            get: function get() {
                return this._is('watch');
            }
        }]);

        return Scheme;
    }();

    exports['default'] = Scheme;
});

var appendFrame_1 = appendFrame;
var removeFrame_1 = removeFrame;
var FRAME_ID = 'client-detect-frame';

var FRAME_ID_1 = FRAME_ID;

function appendFrame() {
    var frame = arguments.length <= 0 || arguments[0] === undefined ? FRAME_ID : arguments[0];
    var parent = arguments.length <= 1 || arguments[1] === undefined ? document.body : arguments[1];

    var child = frame;

    if (typeof frame === 'string') {
        child = document.createElement('iframe');
        child.id = frame;
        child.style.display = 'none';
    }

    parent.appendChild(child);

    return child;
}

function removeFrame() {
    var frame = arguments.length <= 0 || arguments[0] === undefined ? FRAME_ID : arguments[0];
    var parent = arguments.length <= 1 || arguments[1] === undefined ? document.body : arguments[1];

    var child = frame;

    if (typeof frame === 'string') {
        child = document.getElementById(frame);
    }

    if (child) {
        parent.removeChild(child);
    }
}

var dom = {
    appendFrame: appendFrame_1,
    removeFrame: removeFrame_1,
    FRAME_ID: FRAME_ID_1
};

var _default = createCommonjsModule(function (module, exports) {
    'use strict';

    exports['default'] = function (href) {
        var callback = arguments.length <= 1 || arguments[1] === undefined ? Function() : arguments[1];

        var iframe = (0, dom.appendFrame)();
        iframe.contentWindow.location.href = href;

        window.setTimeout(function () {
            (0, dom.removeFrame)(iframe);
            callback();
        }, 250);
    };

    
});

var chrome = createCommonjsModule(function (module, exports) {
    'use strict';

    exports['default'] = function (href) {
        var supported = arguments.length <= 1 || arguments[1] === undefined ? Function() : arguments[1];
        var unsupported = arguments.length <= 2 || arguments[2] === undefined ? Function() : arguments[2];

        function onBlur() {
            window.clearTimeout(timer);
            window.removeEventListener('blur', onBlur);
            supported();
        }

        window.addEventListener('blur', onBlur);

        var timer = window.setTimeout(function () {
            window.removeEventListener('blur', onBlur);
            unsupported();
        }, 250);

        window.location.href = href;
    };

    
});

var firefox = createCommonjsModule(function (module, exports) {
    'use strict';

    exports['default'] = function (href) {
        var supported = arguments.length <= 1 || arguments[1] === undefined ? Function() : arguments[1];
        var unsupported = arguments.length <= 2 || arguments[2] === undefined ? Function() : arguments[2];

        var iframe = (0, dom.appendFrame)();

        try {
            // On FF, if we are able to change the iframe's location,
            // then the protocol scheme is registered
            iframe.contentWindow.location.href = href;
            supported();
        } catch (e) {
            // if e.name === 'NS_ERROR_UNKNOWN_PROTOCOL'
            // we know confidently this is NOT installed
            unsupported();
        } finally {
            (0, dom.removeFrame)();
        }
    };

    
});

var ie = createCommonjsModule(function (module, exports) {
    'use strict';

    var POPUP_ID = 'client-detect-popup';

    exports.POPUP_ID = POPUP_ID;

    exports['default'] = function (href) {
        var supported = arguments.length <= 1 || arguments[1] === undefined ? Function() : arguments[1];
        var unsupported = arguments.length <= 2 || arguments[2] === undefined ? Function() : arguments[2];

        var blank = 'about:blank';
        var popup = window.open('', POPUP_ID, 'height=0,width=0');
        popup.location.href = href;

        try {
            (function () {
                // In IE, if we can change the popup location after setting to
                // a protocol scheme - the protocol scheme is supported
                popup.location.href = blank;
                supported();

                // In IE if the user is the external application dialog - we cannot
                // close the popup, so try until we close
                var interval = window.setInterval(function () {
                    popup.close();

                    if (popup.closed) {
                        window.clearInterval(interval);
                    }
                }, 250);
            })();
        } catch (e) {
            popup = window.open(blank, POPUP_ID);
            popup.close();
            unsupported();
        }
    };

    
});

var ios = createCommonjsModule(function (module, exports) {
    "use strict";

    exports["default"] = function (href) {
        var supported = arguments.length <= 1 || arguments[1] === undefined ? Function() : arguments[1];
        var unsupported = arguments.length <= 2 || arguments[2] === undefined ? Function() : arguments[2];

        try {
            // on iOS appending an iframe doenst work as expected
            // <rdar://problem/37768636> RU: WebPlayer iOS - iPod - 'Get Apple Music'
            // button is not tappable
            top.window.location.href = href;
            supported();
        } catch (e) {
            // we know this is NOT installed
            // TODO: Check if Apple Music is installed (not removed) on device
            unsupported();
        }
    };

    
});

var launch = createCommonjsModule(function (module, exports) {
    'use strict';

    exports['default'] = {
        chrome: chrome['default'],
        firefox: firefox['default'],
        ie: ie['default'],
        ios: ios['default'],
        'default': _default['default']
    };
});

var clientDetect = createCommonjsModule(function (module, exports) {
    'use strict';

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
            }
        }return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
        };
    }();

    exports.registerGlobal = registerGlobal;

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError('Cannot call a class as a function');
        }
    }

    var SUPPORTED = 1;
    var UNSUPPORTED = 0;
    var UNKNOWN = -1;

    var ClientDetect = function () {
        function ClientDetect() {
            _classCallCheck(this, ClientDetect);
        }

        _createClass(ClientDetect, null, [{
            key: 'browser',
            value: function browser$$1() {
                return new browser['default']();
            }
        }, {
            key: 'couldHaveAppStore',
            value: function couldHaveAppStore() {
                return new browser['default']().couldSupportScheme('itms-apps');
            }
        }, {
            key: 'couldHaveBookStore',
            value: function couldHaveBookStore() {
                return new browser['default']().couldSupportScheme('itms-books');
            }
        }, {
            key: 'couldHaveiTunes',
            value: function couldHaveiTunes() {
                return new browser['default']().couldSupportScheme('itms');
            }
        }, {
            key: 'couldHaveiTunesU',
            value: function couldHaveiTunesU() {
                return new browser['default']().couldSupportScheme('itms-itunesu');
            }
        }, {
            key: 'couldHaveMacAppStore',
            value: function couldHaveMacAppStore() {
                return new browser['default']().couldSupportScheme('macappstore');
            }
        }, {
            key: 'couldHaveMessages',
            value: function couldHaveMessages() {
                return new browser['default']().couldSupportScheme('itms-messages');
            }
        }, {
            key: 'couldHaveMusic',
            value: function couldHaveMusic() {
                var browser$$1 = new browser['default']();

                return browser$$1.couldSupportScheme('music') || browser$$1.couldSupportScheme('apple-music');
            }
        }, {
            key: 'couldHavePodcasts',
            value: function couldHavePodcasts() {
                return new browser['default']().couldSupportScheme('itms-podcast');
            }
        }, {
            key: 'couldHaveWatch',
            value: function couldHaveWatch() {
                return new browser['default']().couldSupportScheme('itms-watch');
            }
        }, {
            key: 'launchClient',
            value: function launchClient(url, callback) {
                var browser$$1 = new browser['default']();
                var scheme$$1 = scheme['default'].forURL(url, browser$$1);

                // TODO: Fallback to http(s)
                var re = browser$$1.isAndroid ? /^https?/ : /^http/;

                var href = url.replace(re, scheme$$1);

                if (typeof callback !== 'function') {
                    return window.location.href = href;
                }

                // browser specific strategies purposely have the same method
                // signature as msLaunchUri to feel more like a polyfill
                // these functions funnel the multiple callbacks defined in those
                // signatures into a single callback
                function supported() {
                    callback(SUPPORTED, browser$$1, href);
                }

                function unsupported() {
                    callback(UNSUPPORTED, browser$$1, href);
                }

                // Proprietary msLaunchUri method (IE 10+ on Windows 8+)
                if (navigator.msLaunchUri) {
                    navigator.msLaunchUri(href, supported, unsupported);
                } else if (browser$$1.isChrome) {
                    launch['default'].chrome(href, supported, unsupported);
                } else if (browser$$1.isFirefox) {
                    launch['default'].firefox(href, supported, unsupported);
                } else if (browser$$1.isIE) {
                    launch['default'].ie(href, supported, unsupported);
                } else if (browser$$1.isiOS) {
                    launch['default'].ios(href, supported, unsupported);
                } else {
                    launch['default']['default'](href, function () {
                        callback(UNKNOWN, browser$$1, href);
                    });
                }
                return { scheme: scheme$$1, href: href };
            }
        }]);

        return ClientDetect;
    }();

    exports.ClientDetect = ClientDetect;

    function registerGlobal(window) {
        window.ClientDetect = ClientDetect;
    }

    exports['default'] = ClientDetect;
});

var clientDetect_2 = clientDetect.ClientDetect;

/*
 *  src/logger.js
 *  mt-loggerkit
 *
 *  Copyright © 2016 Apple Inc. All rights reserved.
 *
 */

/**
 ************************************ PRIVATE METHODS/IVARS ************************************
 */

/** Global properties */
var LOGGER_PROPERTIES$1 = {
    mirrorToServerLevel: LOG_LEVELS.NONE, // equal to logger-core.Logger.LOGGER_LEVELS.NONE. We can't reference to Logger.prototype.NONE in here, because the field was merged into Logger lazily by Logger.constructor().
    topic: '' // topic must be set by the client
};

/** Default class property setters and getters */
/** Set the global Figaro topic for all loggers - this can also be set individually per logger */
Logger.setTopic = function setTopic(topic) {
    LOGGER_PROPERTIES$1.topic = topic;
};
Logger.topic = function topic() {
    return LOGGER_PROPERTIES$1.topic;
};
Logger.mirrorToServerLevel = function mirrorToServerLevel() {
    return LOGGER_PROPERTIES$1.mirrorToServerLevel;
};

Logger.loggerNamed = loggerNamed;
Logger.utils = utils;

/**
 ************************************ PUBLIC METHODS/IVARS ************************************
 */

/**
 * @param {String} topic - the Figaro 'topic' to send log events to
 * @overridable
 */
Logger.prototype.setTopic = function setTopic(topic) {
    this._topic = topic;
};

/**
 * The Figaro 'topic' to send log events to
 * @returns {String}
 * @overridable
 */
Logger.prototype.topic = function topic() {
    var topic = this._topic || Logger.topic();

    if (!topic) {
        // Do not invoke this.error() here as it could result in an infinite loop of send attempts depending on logger.mirrorToServerLevel()
        console.error('LoggerKit: topic must be set in order to mirror log events to the server. Example: loggerKit.setTopic(\'my_figaro_topic\');');
    }

    return topic;
};

/**
 * Sets the level at which we will mirror to server at or above
 * @param {*} level loglevel which may be either a string (e.g. 'debug', 'DEBUG', 'Debug', etc.) or an integer (e.g. 1, 2, 3 or logger.DEBUG, logger.INFO, logger.WARN, etc.
 * @overridable
 */
Logger.prototype.setMirrorToServerLevel = function setMirrorToServerLevel(mirrorToServerLevel) {
    var integerLevel = this.levelParameterAsInt(mirrorToServerLevel);
    if (integerLevel !== null) {
        this._mirrorToServerLevel = integerLevel;
    }
};

/**
 * Returns the current logger mirror to server level as an integer
 * @overridable
 */
Logger.prototype.mirrorToServerLevel = function mirrorToServerLevel() {
    var mirrorToServerLevel = this._mirrorToServerLevel;
    return reflect$1.isNumber(mirrorToServerLevel) ? mirrorToServerLevel : Logger.mirrorToServerLevel();
};

/*
 *  src/utils.js
 *  mt-loggerkit
 *
 *  Copyright © 2016 Apple Inc. All rights reserved.
 *
 */

//TODO would clients directly use eventRecorder? Maybe we could directly call eventRecorder in sendToServer function instead of attaching to Logger?
Logger.eventRecorder = queuedEventRecorder;

/**
 ************************************ PRIVATE METHODS/IVARS ************************************
 */
var BASE_EVENT_DATA = {
    eventType: 'log',
    eventVersion: '4' // TBD
};

/**
 * Creates an event object in the proper format for sending to the server
 * @param {Logger} logger
 * @param {String} level
 * @param {Array} logArguments
 * @param {String} (optional) callstack
 * @return {Object} key/value pairs representing the log event
 */
var _createLogEvent = function createLogEvent(logger$$1, level$$1, logArguments, callstack) {
    var logEvent = null;
    var validArguments = logArguments && logArguments.length;

    if (level$$1 && (validArguments || callstack)) {
        // do not include fields that may not be present so they aren't sent
        logEvent = {};
        reflect$1.extend(logEvent, BASE_EVENT_DATA);

        logEvent.eventTime = Date.now();
        logEvent.level = level$$1;
        logEvent.loggerName = logger$$1.loggerName();

        if (callstack) {
            logEvent.callstack = callstack;
        }

        if (validArguments) {
            try {
                logEvent.arguments = JSON.stringify(logArguments);
            } catch (e) {
                // Note: this may result in another attempted event send depending on logger.mirrorToServerLevel()
                logger$$1.error('Error stringifying arguments as JSON: ' + e);
            }

            // As a convenience, if the first argument is a string, include it as the property 'message'
            if (typeof logArguments[0] === 'string') {
                logEvent.message = logArguments[0];
                // As a convenience, if there is exactly one object argument, promote its fields to the top level
                // Keys from this object will not overwrite any existing key names (eventType, loggerName, etc.)
                // Note: If there is more than one argument, the caller probably wanted to keep them separate
                // Note 2: If the caller wants a 'message' top level field, they can include it in the object
            } else if (_typeof(logArguments[0]) === 'object' && logArguments.length === 1) {
                var logObject = logArguments[0];
                logEvent = reflect$1.extend({}, logObject, logEvent); // logEvent keys take precedence
            }
        }
    } else {
        // invoking logger.error() instead of console.error() here may result in another attempted event send
        // depending on logger.mirrorToServerLevel(), but that event would not have much useful information
        console.error('LoggerKit: at least one argument or the INCLUDE_CALL_STACK flag is required in order to mirror to server');
    }

    return logEvent;
};

var utils$1 = {
    /**
     * Enqueues a log event to be sent to the server
     * @param {Logger} logger
     * @param {String} level
     * @param {Array} logArguments
     * @param {String} (optional) callstack
     * @return {*} The result of invoking eventRecorder.recordEvent(), will typically be the event that was enqueued or null if nothing wes enqueued
     */
    sendToServer: function sendToServer(logger$$1, level$$1, logArguments, callstack) {
        var topic = logger$$1.topic();
        var logEvent = _createLogEvent(logger$$1, level$$1, logArguments, callstack);
        var returnValue = null;

        if (topic && logEvent) {
            returnValue = Logger.eventRecorder.recordEvent(topic, logEvent);
        }

        return returnValue;
    }
};

/*
 *  mt-loggerkit/index.js
 *  mt-loggerkit
 *
 *  Copyright © 2016 Apple Inc. All rights reserved.
 *
 */

// delegate base Logger utility functions (e.g. sendToServer) to LoggerKit
Logger.utils.setDelegate(utils$1);

var __extends$1 = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __assign = undefined && undefined.__assign || Object.assign || function (t$$1) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t$$1[p] = s[p];
        }
    }
    return t$$1;
};
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = undefined && undefined.__generator || function (thisArg, body) {
    var _ = { label: 0, sent: function sent() {
            if (t$$1[0] & 1) throw t$$1[1];return t$$1[1];
        }, trys: [], ops: [] },
        f,
        y,
        t$$1,
        g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
    }), g;
    function verb(n) {
        return function (v) {
            return step([n, v]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) {
            try {
                if (f = 1, y && (t$$1 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t$$1 = y["return"]) && t$$1.call(y), 0) : y.next) && !(t$$1 = t$$1.call(y, op[1])).done) return t$$1;
                if (y = 0, t$$1) op = [op[0] & 2, t$$1.value];
                switch (op[0]) {
                    case 0:case 1:
                        t$$1 = op;break;
                    case 4:
                        _.label++;return { value: op[1], done: false };
                    case 5:
                        _.label++;y = op[1];op = [0];continue;
                    case 7:
                        op = _.ops.pop();_.trys.pop();continue;
                    default:
                        if (!(t$$1 = _.trys, t$$1 = t$$1.length > 0 && t$$1[t$$1.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;continue;
                        }
                        if (op[0] === 3 && (!t$$1 || op[1] > t$$1[0] && op[1] < t$$1[3])) {
                            _.label = op[1];break;
                        }
                        if (op[0] === 6 && _.label < t$$1[1]) {
                            _.label = t$$1[1];t$$1 = op;break;
                        }
                        if (t$$1 && _.label < t$$1[2]) {
                            _.label = t$$1[2];_.ops.push(op);break;
                        }
                        if (t$$1[2]) _.ops.pop();
                        _.trys.pop();continue;
                }
                op = body.call(thisArg, _);
            } catch (e) {
                op = [6, e];y = 0;
            } finally {
                f = t$$1 = 0;
            }
        }if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Logger.setTopic('xp_amp_music_webplayer_log');
var ITUNES_SWIZZLE = /(music|itunes).apple.com/;
var EMBED_SWIZZLE = 'embed.music.apple.com';
var METRICS_DEFAULTS = {
    app: 'com.apple.music.embed',
    baseVersion: 1,
    hostApp: navigator.userAgent,
    pageContext: 'MusicKitEmbedWebPlayer',
    pageUrl: window.location.href,
    topic: 'xp_amp_music_webplayer'
};
var Events = MusicKit.Events;
var MKError = MusicKit.MKError;
var PlaybackStates = MusicKit.PlaybackStates;
var Queue = MusicKit.Queue;
var configure = MusicKit.configure;
var getInstance = MusicKit.getInstance;
var formattedMediaURL = MusicKit.formattedMediaURL;
var generateEmbedCode = MusicKit.generateEmbedCode;
var formatMediaTime = MusicKit.formatMediaTime;
var EmbedPlayer = /** @class */function (_super) {
    __extends$1(EmbedPlayer, _super);
    function EmbedPlayer(options) {
        var _this = _super.call(this, options) || this;
        // Display Modals
        _this.displayShare = false;
        _this.displayUpsell = false;
        _this.displayLogout = false;
        _this.timeRemainingMode = true;
        _this.hasNotPlayed = true;
        _this.unknown = true;
        _this.canPlay = false;
        _this.canSupportDRM = false;
        _this.logger = Logger.loggerNamed('WebPlayer');
        _this.needsStorageAccess = 'hasStorageAccess' in document && 'requestStorageAccess' in document;
        _this.state = PlaybackStates.none;
        _this.disablePreviews = true;
        _this.isSingleItem = false;
        _this.isAlbum = false;
        _this.isPlaylist = false;
        _this.isPlayingDuringSeek = false;
        _this.isContentMissingError = false;
        _this.isContentReady = false;
        var debug = /\bdebug=(1|true)\b/.test(_this.queryString);
        _this.disablePreviews = /\bpreviews?=(0|false)\b/.test(_this.queryString);
        _this.logger.setLevel(debug ? _this.logger.DEBUG : _this.logger.ERROR);
        _this.logger.setMirrorToServerLevel(_this.logger.ERROR);
        var browser = clientDetect_2.browser();
        _this.logger.debug({ browser: browser });
        if (window.self === window.top) {
            document.documentElement.className += 'pop';
        }
        configure({
            developerToken: 'eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IldlYlBsYXlLaWQifQ.eyJpYXQiOjE2MTY2MTgyMjIsImV4cCI6MTYyMjgzOTAyMiwiaXNzIjoiQU1QV2ViUGxheSJ9.ozJUlGPAGdKR1clZAPJTa0mY5c4Nt83jicwXYZwmK0xeXfU633kxS3cDnyianIYS6cJnSvuLZ24j6nwkD69v0A',
            app: {
                name: 'Apple Music Web Player'
            },
            features: ['equivalencies'],
            linkParameters: {
                itscg: '50000',
                itsct: 'web_player'
            },
            mergeQueryParams: true,
            persist: 'cookie',
            prefix: 'web',
            sourceType: 8,
            suppressErrorDialog: true,
            debug: debug
        });
        var music = getInstance();
        _this.logger.debug({ music: music });
        _this.logger.debug(music.subscribeURL);
        music.addEventListener(Events.mediaCanPlay, function () {
            return _this.canPlay = true;
        });
        music.addEventListener(Events.mediaItemDidChange, function (_a) {
            var item = _a.item;
            _this.currentMediaItem = item;
            _this.duration = Math.round(item.playbackDuration);
            _this.formattedDuration = formatMediaTime(_this.duration);
        });
        music.addEventListener(Events.playbackStateDidChange, function (_a) {
            var state = _a.state;
            if (browser.isAndroid && state === PlaybackStates.waiting) {
                _this.stalledTimer = setTimeout(function () {
                    music.player.previewOnly = true;
                    music.player.stop();
                    _this.hasNotPlayed = true;
                    _this.currentMediaItem = null;
                }, 5000);
            }
            // Transitioning from paused to seeking
            if (_this.isPaused && state === PlaybackStates.seeking) {
                _this.isPlayingDuringSeek = false;
                // Transitioning from playing to seeking
            } else if (_this.isPlaying && state === PlaybackStates.seeking) {
                _this.isPlayingDuringSeek = true;
            }
            _this.state = state;
            if (_this.state === PlaybackStates.playing) {
                _this.hasNotPlayed = false;
                if (_this.stalledTimer) {
                    clearTimeout(_this.stalledTimer);
                    _this.stalledTimer = undefined;
                }
            }
            if (_this.state === PlaybackStates.completed) {
                _this.currentMediaItem = null;
            }
        });
        music.addEventListener(Events.playbackTimeDidChange, function (event) {
            var currentPlaybackDuration = event.currentPlaybackDuration,
                currentPlaybackTime = event.currentPlaybackTime,
                currentPlaybackTimeRemaining = event.currentPlaybackTimeRemaining;
            _this.duration = currentPlaybackDuration;
            _this.formattedDuration = formatMediaTime(_this.duration);
            _this.currentTime = currentPlaybackTime;
            if (!_this.isScrubbing) {
                _this.progress = music.player.currentPlaybackProgress;
                _this.remainingTime = currentPlaybackTimeRemaining;
                _this.formattedTime = "-" + formatMediaTime(_this.remainingTime);
            }
        });
        music.addEventListener(Events.playbackDurationDidChange, function () {
            _this.duration = music.player.currentPlaybackDuration;
            _this.formattedDuration = formatMediaTime(_this.duration);
        });
        music.addEventListener(Events.mediaPlaybackError, function (error) {
            _this._playbackError(error);
        });
        if (!_this.needsStorageAccess) {
            music.musicUserToken = _this.mut;
        }
        _this.canSupportDRM = music.player.canSupportDRM;
        // We only want to upsell those with full song playback support.
        if (_this.canSupportDRM) {
            music.storekit.addEventListener(Events.eligibleForSubscribeView, function () {
                _this.displayUpsell = true;
                _this.sendUpsellImpressionEvent({
                    id: 'WebPlayer.Upsell.CTA',
                    component: 'button',
                    name: 'startTrial'
                });
                _this.sendUpsellImpressionEvent({
                    id: 'signIn',
                    component: 'button',
                    name: 'signIn'
                });
            });
        }
        _this.iFrameID = "apple-music-embed-" + Date.now();
        // this.theme = 'dark';
        // Load translations into window
        // TODO: error casing, no lang, etc.
        try {
            _this.loadTranslations();
        } catch (e) {
            console.error(e);
        }
        // To handle local and production environment
        var pathName = !!location.hash && !/^#amp/i.test(location.hash) ? location.hash.substring(1) : "" + location.pathname + location.search;
        var _a = formattedMediaURL(pathName),
            contentId = _a.contentId,
            kind = _a.kind,
            storefrontId = _a.storefrontId;
        if (contentId && kind && storefrontId) {
            music.storefrontId = storefrontId;
            _this.typeId = contentId === '1405365674' ? '1418213110' : contentId;
            switch (kind) {
                case 'album':
                case 'albums':
                    _this.loadAlbum(_this.typeId);
                    _this.isAlbum = true;
                    break;
                case 'playlist':
                case 'playlists':
                    _this.loadPlaylist(_this.typeId);
                    _this.isPlaylist = true;
                    break;
                case 'song':
                case 'songs':
                    _this.loadSong(_this.typeId);
                    _this.isSingleItem = true;
                    break;
            }
        }
        _this.clickstreamProcessor = new ClickstreamProcessor(METRICS_DEFAULTS.topic, mtkitDelegates);
        _this.clickstreamProcessor.init();
        _this.clickstreamProcessor.config.setDelegate({
            constraintProfile: function constraintProfile() {
                return 'strict';
            }
        });
        window.onbeforeunload = function () {
            this.clickstreamProcessor.system.eventRecorder.flushUnreportedEvents(true);
        }.bind(_this);
        _this._sendMetricsPageEvent();
        return _this;
    }
    Object.defineProperty(EmbedPlayer.prototype, "isPlaying", {
        get: function get$$1() {
            return this.state === PlaybackStates.playing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "isPaused", {
        get: function get$$1() {
            return this.state === PlaybackStates.paused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "isResting", {
        get: function get$$1() {
            return this.state === PlaybackStates.none;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "isEnded", {
        get: function get$$1() {
            return this.state === PlaybackStates.ended;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "isSeeking", {
        get: function get$$1() {
            return this.state === PlaybackStates.seeking;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "isWaiting", {
        get: function get$$1() {
            return this.state === PlaybackStates.loading || this.state === PlaybackStates.waiting;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "isInProgress", {
        get: function get$$1() {
            // Indicates if we are in some form of state where playback is in progress.
            // This goes beyond just "playing", including a state where we are scrubbing through
            // the song while the song is playing, or while we're loading.
            //
            // This is used to animate/enshadow the album artwork when we start playback and maintain it
            // throughout various state changes until the song is stopped or paused.
            //
            // Using isPlaying is not sufficient because that is a single, very specific state
            // and it will cause the artwork to "jump" during state changes.
            switch (this.state) {
                case PlaybackStates.loading:
                case PlaybackStates.playing:
                case PlaybackStates.waiting:
                case PlaybackStates.stalled:
                    return true;
                case PlaybackStates.seeking:
                    return this.isPlayingDuringSeek;
                case PlaybackStates.none:
                case PlaybackStates.paused:
                case PlaybackStates.stopped:
                case PlaybackStates.ended:
                case PlaybackStates.completed:
                default:
                    return false;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "songs", {
        get: function get$$1() {
            if (this.content.relationships.tracks) {
                return this.content.relationships.tracks.data;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "authenticated", {
        get: function get$$1() {
            return getInstance().isAuthorized;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "signedIn", {
        get: function get$$1() {
            if (this.needsStorageAccess) {
                return this.mut ? this.authenticated : this.unknown;
            }
            return this.authenticated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "disableExplicit", {
        get: function get$$1() {
            return getInstance().isRestricted;
        },
        enumerable: true,
        configurable: true
    });
    EmbedPlayer.prototype.didInsertElement = function () {
        // TODO: Technically this fires before the play/preview button is rendered
        // but this seems "close enough" since the button will be visible as soon
        // as the page finishes loading
        this._sendPlayButtonImpressionEvent();
    };
    Object.defineProperty(EmbedPlayer.prototype, "mut", {
        get: function get$$1() {
            return getInstance().musicUserToken;
        },
        set: function set$$1(mut) {
            this.unknown = false;
            if (this.mut !== mut) {
                getInstance().musicUserToken = mut;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "cid", {
        get: function get$$1() {
            return getInstance().storekit.cid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "queryString", {
        get: function get$$1() {
            if (!this._queryString) {
                var currentLocation = window.location.href;
                if (currentLocation.indexOf('?') !== -1) {
                    this._queryString = currentLocation.substr(currentLocation.indexOf('?')).replace('?', '');
                }
            }
            return this._queryString;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmbedPlayer.prototype, "contentURL", {
        get: function get$$1() {
            return this.selection && this.selection.attributes.url || this.content.attributes.url;
        },
        enumerable: true,
        configurable: true
    });
    EmbedPlayer.prototype.loadTranslations = function () {
        return __awaiter(this, void 0, void 0, function () {
            var meta, rootURL, defaultLanguage, preferred, language, response, _a, _b, response, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        meta = document.head.querySelector('meta[name=contentRoot]');
                        rootURL = meta && meta['content'] ? meta['content'] : '/';
                        defaultLanguage = 'en-gb';
                        preferred = navigator.languages ? navigator.languages[0] : navigator.language;
                        language = preferred ? preferred.toLocaleLowerCase() : defaultLanguage;
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 4,, 7]);
                        return [4 /*yield*/, fetch(rootURL + "locales/" + language + "/translations.json", {
                            // bypass cache entirely to short circuit race condition from 304
                            cache: 'no-store'
                        })];
                    case 2:
                        response = _d.sent();
                        _a = window;
                        return [4 /*yield*/, response.json()];
                    case 3:
                        _a.appleTranslations = _d.sent();
                        return [3 /*break*/, 7];
                    case 4:
                        _b = _d.sent();
                        return [4 /*yield*/, fetch(rootURL + "locales/" + defaultLanguage + "/translations.json", {
                            // bypass cache entirely to short circuit race condition from 304
                            cache: 'no-store'
                        })];
                    case 5:
                        response = _d.sent();
                        _c = window;
                        return [4 /*yield*/, response.json()];
                    case 6:
                        _c.appleTranslations = _d.sent();
                        return [3 /*break*/, 7];
                    case 7:
                        this.isContentReady = !!this.content && !!window.appleTranslations;
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype.loadAlbum = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 2,, 3]);
                        _a = this;
                        return [4 /*yield*/, getInstance().api.album(id, { include: 'artists' })];
                    case 1:
                        _a.content = _c.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _b = _c.sent();
                        return [2 /*return*/, this._showNoContentError()];
                    case 3:
                        if (!this.content) {
                            return [2 /*return*/, this._showNoContentError()];
                        }
                        getInstance().player.queue = new Queue(this.content);
                        this.isContentReady = !!this.content && !!window.appleTranslations;
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype.loadPlaylist = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _c.trys.push([0, 2,, 3]);
                        _a = this;
                        return [4 /*yield*/, getInstance().api.playlist(id, { include: 'curator' })];
                    case 1:
                        _a.content = _c.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _b = _c.sent();
                        return [2 /*return*/, this._showNoContentError()];
                    case 3:
                        if (!this.content) {
                            return [2 /*return*/, this._showNoContentError()];
                        }
                        if (!this.content.attributes.artwork && this.content.relationships.tracks) {
                            this.content.attributes.artwork = this.content.relationships.tracks.data[0].attributes.artwork;
                        }
                        getInstance().player.queue = new Queue(this.content);
                        this.isContentReady = !!this.content && !!window.appleTranslations;
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype.loadSong = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 2,, 3]);
                        _a = this;
                        _b = this;
                        return [4 /*yield*/, getInstance().api.song(id, { include: 'albums' })];
                    case 1:
                        _a.content = _b.selection = _d.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _c = _d.sent();
                        return [2 /*return*/, this._showNoContentError()];
                    case 3:
                        if (!this.content) {
                            return [2 /*return*/, this._showNoContentError()];
                        }
                        getInstance().player.queue = new Queue(this.content);
                        this.isContentReady = !!this.content && !!window.appleTranslations;
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype.login = function (isDialog, event) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (isDialog) {
                            this.sendMetricsDialogEvent({
                                result: 'signIn',
                                actionType: 'navigate',
                                targetId: 'signIn'
                            });
                        } else if (event) {
                            this.sendMetricsClickEvent({
                                targetType: 'link',
                                targetId: 'signIn',
                                actionType: 'navigate',
                                actionDetails: {
                                    actionText: 'signIn'
                                },
                                targetElement: event.target
                            });
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3,, 4]);
                        _a = this;
                        return [4 /*yield*/, getInstance().authorize()];
                    case 2:
                        _a.mut = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _b.sent();
                        this.errorMessage = t('WebPlayer.SignIn.StorefrontError');
                        return [2 /*return*/];
                    case 4:
                        this.close();
                        // Impress play button change (Preview -> Play)
                        this._sendPlayButtonImpressionEvent();
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype.logout = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2,, 3]);
                        return [4 /*yield*/, getInstance().unauthorize()];
                    case 1:
                        _a.sent();
                        this.mut = undefined;
                        this.displayLogout = false;
                        return [3 /*break*/, 3];
                    case 2:
                        e_2 = _a.sent();
                        // TODO
                        this.errorMessage = t('WebPlayer.SignIn.StorefrontError');
                        return [2 /*return*/];
                    case 3:
                        // Impress play button change (Play -> Preview)
                        this._sendPlayButtonImpressionEvent();
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype.upsell = function (isDialog, event) {
        var _this = this;
        var url = getInstance().subscribeIndividualURL;
        var metricsData;
        if (isDialog) {
            metricsData = this.sendMetricsDialogEvent({
                result: 'upsell',
                actionType: 'navigate',
                targetId: 'startTrial'
            });
        } else {
            metricsData = this.sendMetricsClickEvent({
                targetType: 'button',
                targetId: 'startTrial',
                actionType: 'signUp',
                targetElement: event.target
            });
        }
        if (metricsData.clientId) {
            // Note that this assumes OFFER_URL already has query params (which it is currently hardcoded to have)
            url = url + "&ign-refClientId=" + metricsData.clientId;
        }
        clientDetect_2.launchClient(url, function (supported) {
            _this.close();
        });
    };
    EmbedPlayer.prototype.share = function (event) {
        this.displayShare = true;
        this.sendMetricsClickEvent({
            targetType: 'button',
            targetId: 'WebPlayerShareSheet',
            actionType: 'select',
            targetElement: event.target
        });
    };
    EmbedPlayer.prototype.showLogoutModal = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.needsStorageAccess) {
                            return [2 /*return*/, this._showLogoutModal(event)];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3,, 4]);
                        return [4 /*yield*/, document.requestStorageAccess()];
                    case 2:
                        _b.sent();
                        this.logger.debug('showLogoutModal() => requestStorageAccess was granted');
                        if (!getInstance().isAuthorized) {
                            this.mut = getInstance().musicUserToken;
                            this.unknown = false;
                            return [2 /*return*/];
                        }
                        return [2 /*return*/, this._showLogoutModal(event)];
                    case 3:
                        _a = _b.sent();
                        this.logger.debug('showLogoutModal() => requestStorageAccess was rejected');
                        this.unknown = false;
                        return [3 /*break*/, 4];
                    case 4:
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype._showLogoutModal = function (event) {
        this.displayLogout = true;
        this.sendMetricsClickEvent({
            targetType: 'button',
            targetId: 'signOut',
            actionType: 'navigate',
            actionDetails: {
                actionText: 'signOut'
            },
            targetElement: event.target
        });
    };
    EmbedPlayer.prototype.close = function (isDialog) {
        this.displayShare = false;
        this.displayUpsell = false;
        this.displayLogout = false;
        this.errorMessage = undefined;
        if (isDialog) {
            this.sendMetricsDialogEvent({
                result: 'cancel',
                actionType: 'cancel',
                targetId: 'cancel'
            });
        }
    };
    EmbedPlayer.prototype.closeError = function () {
        this.sendMetricsDialogEvent({
            message: this.errorMessage,
            result: 'cancel',
            actionType: 'cancel',
            targetId: 'cancel'
        });
        this.close();
    };
    EmbedPlayer.prototype.openURL = function (targetURL, actionText, event) {
        if (!targetURL) {
            return;
        }
        // TODO: <rdar://problem/37010821> Web Player - Embed - clean up metrics code hack to differentiate between album/playlist and artist/curator
        if (actionText === 'album/playlist') {
            actionText = this.isAlbum ? 'album' : 'playlist';
        } else if (actionText === 'artist/curator') {
            actionText = this.isPlaylist ? 'curator' : 'artist';
        }
        this.sendMetricsClickEvent({
            targetType: 'link',
            actionType: 'open',
            actionDetails: {
                actionText: actionText
            },
            actionURL: this.contentURL,
            targetElement: event.target
        });
        if (this.queryString) {
            targetURL = "" + targetURL + (targetURL.indexOf('?') === -1 ? '?' : '&') + this.queryString;
        }
        window.open(targetURL);
    };
    EmbedPlayer.prototype.select = function (selection, event) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.needsStorageAccess) {
                            return [2 /*return*/, this._select(selection, event)];
                        }
                        getInstance().deferPlayback();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3,, 4]);
                        return [4 /*yield*/, document.requestStorageAccess()];
                    case 2:
                        _b.sent();
                        this.logger.debug('select() => requestStorageAccess was granted');
                        this.mut = getInstance().musicUserToken;
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        this.logger.debug('select() => requestStorageAccess was rejected');
                        return [3 /*break*/, 4];
                    case 4:
                        return [2 /*return*/, this._select(selection, event)];
                }
            });
        });
    };
    EmbedPlayer.prototype._select = function (selection, event) {
        var _this = this;
        this.selection = selection;
        var attributes = this.selection.attributes;
        if (!attributes || this.disableExplicit && attributes.contentRating === 'explicit' || !attributes.playParams) {
            return;
        }
        if (!this.authenticated && this.disablePreviews) {
            this.displayUpsell = true;
            return;
        }
        getInstance().player.continuous = this.authenticated;
        if (this.selection === this.currentMediaItem) {
            return this.isPaused ? this.play(event) : this.pause();
        }
        this.sendMetricsClickEvent({
            targetType: 'button',
            actionType: this.authenticated ? 'play' : 'preview',
            actionDetails: 'trackSelection',
            actionURL: this.contentURL,
            targetElement: event.target
        });
        getInstance().player.changeToMediaItem(this.selection.id).then(function () {
            _this.sendMetricsMediaEvent({
                actionType: 'play',
                position: 0
            });
        }).catch(function (error) {
            return _this._playbackError(error);
        });
    };
    EmbedPlayer.prototype.play = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.needsStorageAccess) {
                            return [2 /*return*/, this._play(this.authenticated, event)];
                        }
                        getInstance().deferPlayback();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3,, 4]);
                        return [4 /*yield*/, document.requestStorageAccess()];
                    case 2:
                        _b.sent();
                        this.logger.debug('play() => requestStorageAccess was granted');
                        this.mut = getInstance().musicUserToken;
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        this.logger.debug('play() => requestStorageAccess was rejected');
                        return [3 /*break*/, 4];
                    case 4:
                        return [2 /*return*/, this._play(this.authenticated, event)];
                }
            });
        });
    };
    EmbedPlayer.prototype._play = function (authenticated, event) {
        var _this = this;
        if (this.selection) {
            var attributes = this.selection.attributes;
            if (!attributes || this.disableExplicit && attributes.contentRating === 'explicit' || !attributes.playParams) {
                return;
            }
        }
        if (!authenticated && this.disablePreviews) {
            this.displayUpsell = true;
            return;
        }
        // Explicit clicks to the play button should play continuous regardless of auth
        getInstance().player.continuous = true;
        this.sendMetricsClickEvent({
            targetType: 'button',
            actionType: authenticated ? 'play' : 'preview',
            actionURL: this.contentURL,
            targetElement: event.target
        });
        getInstance().player.play().then(function () {
            _this.sendMetricsMediaEvent({
                actionType: 'play',
                position: getInstance().player.currentPlaybackTime
            });
        }).catch(function (error) {
            return _this._playbackError(error);
        });
    };
    EmbedPlayer.prototype._playbackError = function (error) {
        var dialog = error.dialog,
            description = error.description,
            errorCode = error.errorCode,
            name = error.name,
            status = error.status;
        if (name === 'AbortError') {
            // <rdar://problem/37697498> Web Player: The operation was aborted error when skipping tracks
            return;
        }
        if (errorCode === MKError.AUTHORIZATION_ERROR) {
            this.logout();
            return this.login();
        } else if (errorCode === MKError.SUBSCRIPTION_ERROR) {
            this.logout();
            this.errorMessage = description;
        } else if (errorCode === MKError.CONTENT_RESTRICTED) {
            this.errorMessage = t('WebPlayer.Error.ExplicitContent_message');
        } else if (status === 0) {
            this.errorMessage = t('MZStore.ItemNotAvailableInAppleMusic_message');
        } else if (dialog) {
            error.presentDialog();
        } else {
            this.errorMessage = description || 'Unknown Error';
        }
        this.logger.error({
            errorMessage: this.errorMessage,
            errorCode: errorCode
        });
    };
    EmbedPlayer.prototype.pause = function () {
        this.sendMetricsMediaEvent({
            actionType: 'stop',
            actionDetails: 'pause',
            position: getInstance().player.currentPlaybackTime
        });
        getInstance().player.pause();
    };
    EmbedPlayer.prototype.togglePlay = function (event) {
        return this.isPlaying ? this.pause() : this.play(event);
    };
    EmbedPlayer.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.needsStorageAccess) {
                            return [2 /*return*/, this._next()];
                        }
                        getInstance().deferPlayback();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3,, 4]);
                        return [4 /*yield*/, document.requestStorageAccess()];
                    case 2:
                        _b.sent();
                        this.logger.debug('next() => requestStorageAccess was granted');
                        this.mut = getInstance().musicUserToken;
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        this.logger.debug('next() => requestStorageAccess was rejected');
                        return [3 /*break*/, 4];
                    case 4:
                        return [2 /*return*/, this._next()];
                }
            });
        });
    };
    EmbedPlayer.prototype._next = function () {
        var _this = this;
        var previousId = this.typeId;
        var previousPosition = getInstance().player.currentPlaybackTime;
        getInstance().player.skipToNextItem().then(function () {
            _this.sendMetricsMediaEvent({
                actionType: 'stop',
                actionDetails: 'skipNext',
                position: previousPosition,
                id: previousId
            });
            _this.sendMetricsMediaEvent({
                actionType: 'play',
                position: 0
            });
        }).catch(function (error) {
            return _this._playbackError(error);
        });
    };
    EmbedPlayer.prototype.scrub = function (event) {
        this.progress = event.target.value;
        var song = document.querySelector('.song');
        var rangeValue = event.target.value;
        var newTime = this.duration * rangeValue;
        this.sendMetricsMediaEvent({
            actionType: 'seek',
            actionDetails: 'end',
            position: newTime
        });
        getInstance().player.seekToTime(newTime);
        this.isScrubbing = false;
    };
    EmbedPlayer.prototype.seeking = function (event) {
        var bar = document.querySelector('.progress-bar__bg');
        var progress = document.querySelector('.progress-bar__fg');
        var rangeValue = event.target.value;
        // Need to keep this @tracked prop (@progress) in sync here
        // Also need to stop regular playback from updating progress while user is seeking
        this.progress = rangeValue;
        var newCurrentTime = this.duration * rangeValue;
        var newRemainingTime = this.duration - newCurrentTime;
        if (!this.isScrubbing) {
            this.sendMetricsMediaEvent({
                actionType: 'seek',
                actionDetails: 'start',
                position: getInstance().player.currentPlaybackTime
            });
        }
        this.isScrubbing = true;
        bar.value = rangeValue;
        progress.style.width = Math.floor(rangeValue * 100) + "%";
        this.currentTime = newCurrentTime;
        this.formattedTime = formatMediaTime(newRemainingTime);
    };
    EmbedPlayer.prototype.toggleTimeFormat = function () {
        this.timeRemainingMode = !this.timeRemainingMode;
    };
    EmbedPlayer.prototype.addSongToLibrary = function (actionText, song, event) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        event.stopPropagation();
                        if (!this.needsStorageAccess) {
                            return [2 /*return*/, this._addSongToLibrary(actionText, song, event)];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3,, 4]);
                        return [4 /*yield*/, document.requestStorageAccess()];
                    case 2:
                        _b.sent();
                        this.logger.debug('addSongToLibrary() => requestStorageAccess was granted');
                        this.mut = getInstance().musicUserToken;
                        this._addSongToLibrary(actionText, song, event);
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        this.logger.debug('addSongToLibrary() => requestStorageAccess was rejected');
                        this.displayUpsell = true;
                        return [3 /*break*/, 4];
                    case 4:
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype._addSongToLibrary = function (actionText, song, event) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._displayToast('add');
                        return [4 /*yield*/, getInstance().api.addToLibrary({ songs: [song.id] }).catch(function () {
                            _this.errorMessage = t('WebPlayer.Share.AddToLibrary.Error');
                            _this._dismissToast();
                        })];
                    case 1:
                        _a.sent();
                        this.close();
                        this.sendMetricsClickEvent({
                            targetType: 'button',
                            actionType: 'select',
                            actionDetails: {
                                actionText: actionText,
                                actionSubtype: 'add'
                            },
                            actionURL: this.contentURL,
                            targetElement: event.target
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype.addTracklistToLibrary = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        event.stopPropagation();
                        if (!this.needsStorageAccess) {
                            return [2 /*return*/, this._addTracklistToLibrary(event)];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3,, 4]);
                        return [4 /*yield*/, document.requestStorageAccess()];
                    case 2:
                        _b.sent();
                        this.logger.debug('addSongToLibrary() => requestStorageAccess was granted');
                        this.mut = getInstance().musicUserToken;
                        return [2 /*return*/, this._addTracklistToLibrary(event)];
                    case 3:
                        _a = _b.sent();
                        this.logger.debug('addSongToLibrary() => requestStorageAccess was rejected');
                        this.displayUpsell = true;
                        return [3 /*break*/, 4];
                    case 4:
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype._addTracklistToLibrary = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var resource, toastType;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        resource = this.isAlbum ? { albums: [this.content.id] } : { playlists: [this.content.id] };
                        toastType = this.isAlbum ? 'add-album' : 'add-playlist';
                        this._displayToast(toastType);
                        return [4 /*yield*/, getInstance().api.addToLibrary(resource).catch(function () {
                            _this.errorMessage = t('WebPlayer.Share.AddToLibrary.Error');
                            _this._dismissToast();
                        })];
                    case 1:
                        _a.sent();
                        ;
                        this.close();
                        this.sendMetricsClickEvent({
                            targetType: 'button',
                            actionType: 'select',
                            actionDetails: {
                                actionText: this.isAlbum ? 'addAlbumToLibrary' : 'addPlaylistToLibrary',
                                actionSubtype: 'add'
                            },
                            actionURL: this.contentURL,
                            targetElement: event.target
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    EmbedPlayer.prototype.copyToClipboard = function (copyString, embed, actionText, event) {
        // Grab the copyToClipboard dummy <input> element
        var copyToClipboard = document.getElementById('copy-to-clipboard');
        // For Embed Codes as opposed to just links
        if (embed) {
            copyString = generateEmbedCode(copyString);
        }
        // Set a value attribute on the dummy <input> to the string to be copied.
        copyToClipboard.setAttribute('value', copyString);
        // iOS Devices need to use a range element for this copy.
        if (clientDetect_2.browser().isiOS) {
            var range = document.createRange();
            range.selectNodeContents(copyToClipboard);
            var selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            copyToClipboard.setSelectionRange(0, 999999);
        } else {
            // Other Clients can just use this line
            copyToClipboard.select();
        }
        // Copy the final value to the clipboard.
        document.execCommand('copy');
        this.close();
        var toastType = embed ? 'embed' : 'link';
        // ugly hack
        if (actionText === 'copyLinkToAlbum/Playlist') {
            actionText = this.isAlbum ? 'copyLinkToAlbum' : 'copyLinkToPlaylist';
            toastType += '-playlist';
        } else if (actionText === 'copyAlbum/PlaylistEmbedCode') {
            actionText = this.isAlbum ? 'copyAlbumEmbedCode' : 'copyPlaylistEmbedCode';
            toastType += '-playlist';
        }
        this._displayToast(toastType);
        this.sendMetricsClickEvent({
            targetType: 'button',
            actionType: 'select',
            actionDetails: {
                actionText: actionText,
                actionSubtype: 'add'
            },
            actionURL: this.contentURL,
            targetElement: event.target
        });
    };
    EmbedPlayer.prototype.openPopup = function () {
        // TODO - add plumbing here to disable original embed, modal shield, etc.
        var popupUrl = this.content.attributes.url.replace(ITUNES_SWIZZLE, EMBED_SWIZZLE);
        window.open(popupUrl);
        this.close();
    };
    // TODO: The metrics actions have a fair bit of code shared
    // between them that could stand to be refactored out.
    EmbedPlayer.prototype._sendMetricsPageEvent = function () {
        var pageType;
        var appVersion;
        appVersion = document.head.querySelector('meta[name=version]').getAttribute('content');
        if (this.isPlaylist) {
            pageType = 'Playlist';
        } else if (this.isAlbum) {
            pageType = 'Album';
        } else if (this.isSingleItem) {
            pageType = 'Track';
        } else {
            pageType = 'Picker';
        }
        var metricsData = __assign({}, METRICS_DEFAULTS, { consumerId: this.cid, appVersion: appVersion, page: pageType + "_" + this.typeId, pageType: pageType, pageDetails: {
                iFrameId: this.iFrameID
            }, parentPageUrl: document.referrer, userType: this.authenticated ? 'signedIn' : 'signedOut' });
        metricsData = this.clickstreamProcessor.eventHandlers.page.metricsData(this.typeId, pageType, METRICS_DEFAULTS.pageContext, metricsData);
        this.clickstreamProcessor.system.eventRecorder.recordEvent(METRICS_DEFAULTS.topic, metricsData);
        return metricsData;
    };
    EmbedPlayer.prototype._sendPlayButtonImpressionEvent = function () {
        var kind;
        if (this.isPlaylist) {
            kind = 'playlist';
        } else if (this.isAlbum) {
            kind = 'album';
        } else if (this.isSingleItem) {
            kind = 'track';
        }
        // TODO: Disabled play button impression (P3)
        return this._sendMetricsImpressionEvent({
            id: this.typeId,
            component: 'button',
            name: this.authenticated ? 'play' : 'preview',
            impressionQueueTag: 'data-metrics-impressions-low-latency',
            kind: kind
        });
    };
    EmbedPlayer.prototype.sendUpsellImpressionEvent = function (eventFields) {
        return this._sendMetricsImpressionEvent(eventFields);
    };
    EmbedPlayer.prototype._sendMetricsImpressionEvent = function (eventFields) {
        var pageType;
        var appVersion;
        appVersion = document.head.querySelector('meta[name=version]').getAttribute('content');
        if (this.isPlaylist) {
            pageType = 'Playlist';
        } else if (this.isAlbum) {
            pageType = 'Album';
        } else if (this.isSingleItem) {
            pageType = 'Track';
        } else {
            pageType = 'Picker';
        }
        var metricsData = __assign({}, METRICS_DEFAULTS, {
            // TODO: Batch impressions events instead of having an array with a single impression
            // <rdar://problem/37621284> Apple Music: Web Player - Metrics: Impression events are not batched
            impressions: [__assign({}, eventFields)], appVersion: appVersion, page: pageType + "_" + this.typeId, pageType: pageType, pageDetails: {
                iFrameId: this.iFrameID
            }, parentPageUrl: document.referrer, isSignedIn: this.authenticated, userType: this.authenticated ? 'signedIn' : 'signedOut' });
        metricsData = this.clickstreamProcessor.eventHandlers.impressions.metricsData(this.typeId, pageType, METRICS_DEFAULTS.pageContext, metricsData);
        this.clickstreamProcessor.system.eventRecorder.recordEvent(METRICS_DEFAULTS.topic, metricsData);
        return metricsData;
    };
    EmbedPlayer.prototype.sendMetricsClickEvent = function (_a) {
        var targetType = _a.targetType,
            targetId = _a.targetId,
            actionType = _a.actionType,
            actionURL = _a.actionURL,
            actionDetails = _a.actionDetails,
            targetElement = _a.targetElement;
        var pageType;
        if (this.isPlaylist) {
            pageType = 'Playlist';
        } else if (this.isAlbum) {
            pageType = 'Album';
        } else if (this.isSingleItem) {
            pageType = 'Track';
        } else {
            pageType = 'Picker';
        }
        var metricsData = __assign({}, METRICS_DEFAULTS, { targetId: targetId || this.selection && this.selection.id || this.typeId, page: pageType + "_" + this.typeId, consumerId: this.cid, parentPageUrl: document.referrer, pageDetails: {
                iFrameId: this.iFrameID
            }, actionURL: actionURL,
            targetType: targetType,
            actionType: actionType,
            actionDetails: actionDetails, isSignedIn: this.authenticated, userType: this.authenticated ? 'signedIn' : 'signedOut' });
        metricsData = this.clickstreamProcessor.eventHandlers.click.metricsData(this.typeId, pageType, METRICS_DEFAULTS.pageContext, targetElement, metricsData);
        this.clickstreamProcessor.system.eventRecorder.recordEvent(METRICS_DEFAULTS.topic, metricsData);
        return metricsData;
    };
    EmbedPlayer.prototype.sendMetricsDialogEvent = function (eventFields) {
        var pageType;
        var appVersion;
        appVersion = document.head.querySelector('meta[name=version]').getAttribute('content');
        if (this.isPlaylist) {
            pageType = 'Playlist';
        } else if (this.isAlbum) {
            pageType = 'Album';
        } else if (this.isSingleItem) {
            pageType = 'Track';
        } else {
            pageType = 'Picker';
        }
        var pageId = this.typeId;
        var dialogId;
        var dialogType = 'upsell';
        var options = 'WebPlayer.Upsell.CTA, signIn';
        if (this.errorMessage) {
            dialogId = 'embedWebPlayerError';
            dialogType = 'error';
            options = undefined;
        } else if (this.isPlaylist) {
            dialogId = 'embedWebPlayerPlaylistUpsell';
        } else if (this.isAlbum) {
            dialogId = 'embedWebPlayerAlbumUpsell';
        } else if (this.isSingleItem) {
            dialogId = 'embedWebPlayerTrackUpsell';
        }
        var metricsData = __assign({}, METRICS_DEFAULTS, { dialogType: dialogType, consumerId: this.cid, dialogId: dialogId,
            options: options,
            appVersion: appVersion, page: pageType + "_" + pageId, pageId: pageId, pageDetails: {
                iFrameId: this.iFrameID
            }, parentPageUrl: document.referrer, isSignedIn: this.authenticated, userType: this.authenticated ? 'signedIn' : 'signedOut' }, eventFields // Allow caller to override above fields
        );
        metricsData = this.clickstreamProcessor.eventHandlers.dialog.metricsData(pageId, pageType, METRICS_DEFAULTS.pageContext, metricsData);
        this.clickstreamProcessor.system.eventRecorder.recordEvent(METRICS_DEFAULTS.topic, metricsData);
        return metricsData;
    };
    EmbedPlayer.prototype.sendMetricsMediaEvent = function (eventFields) {
        var pageType;
        var appVersion;
        appVersion = document.head.querySelector('meta[name=version]').getAttribute('content');
        if (this.isPlaylist) {
            pageType = 'Playlist';
        } else if (this.isAlbum) {
            pageType = 'Album';
        } else if (this.isSingleItem) {
            pageType = 'Track';
        } else {
            pageType = 'Picker';
        }
        var pageId = this.typeId;
        var metricsData = __assign({}, METRICS_DEFAULTS, { consumerId: this.cid, appVersion: appVersion, page: pageType + "_" + pageId, pageId: pageId, pageDetails: {
                iFrameId: this.iFrameID
            }, parentPageUrl: document.referrer, isSignedIn: this.authenticated, userType: this.authenticated ? 'signedIn' : 'signedOut', id: this.typeId, idType: 'its_id', type: 'audio' }, eventFields // Put this last so callers can override
        );
        metricsData = this.clickstreamProcessor.eventHandlers.media.metricsData(pageId, pageType, METRICS_DEFAULTS.pageContext, metricsData);
        this.clickstreamProcessor.system.eventRecorder.recordEvent(METRICS_DEFAULTS.topic, metricsData);
        return metricsData;
    };
    EmbedPlayer.prototype.toastAnimationComplete = function () {
        this.displayToast = false;
    };
    EmbedPlayer.prototype._showNoContentError = function () {
        this.logger.error({
            errorCode: MKError.CONTENT_UNAVAILABLE
        });
        this.isContentMissingError = true;
    };
    /**
     * Displays a toast for a short period of time.
     *
     * @method _displayToast
     * @param {String} toastType ['link(-playlist)', 'embed(-playlist)', 'add(-playlist)']
     * @private
     */
    EmbedPlayer.prototype._displayToast = function (toastType) {
        this.toastType = toastType;
        this.displayToast = true;
    };
    /**
    * Hides a toast if it's on top
    *
    * @method _dismissToast
    * @private
    */
    EmbedPlayer.prototype._dismissToast = function () {
        this.toastType = null;
        this.displayToast = false;
    };
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "content", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "selection", void 0);
    __decorate([tracked, __metadata("design:type", String)], EmbedPlayer.prototype, "theme", void 0);
    __decorate([tracked, __metadata("design:type", String)], EmbedPlayer.prototype, "typeId", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "errorMessage", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "displayShare", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "displayUpsell", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "displayLogout", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "displayToast", void 0);
    __decorate([tracked, __metadata("design:type", String)], EmbedPlayer.prototype, "toastType", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "timeRemainingMode", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "hasNotPlayed", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "unknown", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "state", void 0);
    __decorate([tracked, __metadata("design:type", Number)], EmbedPlayer.prototype, "currentTime", void 0);
    __decorate([tracked, __metadata("design:type", Number)], EmbedPlayer.prototype, "remainingTime", void 0);
    __decorate([tracked, __metadata("design:type", String)], EmbedPlayer.prototype, "formattedTime", void 0);
    __decorate([tracked, __metadata("design:type", Number)], EmbedPlayer.prototype, "duration", void 0);
    __decorate([tracked, __metadata("design:type", Number)], EmbedPlayer.prototype, "progress", void 0);
    __decorate([tracked, __metadata("design:type", String)], EmbedPlayer.prototype, "formattedDuration", void 0);
    __decorate([tracked, __metadata("design:type", Object)], EmbedPlayer.prototype, "currentMediaItem", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "disablePreviews", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "isSingleItem", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "isAlbum", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "isPlaylist", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "isScrubbing", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "isPlayingDuringSeek", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "isContentMissingError", void 0);
    __decorate([tracked, __metadata("design:type", Boolean)], EmbedPlayer.prototype, "isContentReady", void 0);
    __decorate([tracked('state'), __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "isPlaying", null);
    __decorate([tracked('state'), __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "isPaused", null);
    __decorate([tracked('state'), __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "isResting", null);
    __decorate([tracked('state'), __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "isEnded", null);
    __decorate([tracked('state'), __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "isSeeking", null);
    __decorate([tracked('state'), __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "isWaiting", null);
    __decorate([tracked('state'), __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "isInProgress", null);
    __decorate([tracked('args'), __metadata("design:type", Object), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "songs", null);
    __decorate([tracked('mut'), tracked, __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "authenticated", null);
    __decorate([tracked('unknown'), tracked, __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "signedIn", null);
    __decorate([tracked('mut'), tracked, __metadata("design:type", Boolean), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "disableExplicit", null);
    __decorate([tracked, __metadata("design:type", Object), __metadata("design:paramtypes", [Object])], EmbedPlayer.prototype, "mut", null);
    __decorate([tracked, __metadata("design:type", Object), __metadata("design:paramtypes", [])], EmbedPlayer.prototype, "cid", null);
    return EmbedPlayer;
}(Component);

var __ui_components_EmbedPlayer_template__ = { "id": "p3Mnx5O8", "block": "{\"symbols\":[],\"statements\":[[6,\"div\"],[11,\"class\",[27,[\"embed-player \",[26,\"if\",[[22,[\"isSingleItem\"]],\"single\"],null],\" \",[20,\"theme\"],\" \",[26,\"if\",[[26,\"or\",[[22,[\"displayShare\"]],[22,[\"displayUpsell\"]]],null],\"overlay\"],null],\" \",[26,\"if\",[[22,[\"displayLogout\"]],\"overlay\"],null],\" \",[26,\"if\",[[22,[\"errorMessage\"]],\"overlay\"],null]]]],[8],[0,\"\\n\\n\"],[4,\"if\",[[22,[\"isContentReady\"]]],null,{\"statements\":[[0,\"\\n    \"],[5,\"SongPlayer\",[],[[\"@content\",\"@currentMediaItem\",\"@selection\",\"@signedIn\",\"@canSupportDRM\",\"@disableExplicit\",\"@isResting\",\"@isPlaying\",\"@isInProgress\",\"@isEnded\",\"@isWaiting\",\"@isScrubbing\",\"@hasNotPlayed\",\"@displayShare\",\"@displayUpsell\",\"@isSingleItem\",\"@isAlbum\",\"@currentTime\",\"@formattedTime\",\"@duration\",\"@progress\",\"@isPlayingDuringSeek\",\"@formattedDuration\",\"@timeRemainingMode\",\"@close\",\"@share\",\"@upsell\",\"@login\",\"@logout\",\"@openURL\",\"@play\",\"@pause\",\"@togglePlay\",\"@next\",\"@scrub\",\"@seeking\",\"@toggleTimeFormat\",\"@showLogoutModal\",\"@addSongToLibrary\",\"@copyToClipboard\",\"@sendMetricsClickEvent\",\"@sendMetricsDialogEvent\"],[[20,\"content\"],[20,\"currentMediaItem\"],[20,\"selection\"],[20,\"signedIn\"],[20,\"canSupportDRM\"],[20,\"disableExplicit\"],[20,\"isResting\"],[20,\"isPlaying\"],[20,\"isInProgress\"],[20,\"isEnded\"],[20,\"isWaiting\"],[20,\"isScrubbing\"],[20,\"hasNotPlayed\"],[20,\"displayShare\"],[20,\"displayUpsell\"],[20,\"isSingleItem\"],[20,\"isAlbum\"],[20,\"currentTime\"],[20,\"formattedTime\"],[20,\"duration\"],[20,\"progress\"],[20,\"isPlayingDuringSeek\"],[20,\"formattedDuration\"],[20,\"timeRemainingMode\"],[26,\"action\",[[22,[\"close\"]]],null],[26,\"action\",[[22,[\"share\"]]],null],[26,\"action\",[[22,[\"upsell\"]]],null],[26,\"action\",[[22,[\"login\"]]],null],[26,\"action\",[[22,[\"logout\"]]],null],[26,\"action\",[[22,[\"openURL\"]]],null],[26,\"action\",[[22,[\"play\"]]],null],[26,\"action\",[[22,[\"pause\"]]],null],[26,\"action\",[[22,[\"togglePlay\"]]],null],[26,\"action\",[[22,[\"next\"]]],null],[26,\"action\",[[22,[\"scrub\"]]],null],[26,\"action\",[[22,[\"seeking\"]]],null],[26,\"action\",[[22,[\"toggleTimeFormat\"]]],null],[26,\"action\",[[22,[\"showLogoutModal\"]]],null],[26,\"action\",[[22,[\"addSongToLibrary\"]]],null],[26,\"action\",[[22,[\"copyToClipboard\"]]],null],[26,\"action\",[[22,[\"sendMetricsClickEvent\"]]],null],[26,\"action\",[[22,[\"sendMetricsDialogEvent\"]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\\n\"],[0,\"    \"],[6,\"div\"],[11,\"class\",[27,[\"logout-modal \",[26,\"if\",[[22,[\"displayLogout\"]],\"show\",\"hide\"],null],\" \",[26,\"if\",[[22,[\"isSingleItem\"]],\"single\"],null]]]],[8],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"logout-modal__overlay\"],[11,\"onclick\",[26,\"action\",[[22,[\"close\"]]],null],null],[8],[9],[0,\"\\n      \"],[6,\"button\"],[10,\"class\",\"logout-modal__close\"],[11,\"onclick\",[26,\"action\",[[22,[\"close\"]]],null],null],[8],[9],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"logout-modal__bg\"],[8],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"logout-modal__content\"],[8],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"logout-modal__icon\"],[8],[9],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"logout-modal__container\"],[8],[0,\"\\n            \"],[6,\"p\"],[10,\"class\",\"logout-modal__message\"],[8],[1,[26,\"t\",[\"WebPlayer.SignedIn.Description\"],null],false],[9],[0,\"\\n            \"],[6,\"button\"],[10,\"class\",\"logout-modal__button\"],[11,\"onclick\",[26,\"action\",[[22,[\"logout\"]]],null],null],[8],[1,[26,\"t\",[\"WebPlayer.SignedIn.CTA\"],null],false],[9],[0,\"\\n          \"],[9],[0,\"\\n        \"],[9],[0,\"\\n      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n\\n    \"],[6,\"div\"],[11,\"class\",[27,[\"error-modal \",[26,\"if\",[[22,[\"errorMessage\"]],\"show\",\"hide\"],null]]]],[8],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"error-modal__overlay\"],[11,\"onclick\",[26,\"action\",[[22,[\"closeError\"]]],null],null],[8],[9],[0,\"\\n      \"],[6,\"button\"],[10,\"class\",\"error-modal__close\"],[11,\"onclick\",[26,\"action\",[[22,[\"closeError\"]]],null],null],[8],[9],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"error-modal__bg\"],[8],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"error-modal__content\"],[8],[0,\"\\n          \"],[6,\"p\"],[10,\"class\",\"error-modal__message\"],[8],[1,[20,\"errorMessage\"],false],[9],[0,\"\\n        \"],[9],[0,\"\\n      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n\\n\"],[4,\"if\",[[22,[\"songs\"]]],null,{\"statements\":[[0,\"      \"],[5,\"Tracklist\",[],[[\"@content\",\"@currentMediaItem\",\"@signedIn\",\"@canSupportDRM\",\"@disableExplicit\",\"@isPlaying\",\"@isPlayingDuringSeek\",\"@isPlaylist\",\"@displayShare\",\"@displayUpsell\",\"@select\",\"@upsell\",\"@login\",\"@close\",\"@addSongToLibrary\",\"@copyToClipboard\",\"@addTracklistToLibrary\",\"@openPopup\",\"@selection\",\"@sendMetricsClickEvent\",\"@sendMetricsDialogEvent\",\"@sendUpsellImpressionEvent\"],[[20,\"content\"],[20,\"currentMediaItem\"],[20,\"signedIn\"],[20,\"canSupportDRM\"],[20,\"disableExplicit\"],[20,\"isPlaying\"],[20,\"isPlayingDuringSeek\"],[20,\"isPlaylist\"],[20,\"displayShare\"],[20,\"displayUpsell\"],[26,\"action\",[[22,[\"select\"]]],null],[26,\"action\",[[22,[\"upsell\"]]],null],[26,\"action\",[[22,[\"login\"]]],null],[26,\"action\",[[22,[\"close\"]]],null],[26,\"action\",[[22,[\"addSongToLibrary\"]]],null],[26,\"action\",[[22,[\"copyToClipboard\"]]],null],[26,\"action\",[[22,[\"addTracklistToLibrary\"]]],null],[26,\"action\",[[22,[\"openPopup\"]]],null],[20,\"selection\"],[26,\"action\",[[22,[\"sendMetricsClickEvent\"]]],null],[26,\"action\",[[22,[\"sendMetricsDialogEvent\"]]],null],[26,\"action\",[[22,[\"sendUpsellImpressionEvent\"]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"\\n      \"],[5,\"Toast\",[],[[\"@displayToast\",\"@toastType\",\"@toastAnimationComplete\"],[[20,\"displayToast\"],[20,\"toastType\"],[26,\"action\",[[22,[\"toastAnimationComplete\"]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"\\n    \"],[6,\"div\"],[11,\"class\",[27,[\"loading \",[26,\"if\",[[22,[\"isSingleItem\"]],\"single\"],null]]]],[8],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"logo\"],[8],[9],[0,\"\\n\"],[4,\"if\",[[22,[\"isContentMissingError\"]]],null,{\"statements\":[[0,\"          \"],[6,\"div\"],[10,\"class\",\"error\"],[8],[0,\"\\n            \"],[6,\"p\"],[10,\"class\",\"error__header\"],[8],[1,[26,\"t\",[\"WebPlayer.Error.NoContent.Title\"],null],false],[9],[0,\"\\n            \"],[6,\"p\"],[10,\"class\",\"error__message\"],[8],[1,[26,\"t\",[\"WebPlayer.Error.NoContent.Message\"],null],false],[9],[0,\"\\n          \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"    \"],[9],[0,\"\\n\"]],\"parameters\":[]}],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/web-embed-app/components/EmbedPlayer" } };

var __extends$2 = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var PlaybackBars = /** @class */function (_super) {
    __extends$2(PlaybackBars, _super);
    function PlaybackBars() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PlaybackBars;
}(Component);

var __ui_components_PlaybackBars_template__ = { "id": "vHlQblaf", "block": "{\"symbols\":[\"@isPlaying\"],\"statements\":[[6,\"div\"],[11,\"class\",[27,[\"bars \",[26,\"if\",[[21,1,[]],\"dance\"],null]]]],[8],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"bar one\"],[8],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"bar two\"],[8],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"bar three\"],[8],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"bar four\"],[8],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/web-embed-app/components/PlaybackBars" } };

var __extends$3 = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ProgressBar = /** @class */function (_super) {
    __extends$3(ProgressBar, _super);
    function ProgressBar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ProgressBar.prototype, "percent", {
        get: function get$$1() {
            var width = this.args.progress * 100;
            return width + "%";
        },
        enumerable: true,
        configurable: true
    });
    ProgressBar.prototype.didInsertElement = function () {
        var inputRange = document.querySelector('.progress-bar__bg');
        inputRange.value = '0'; // otherwise default value is the middle
    };
    __decorate$1([tracked('args'), __metadata$1("design:type", String), __metadata$1("design:paramtypes", [])], ProgressBar.prototype, "percent", null);
    return ProgressBar;
}(Component);

var __ui_components_ProgressBar_template__ = { "id": "rR66yMr5", "block": "{\"symbols\":[\"@progress\",\"@scrub\",\"@seeking\"],\"statements\":[[6,\"div\"],[10,\"class\",\"progress-bar\"],[8],[0,\"\\n  \"],[6,\"input\"],[10,\"class\",\"progress-bar__bg\"],[10,\"step\",\"any\"],[10,\"min\",\"0\"],[10,\"max\",\"1\"],[11,\"value\",[21,1,[]],null],[11,\"onchange\",[26,\"action\",[[21,2,[]]],null],null],[11,\"oninput\",[26,\"action\",[[21,3,[]]],null],null],[10,\"type\",\"range\"],[8],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"progress-bar__fg\"],[11,\"style\",[27,[\"width:\",[20,\"percent\"],\";\"]]],[8],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/web-embed-app/components/ProgressBar" } };

var __extends$4 = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var SongPlayer = /** @class */function (_super) {
    __extends$4(SongPlayer, _super);
    function SongPlayer(options) {
        var _this = _super.call(this, options) || this;
        _this.lockupMetrics = {
            targetType: 'lockup',
            actionType: _this.args.signedIn ? 'play' : 'preview'
        };
        return _this;
    }
    Object.defineProperty(SongPlayer.prototype, "displayLine1", {
        get: function get$$1() {
            var _a = this.args,
                currentMediaItem = _a.currentMediaItem,
                attributes = _a.content.attributes;
            if (currentMediaItem) {
                return currentMediaItem.title;
            } else {
                return attributes.name;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SongPlayer.prototype, "displayLine2", {
        get: function get$$1() {
            var _a = this.args,
                currentMediaItem = _a.currentMediaItem,
                attributes = _a.content.attributes;
            if (currentMediaItem) {
                return currentMediaItem.artistName + " \u2014 " + attributes.name;
            } else {
                return attributes.artistName || attributes.curatorName;
            }
        },
        enumerable: true,
        configurable: true
    });
    __decorate$2([tracked('args'), __metadata$2("design:type", String), __metadata$2("design:paramtypes", [])], SongPlayer.prototype, "displayLine1", null);
    __decorate$2([tracked('args'), __metadata$2("design:type", String), __metadata$2("design:paramtypes", [])], SongPlayer.prototype, "displayLine2", null);
    return SongPlayer;
}(Component);

var __ui_components_SongPlayer_template__ = { "id": "qhCnbjfe", "block": "{\"symbols\":[\"@content\",\"@addSongToLibrary\",\"@displayShare\",\"@close\",\"@signedIn\",\"@copyToClipboard\",\"@displayUpsell\",\"@upsell\",\"@login\",\"@openURL\",\"@currentMediaItem\",\"@canSupportDRM\",\"@showLogoutModal\",\"@isEnded\",\"@isPaused\",\"@isPlaying\",\"@isWaiting\",\"@isInProgress\",\"@isResting\",\"@sendMetricsClickEvent\",\"@togglePlay\",\"@selection\",\"@disableExplicit\",\"@isSingleItem\",\"@isPlayingDuringSeek\",\"@hasNotPlayed\",\"@currentTime\",\"@formattedTime\",\"@duration\",\"@progress\",\"@formattedDuration\",\"@timeRemainingMode\",\"@play\",\"@pause\",\"@next\",\"@scrub\",\"@seeking\",\"@toggleTimeFormat\",\"@share\"],\"statements\":[[6,\"div\"],[11,\"class\",[27,[\"song \",[26,\"if\",[[21,19,[]],\"resting\"],null],\" \",[26,\"if\",[[21,18,[]],\"in-progress\"],null],\" \",[26,\"if\",[[21,17,[]],\"buffering\"],null],\" \",[26,\"if\",[[21,16,[]],\"playing\"],null],\" \",[26,\"if\",[[21,15,[]],\"paused\"],null],\" \",[26,\"if\",[[21,14,[]],\"ended\"],null]]]],[8],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"song__heading\"],[8],[0,\"\\n    \"],[6,\"button\"],[10,\"class\",\"song__heading__logo\"],[11,\"aria-label\",[26,\"t\",[\"WebPlayer.AppleMusic\"],null],null],[11,\"onclick\",[26,\"action\",[[21,10,[]],[26,\"or\",[[21,11,[\"attributes\",\"url\"]],[21,1,[\"attributes\",\"url\"]]],null],\"logo\"],null],null],[8],[0,\"\\n      \"],[6,\"span\"],[10,\"class\",\"logo\"],[8],[9],[0,\"\\n    \"],[9],[0,\"\\n\"],[4,\"if\",[[21,5,[]]],null,{\"statements\":[[0,\"      \"],[6,\"button\"],[10,\"class\",\"song__heading__auth\"],[11,\"aria-label\",[26,\"t\",[\"WebPlayer.SignedIn.CTA\"],null],null],[11,\"onclick\",[26,\"action\",[[21,13,[]]],null],null],[8],[0,\"\\n        \"],[6,\"span\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n      \"],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[4,\"if\",[[21,12,[]]],null,{\"statements\":[[0,\"      \"],[6,\"button\"],[10,\"class\",\"song__heading__auth\"],[11,\"onclick\",[26,\"action\",[[21,9,[]],false],null],null],[8],[0,\"\\n        \"],[1,[26,\"t\",[\"WebPlayer.SignInButton\"],null],false],[0,\"\\n      \"],[9],[0,\"\\n    \"]],\"parameters\":[]},null]],\"parameters\":[]}],[0,\"  \"],[9],[0,\"\\n\\n  \"],[6,\"div\"],[10,\"class\",\"song__body\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"song__artwork\"],[11,\"onclick\",[26,\"action\",[[21,20,[]],[22,[\"lockupMetrics\"]]],null],null],[8],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"artwork-container\"],[10,\"role\",\"button\"],[11,\"aria-label\",[26,\"t\",[\"WebPlayer.PlayButton\"],null],null],[11,\"onclick\",[26,\"action\",[[21,21,[]]],null],null],[8],[0,\"\\n        \"],[6,\"img\"],[10,\"class\",\"artwork\"],[11,\"src\",[26,\"artwork\",[[21,1,[\"attributes\",\"artwork\"]]],null],null],[11,\"style\",[27,[\"background:#\",[21,1,[\"attributes\",\"artwork\",\"bgColor\"]]]]],[10,\"role\",\"presentation\"],[8],[9],[0,\"\\n        \"],[6,\"img\"],[10,\"class\",\"artwork shadow\"],[11,\"src\",[26,\"artwork\",[[21,1,[\"attributes\",\"artwork\"]]],null],null],[10,\"role\",\"presentation\"],[8],[9],[0,\"\\n      \"],[9],[0,\"\\n\"],[4,\"if\",[[21,1,[\"relationships\",\"tracks\",\"data\"]]],null,{\"statements\":[[0,\"        \"],[6,\"div\"],[10,\"class\",\"song__count\"],[8],[0,\"\\n\"],[4,\"if\",[[21,1,[\"attributes\",\"trackCount\"]]],null,{\"statements\":[[0,\"            \"],[1,[26,\"t\",[\"WebPlayer.Info.TotalTime.Songs\"],[[\"_pluralize\",\"count\"],[[21,1,[\"attributes\",\"trackCount\"]],[21,1,[\"attributes\",\"trackCount\"]]]]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"            \"],[1,[26,\"t\",[\"WebPlayer.Info.TotalTime.Songs\"],[[\"_pluralize\",\"count\"],[[21,1,[\"relationships\",\"tracks\",\"data\",\"length\"]],[21,1,[\"relationships\",\"tracks\",\"data\",\"length\"]]]]],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"        \"],[9],[0,\"\\n\"],[4,\"if\",[[21,1,[\"attributes\",\"description\"]]],null,{\"statements\":[[0,\"          \"],[6,\"p\"],[10,\"class\",\"description\"],[8],[0,\"\\n\"],[4,\"if\",[[21,1,[\"attributes\",\"description\",\"short\"]]],null,{\"statements\":[[0,\"            \"],[1,[21,1,[\"attributes\",\"description\",\"short\"]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"            \"],[1,[21,1,[\"attributes\",\"description\",\"standard\"]],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"          \"],[9],[0,\"\\n\"]],\"parameters\":[]},null]],\"parameters\":[]},null],[0,\"    \"],[9],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"song__lcd\"],[8],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"song__info\"],[8],[0,\"\\n\"],[4,\"if\",[[21,11,[]]],null,{\"statements\":[[0,\"\\n\"],[0,\"          \"],[6,\"div\"],[10,\"class\",\"song__info__name name-container\"],[11,\"onclick\",[26,\"action\",[[21,10,[]],[21,1,[\"attributes\",\"url\"]],\"track\"],null],null],[8],[0,\"\\n            \"],[6,\"span\"],[10,\"class\",\"name\"],[8],[1,[20,\"displayLine1\"],false],[9],[0,\"\\n            \"],[6,\"span\"],[11,\"class\",[27,[\"badge \",[21,11,[\"contentRating\"]]]]],[8],[9],[0,\"\\n          \"],[9],[0,\"\\n\"],[0,\"          \"],[6,\"div\"],[10,\"class\",\"song__info__sub\"],[11,\"title\",[27,[[20,\"displayLine2\"]]]],[11,\"onclick\",[26,\"action\",[[21,10,[]],[21,1,[\"attributes\",\"url\"]],\"artistAlbum\"],null],null],[8],[0,\"\\n            \"],[6,\"span\"],[8],[1,[20,\"displayLine2\"],false],[9],[0,\"\\n          \"],[9],[0,\"\\n\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"\\n\"],[0,\"          \"],[6,\"div\"],[10,\"class\",\"song__info__name name-container\"],[11,\"onclick\",[26,\"action\",[[21,10,[]],[21,1,[\"attributes\",\"url\"]],\"album/playlist\"],null],null],[8],[0,\"\\n            \"],[6,\"span\"],[10,\"class\",\"name\"],[8],[1,[20,\"displayLine1\"],false],[9],[0,\"\\n            \"],[6,\"span\"],[11,\"class\",[27,[\"badge \",[21,1,[\"attributes\",\"contentRating\"]]]]],[8],[9],[0,\"\\n          \"],[9],[0,\"\\n\"],[0,\"          \"],[6,\"div\"],[10,\"class\",\"song__info__sub\"],[11,\"title\",[27,[[20,\"displayLine2\"]]]],[8],[0,\"\\n            \"],[6,\"span\"],[8],[1,[20,\"displayLine2\"],false],[9],[0,\"\\n          \"],[9],[0,\"\\n\"]],\"parameters\":[]}],[0,\"      \"],[9],[0,\"\\n\\n      \"],[6,\"div\"],[10,\"class\",\"song__controls\"],[8],[0,\"\\n        \"],[5,\"TransportControl\",[],[[\"@content\",\"@selection\",\"@signedIn\",\"@disableExplicit\",\"@isSingleItem\",\"@isResting\",\"@isPlaying\",\"@isPlayingDuringSeek\",\"@isEnded\",\"@isWaiting\",\"@hasNotPlayed\",\"@currentTime\",\"@formattedTime\",\"@duration\",\"@progress\",\"@formattedDuration\",\"@timeRemainingMode\",\"@play\",\"@pause\",\"@next\",\"@scrub\",\"@seeking\",\"@toggleTimeFormat\",\"@sendMetricsClickEvent\"],[[21,1,[]],[21,22,[]],[21,5,[]],[21,23,[]],[21,24,[]],[21,19,[]],[21,16,[]],[21,25,[]],[21,14,[]],[21,17,[]],[21,26,[]],[21,27,[]],[21,28,[]],[21,29,[]],[21,30,[]],[21,31,[]],[21,32,[]],[26,\"action\",[[21,33,[]]],null],[26,\"action\",[[21,34,[]]],null],[26,\"action\",[[21,35,[]]],null],[26,\"action\",[[21,36,[]]],null],[26,\"action\",[[21,37,[]]],null],[26,\"action\",[[21,38,[]]],null],[26,\"action\",[[21,20,[]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\\n        \"],[6,\"button\"],[10,\"class\",\"song__share\"],[11,\"aria-label\",[26,\"t\",[\"WebPlayer.Share.More\"],null],null],[11,\"onclick\",[26,\"action\",[[21,39,[]]],null],null],[8],[0,\"\\n          \"],[6,\"span\"],[10,\"class\",\"more\"],[8],[9],[0,\"\\n        \"],[9],[0,\"\\n      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n\\n  \"],[9],[0,\"\\n\"],[9],[0,\"\\n\\n\"],[4,\"if\",[[21,24,[]]],null,{\"statements\":[[6,\"div\"],[11,\"class\",[27,[\"song-modal song-modal--share \",[26,\"if\",[[21,3,[]],\"show\",\"hide\"],null]]]],[8],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"song-modal__overlay\"],[11,\"onclick\",[26,\"action\",[[21,4,[]],false],null],null],[8],[9],[0,\"\\n  \"],[6,\"button\"],[10,\"class\",\"song-modal__close\"],[11,\"onclick\",[26,\"action\",[[21,4,[]],false],null],null],[8],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"song-modal__bg\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"song-modal__content\"],[8],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"song-modal__buttons\"],[8],[0,\"\\n        \"],[6,\"input\"],[10,\"id\",\"copy-to-clipboard\"],[10,\"readonly\",\"\"],[10,\"type\",\"text\"],[8],[9],[0,\"\\n\"],[4,\"if\",[[21,5,[]]],null,{\"statements\":[[0,\"          \"],[6,\"button\"],[10,\"class\",\"button add\"],[11,\"onclick\",[26,\"action\",[[21,2,[]],\"addSongToLibrary\",[21,1,[]]],null],null],[8],[0,\"\\n            \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n            \"],[6,\"div\"],[8],[1,[26,\"t\",[\"WebPlayer.Share.AddToLibrary\"],null],false],[9],[0,\"\\n          \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"        \"],[6,\"button\"],[10,\"class\",\"button link\"],[11,\"onclick\",[26,\"action\",[[21,6,[]],[21,1,[\"attributes\",\"url\"]],false,\"copyLinkToSong\"],null],null],[8],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n          \"],[6,\"div\"],[8],[1,[26,\"t\",[\"WebPlayer.Share.CopyLink\"],null],false],[9],[0,\"\\n        \"],[9],[0,\"\\n        \"],[6,\"button\"],[10,\"class\",\"button embed\"],[11,\"onclick\",[26,\"action\",[[21,6,[]],[21,1,[\"attributes\",\"url\"]],true,\"copySongEmbedCode\"],null],null],[8],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n          \"],[6,\"div\"],[8],[1,[26,\"t\",[\"WebPlayer.Share.Song.Embed\"],null],false],[9],[0,\"\\n        \"],[9],[0,\"\\n      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n  \"],[9],[0,\"\\n\\n  \"],[6,\"a\"],[10,\"class\",\"song-modal__legal\"],[10,\"href\",\"https://support.apple.com/kb/HT208364\"],[10,\"target\",\"_blank\"],[8],[1,[26,\"t\",[\"WebPlayer.AboutWebPlayerAndPrivacy\"],null],false],[9],[0,\"\\n\"],[9],[0,\"\\n\\n\"],[6,\"div\"],[11,\"class\",[27,[\"song-modal song-modal--upsell \",[26,\"if\",[[21,7,[]],\"show\",\"hide\"],null]]]],[8],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"song-modal__overlay\"],[11,\"onclick\",[26,\"action\",[[21,4,[]],true],null],null],[8],[9],[0,\"\\n  \"],[6,\"button\"],[10,\"class\",\"song-modal__close\"],[11,\"onclick\",[26,\"action\",[[21,4,[]],true],null],null],[8],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"song-modal__bg\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"song-modal__content\"],[8],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"song-modal__logo\"],[8],[9],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"song-modal__copy\"],[8],[1,[26,\"t\",[\"WebPlayer.Upsell.Header\"],null],false],[9],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"song-modal__ctas\"],[8],[0,\"\\n        \"],[6,\"button\"],[10,\"class\",\"cta\"],[11,\"onclick\",[26,\"action\",[[21,8,[]],true],null],null],[8],[1,[26,\"t\",[\"WebPlayer.Upsell.CTA\"],null],false],[9],[0,\"\\n        \"],[6,\"button\"],[10,\"class\",\"login\"],[11,\"onclick\",[26,\"action\",[[21,9,[]],true],null],null],[8],[1,[26,\"t\",[\"WebPlayer.SignInButton\"],null],false],[9],[0,\"\\n      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n  \"],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"parameters\":[]},null]],\"hasEval\":false}", "meta": { "specifier": "template:/web-embed-app/components/SongPlayer" } };

var __extends$5 = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$3 = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var TOAST_ANIMATION_DURATION = 4500;
var TOAST_VISIBLE_TIMEOUT = 3000;
var TOAST_TYPES = {
    'add': {
        'key': 'WebPlayer.Share.Song.Library.Confirmation',
        'class': 'add'
    },
    'add-album': {
        'key': 'WebPlayer.Share.Album.Library.Confirmation',
        'class': 'add-playlist'
    },
    'add-playlist': {
        'key': 'WebPlayer.Share.Playlist.Library.Confirmation',
        'class': 'add-playlist'
    },
    'link': {
        'key': 'WebPlayer.Share.Song.CopyLink.Confirmation',
        'class': 'link'
    },
    'link-playlist': {
        'key': 'WebPlayer.Share.Song.CopyLink.Confirmation',
        'class': 'link-playlist'
    },
    'embed': {
        'key': 'WebPlayer.Share.Song.Embed.Confirmation',
        'class': 'embed'
    },
    'embed-playlist': {
        'key': 'WebPlayer.Share.Song.Embed.Confirmation',
        'class': 'embed-playlist'
    }
};
var Toast = /** @class */function (_super) {
    __extends$5(Toast, _super);
    function Toast() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Toast.prototype, "toastString", {
        get: function get$$1() {
            if (!this.args.toastType) {
                return null;
            }
            var toastString = TOAST_TYPES[this.args.toastType].key;
            return t(toastString);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Toast.prototype, "toastClass", {
        get: function get$$1() {
            if (!this.args.toastType) {
                return null;
            }
            return TOAST_TYPES[this.args.toastType].class || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Toast.prototype, "shouldAnimateToast", {
        get: function get$$1() {
            var _this = this;
            if (this.args.displayToast) {
                // add fadeout class to the element. 
                setTimeout(function () {
                    var toast = document.querySelector('.toast');
                    toast.classList.add('fade-out');
                    return true;
                }, TOAST_VISIBLE_TIMEOUT);
                // Animation is complete. Bubble up action
                setTimeout(function () {
                    _this.args.toastAnimationComplete();
                    return false;
                }, TOAST_ANIMATION_DURATION);
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Toast.prototype.closeToast = function () {
        this.args.toastAnimationComplete();
    };
    __decorate$3([tracked('args'), __metadata$3("design:type", String), __metadata$3("design:paramtypes", [])], Toast.prototype, "toastString", null);
    __decorate$3([tracked('args'), __metadata$3("design:type", String), __metadata$3("design:paramtypes", [])], Toast.prototype, "toastClass", null);
    __decorate$3([tracked('args'), __metadata$3("design:type", Boolean), __metadata$3("design:paramtypes", [])], Toast.prototype, "shouldAnimateToast", null);
    return Toast;
}(Component);

var __ui_components_Toast_template__ = { "id": "ehs8h2Es", "block": "{\"symbols\":[\"@displayToast\"],\"statements\":[[0,\"\\n\"],[6,\"div\"],[11,\"class\",[27,[\"toast \",[26,\"if\",[[21,1,[]],\"show\",\"hide\"],null],\" \",[26,\"if\",[[22,[\"shouldAnimateToast\"]],\"fade-out\"],null]]]],[10,\"role\",\"alert\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"wrapper\"],[11,\"onclick\",[26,\"action\",[[22,[\"closeToast\"]]],null],null],[8],[0,\"\\n        \"],[6,\"div\"],[11,\"class\",[27,[\"icon \",[20,\"toastClass\"]]]],[8],[9],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"text\"],[8],[1,[20,\"toastString\"],false],[9],[0,\"\\n    \"],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/web-embed-app/components/Toast" } };

// https://github.com/jrop/moment-from-now
// 146097 days in 400 years (moment.js:daysToMonths()):
var DAYS_PER_MONTH = 146097 / 400 / 12;
var LOC_KEY_ROOT = 'WebPlayer.Ago.';
function first(arr, func) {
    for (var i = 0; i < arr.length; ++i) {
        if (func(arr[i])) {
            return arr[i];
        }
    }
}
function thresh(t$$1, val) {
    val = Math.round(val);
    return val < t$$1 ? val : 0;
}
function humanize(duration) {
    var ago = duration < 0;
    duration = Math.abs(duration);
    duration = [{ n: thresh(45, duration / 1000), units: 'Seconds' }, { n: thresh(45, duration / (60 * 1000)), units: 'Minutes' }, { n: thresh(22, duration / (60 * 60 * 1000)), units: 'Hours' }, { n: thresh(26, duration / (24 * 60 * 60 * 1000)), units: 'Days' }, { n: thresh(11, duration / (DAYS_PER_MONTH * 24 * 60 * 60 * 1000)), units: 'Months' }, { n: thresh(Number.MAX_VALUE, duration / (365 * 24 * 60 * 60 * 1000)), units: 'Years' }, { n: 'now', units: '' }];
    duration = first(duration, function (part) {
        return part.n !== 0;
    });
    ago = ago && duration.n != 'now';
    var agoString = '';
    if (duration) {
        agoString = t("" + LOC_KEY_ROOT + duration.units, {
            count: duration.n,
            _pluralize: duration.n
        });
    } else {
        agoString = t(LOC_KEY_ROOT + "JustNow");
    }
    return agoString;
}
function fromNow(date) {
    var now = new Date().getTime();
    if (!(date instanceof Date)) {
        date = new Date(date);
    }
    return humanize(date.getTime() - now);
}

fromNow.humanize = humanize;

var __extends$6 = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$4 = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var formattedMilliseconds = MusicKit.formattedMilliseconds;
var MONTHS = {
    '01': 'January',
    '02': 'February',
    '03': 'March',
    '04': 'April',
    '05': 'May',
    '06': 'June',
    '07': 'July',
    '08': 'August',
    '09': 'September',
    '10': 'October',
    '11': 'November',
    '12': 'December'
};
var upsellImpressionSent = false;
var Tracklist = /** @class */function (_super) {
    __extends$6(Tracklist, _super);
    function Tracklist() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Tracklist.prototype, "totalDuration", {
        get: function get$$1() {
            var tracks = this.args.content.relationships.tracks.data;
            var totalMillis = tracks.reduce(function (sum, track) {
                if (track.attributes) {
                    return sum + track.attributes.durationInMillis;
                }
            }, 0);
            return formattedMilliseconds(totalMillis);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tracklist.prototype, "releaseDate", {
        get: function get$$1() {
            var date = this.args.content.attributes.releaseDate;
            return this.formatDate(date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tracklist.prototype, "isPlayingState", {
        get: function get$$1() {
            return this.args.isPlaying === true || this.args.isPlayingDuringSeek === true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tracklist.prototype, "lastUpdated", {
        get: function get$$1() {
            var date = this.args.content.attributes.lastModifiedDate;
            return fromNow(new Date(date).getTime() + 60 * 1000);
        },
        enumerable: true,
        configurable: true
    });
    Tracklist.prototype.didInsertElement = function () {
        var _this = this;
        this.handleWorkNames();
        var tracklist = document.querySelector('.tracklist');
        var topGradient = document.querySelector('.top .gradient');
        var topGradientClass = "top-gradient-visible";
        // TODO: This should probably be throttled by requestAnimationFrame
        tracklist.addEventListener('scroll', function (event) {
            var eventTarget = event.target;
            var clientHeight = eventTarget.clientHeight;
            var scrollTop = eventTarget.scrollTop;
            if (scrollTop > 0) {
                tracklist.classList.add(topGradientClass);
            } else {
                tracklist.classList.remove(topGradientClass);
            }
            var upsellButtons = document.querySelector('.tracklist__upsell__buttons');
            if (upsellButtons && !upsellImpressionSent && upsellButtons.offsetTop <= clientHeight + scrollTop) {
                _this.args.sendUpsellImpressionEvent({
                    id: 'WebPlayer.Upsell.CTA',
                    component: 'button',
                    name: 'startTrial'
                });
                _this.args.sendUpsellImpressionEvent({
                    id: 'signIn',
                    component: 'button',
                    name: 'signIn'
                });
                upsellImpressionSent = true;
            }
        });
    };
    Tracklist.prototype.handleWorkNames = function () {
        var workNames = document.querySelectorAll('[data-workname]');
        workNames.forEach(function (element, index) {
            var currentVal = element.dataset.workname;
            var prevVal = index > 0 ? workNames[index - 1].dataset.workname : null;
            if (currentVal === prevVal) {
                element.parentNode.removeChild(element);
            }
        });
    };
    // 2014-07-15 => July 15, 2014
    Tracklist.prototype.formatDate = function (date) {
        var _a = date.split('-'),
            year = _a[0],
            month = _a[1],
            day = _a[2];
        if (!month && !day) {
            return year;
        } else {
            var stringifiedMonth = MONTHS[month];
            var stringifiedDay = day[0] === '0' ? day.substring(1) : day;
            return stringifiedMonth + " " + stringifiedDay + ", " + year;
        }
    };
    __decorate$4([tracked('args'), __metadata$4("design:type", Object), __metadata$4("design:paramtypes", [])], Tracklist.prototype, "totalDuration", null);
    __decorate$4([tracked('args'), __metadata$4("design:type", String), __metadata$4("design:paramtypes", [])], Tracklist.prototype, "releaseDate", null);
    __decorate$4([tracked('args'), __metadata$4("design:type", Boolean), __metadata$4("design:paramtypes", [])], Tracklist.prototype, "isPlayingState", null);
    __decorate$4([tracked('args'), __metadata$4("design:type", String), __metadata$4("design:paramtypes", [])], Tracklist.prototype, "lastUpdated", null);
    return Tracklist;
}(Component);

var __ui_components_Tracklist_template__ = { "id": "GQ06gCus", "block": "{\"symbols\":[\"track\",\"index\",\"track\",\"index\",\"@selection\",\"@copyToClipboard\",\"@addSongToLibrary\",\"@upsell\",\"@login\",\"@content\",\"@disableExplicit\",\"@select\",\"@currentMediaItem\",\"@isPlaylist\",\"@canSupportDRM\",\"@signedIn\",\"@displayShare\",\"@close\",\"@addTracklistToLibrary\",\"@openPopup\",\"@displayUpsell\"],\"statements\":[[6,\"div\"],[11,\"class\",[27,[\"tracklist \",[26,\"if\",[[21,14,[]],\"playlist\"],null]]]],[8],[0,\"\\n\\n\"],[4,\"if\",[[26,\"and\",[[26,\"eq\",[[21,10,[\"type\"]],\"playlists\"],null],[21,10,[\"attributes\",\"description\"]]],null]],null,{\"statements\":[[0,\"    \"],[6,\"div\"],[10,\"class\",\"tracklist__editorial\"],[8],[0,\"\\n      \"],[6,\"p\"],[10,\"class\",\"notes\"],[8],[0,\"\\n\"],[4,\"if\",[[21,10,[\"attributes\",\"description\",\"short\"]]],null,{\"statements\":[[0,\"        \"],[1,[21,10,[\"attributes\",\"description\",\"short\"]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"        \"],[1,[21,10,[\"attributes\",\"description\",\"standard\"]],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"    \"],[6,\"div\"],[10,\"class\",\"tracklist__border\"],[8],[9],[0,\"\\n\"]],\"parameters\":[]}],[0,\"  \"],[6,\"ul\"],[10,\"class\",\"tracklist__tracks\"],[8],[0,\"\\n\"],[4,\"if\",[[26,\"eq\",[[21,10,[\"type\"]],\"playlists\"],null]],null,{\"statements\":[[4,\"each\",[[21,10,[\"relationships\",\"tracks\",\"data\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"      \"],[6,\"li\"],[11,\"class\",[27,[\"tracklist__track large \",[26,\"if\",[[26,\"or\",[[26,\"and\",[[21,11,[]],[26,\"eq\",[[21,3,[\"attributes\",\"contentRating\"]],\"explicit\"],null]],null],[26,\"and\",[[26,\"not\",[[21,3,[\"attributes\",\"playParams\"]]],null],[26,\"not\",[[21,3,[\"attributes\",\"previews\",\"0\",\"url\"]]],null]],null]],null],\"disabled\"],null]]]],[11,\"onclick\",[26,\"action\",[[21,12,[]],[21,3,[]]],null],null],[8],[0,\"\\n        \"],[6,\"span\"],[10,\"class\",\"tracklist__track__artwork\"],[8],[0,\"\\n          \"],[6,\"img\"],[10,\"class\",\"artwork\"],[11,\"src\",[27,[[26,\"artwork\",[[21,3,[\"attributes\",\"artwork\"]]],null]]]],[10,\"alt\",\"artwork\"],[11,\"style\",[27,[\"background:#\",[21,3,[\"attributes\",\"artwork\",\"bgColor\"]]]]],[8],[9],[0,\"\\n\"],[4,\"if\",[[26,\"eq\",[[21,13,[\"id\"]],[21,3,[\"id\"]]],null]],null,{\"statements\":[[0,\"            \"],[6,\"div\"],[10,\"class\",\"artwork-overlay\"],[8],[0,\"\\n              \"],[5,\"PlaybackBars\",[],[[\"@isPlaying\"],[[20,\"isPlayingState\"]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n            \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"        \"],[9],[0,\"\\n        \"],[6,\"span\"],[10,\"class\",\"tracklist__track__info\"],[8],[0,\"\\n          \"],[6,\"span\"],[10,\"class\",\"column-flex\"],[8],[0,\"\\n            \"],[6,\"span\"],[10,\"class\",\"tracklist__track__name name-container\"],[8],[0,\"\\n              \"],[6,\"span\"],[10,\"class\",\"name\"],[8],[1,[21,3,[\"attributes\",\"name\"]],false],[9],[0,\"\\n              \"],[6,\"span\"],[11,\"class\",[27,[\"badge \",[21,3,[\"attributes\",\"contentRating\"]]]]],[8],[9],[0,\"\\n            \"],[9],[0,\"\\n            \"],[6,\"span\"],[10,\"class\",\"tracklist__track__sub\"],[8],[1,[21,3,[\"attributes\",\"artistName\"]],false],[9],[0,\"\\n          \"],[9],[0,\"\\n          \"],[6,\"button\"],[10,\"class\",\"tracklist__track__add\"],[11,\"aria-label\",[26,\"t\",[\"WebPlayer.Share.AddToLibrary\"],null],null],[11,\"onclick\",[26,\"action\",[[21,7,[]],\"add\",[21,3,[]]],null],null],[8],[0,\"\\n            \"],[6,\"span\"],[10,\"class\",\"add\"],[8],[9],[0,\"\\n          \"],[9],[0,\"\\n        \"],[9],[0,\"\\n      \"],[9],[0,\"\\n\"]],\"parameters\":[3,4]},null],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"\\n\"],[4,\"each\",[[21,10,[\"relationships\",\"tracks\",\"data\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"\\n\"],[4,\"if\",[[26,\"and\",[[21,1,[\"attributes\",\"workName\"]],[21,1,[\"attributes\",\"movementNumber\"]]],null]],null,{\"statements\":[[4,\"if\",[[26,\"eq\",[[21,1,[\"attributes\",\"movementNumber\"]],1],null]],null,{\"statements\":[[0,\"          \"],[6,\"div\"],[10,\"class\",\"tracklist__workname\"],[8],[1,[21,1,[\"attributes\",\"workName\"]],false],[9],[0,\"\\n\"]],\"parameters\":[]},null]],\"parameters\":[]},{\"statements\":[[4,\"if\",[[21,1,[\"attributes\",\"workName\"]]],null,{\"statements\":[[0,\"        \"],[6,\"div\"],[10,\"class\",\"tracklist__workname\"],[11,\"data-workname\",[27,[[21,1,[\"attributes\",\"workName\"]]]]],[8],[1,[21,1,[\"attributes\",\"workName\"]],false],[9],[0,\"\\n      \"]],\"parameters\":[]},null]],\"parameters\":[]}],[0,\"      \"],[6,\"li\"],[11,\"class\",[27,[\"tracklist__track \",[26,\"if\",[[26,\"or\",[[26,\"and\",[[21,11,[]],[26,\"eq\",[[21,1,[\"attributes\",\"contentRating\"]],\"explicit\"],null]],null],[26,\"and\",[[26,\"not\",[[21,1,[\"attributes\",\"playParams\"]]],null],[26,\"not\",[[21,1,[\"attributes\",\"previews\",\"0\",\"url\"]]],null]],null]],null],\"disabled\"],null]]]],[11,\"onclick\",[26,\"action\",[[21,12,[]],[21,1,[]]],null],null],[8],[0,\"\\n\"],[4,\"if\",[[26,\"eq\",[[21,13,[\"id\"]],[21,1,[\"id\"]]],null]],null,{\"statements\":[[0,\"          \"],[5,\"PlaybackBars\",[],[[\"@isPlaying\"],[[20,\"isPlayingState\"]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"          \"],[6,\"span\"],[10,\"class\",\"tracklist__track__num\"],[8],[0,\"\\n\"],[4,\"if\",[[21,1,[\"attributes\"]]],null,{\"statements\":[[0,\"              \"],[1,[21,1,[\"attributes\",\"trackNumber\"]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"              \"],[1,[26,\"counter\",[[21,2,[]]],null],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"          \"],[9],[0,\"\\n\"]],\"parameters\":[]}],[0,\"\\n        \"],[6,\"span\"],[10,\"class\",\"tracklist__track__info\"],[8],[0,\"\\n          \"],[6,\"span\"],[10,\"class\",\"tracklist__track__name name-container\"],[8],[0,\"\\n            \"],[6,\"span\"],[10,\"class\",\"name\"],[8],[0,\"\\n\"],[4,\"if\",[[21,1,[\"attributes\"]]],null,{\"statements\":[[4,\"if\",[[26,\"and\",[[21,1,[\"attributes\",\"workName\"]],[21,1,[\"attributes\",\"movementName\"]]],null]],null,{\"statements\":[[0,\"                  \"],[1,[21,1,[\"attributes\",\"movementName\"]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[4,\"if\",[[21,1,[\"attributes\",\"workName\"]]],null,{\"statements\":[[0,\"                  \"],[1,[26,\"movement\",[[21,1,[\"attributes\",\"name\"]],[21,1,[\"attributes\",\"workName\"]]],null],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"                  \"],[1,[21,1,[\"attributes\",\"name\"]],false],[0,\"\\n                \"]],\"parameters\":[]}]],\"parameters\":[]}]],\"parameters\":[]},{\"statements\":[[0,\"                \"],[1,[26,\"t\",[\"WebPlayer.Error.ItemNotAvailable\"],null],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"            \"],[9],[0,\"\\n            \"],[6,\"span\"],[11,\"class\",[27,[\"badge \",[21,1,[\"attributes\",\"contentRating\"]]]]],[8],[9],[0,\"\\n          \"],[9],[0,\"\\n          \"],[6,\"button\"],[10,\"class\",\"tracklist__track__add\"],[11,\"aria-label\",[26,\"t\",[\"WebPlayer.Share.AddToLibrary\"],null],null],[11,\"onclick\",[26,\"action\",[[21,7,[]],\"add\",[21,1,[]]],null],null],[8],[0,\"\\n            \"],[6,\"span\"],[10,\"class\",\"add\"],[8],[9],[0,\"\\n          \"],[9],[0,\"\\n        \"],[9],[0,\"\\n      \"],[9],[0,\"\\n\"]],\"parameters\":[1,2]},null]],\"parameters\":[]}],[0,\"  \"],[9],[0,\"\\n\\n  \"],[6,\"div\"],[10,\"class\",\"tracklist__footer\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"tracklist__footer__duration\"],[8],[0,\"\\n\"],[4,\"if\",[[21,10,[\"attributes\",\"trackCount\"]]],null,{\"statements\":[[0,\"        \"],[1,[26,\"t\",[\"WebPlayer.Info.TotalTime.Songs\"],[[\"_pluralize\",\"count\"],[[21,10,[\"attributes\",\"trackCount\"]],[21,10,[\"attributes\",\"trackCount\"]]]]],false],[0,\",\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"        \"],[1,[26,\"t\",[\"WebPlayer.Info.TotalTime.Songs\"],[[\"_pluralize\",\"count\"],[[21,10,[\"relationships\",\"tracks\",\"data\",\"length\"]],[21,10,[\"relationships\",\"tracks\",\"data\",\"length\"]]]]],false],[0,\",\\n\"]],\"parameters\":[]}],[0,\"\\n\"],[4,\"if\",[[26,\"and\",[[26,\"gt\",[[22,[\"totalDuration\",\"hours\"]],0],null],[26,\"gt\",[[22,[\"totalDuration\",\"minutes\"]],0],null]],null]],null,{\"statements\":[[0,\"        \"],[1,[26,\"t\",[\"WebPlayer.Info.TotalTime.Hours\"],[[\"count\",\"_pluralize\"],[[22,[\"totalDuration\",\"hours\"]],[22,[\"totalDuration\",\"hours\"]]]]],false],[0,\", \"],[1,[26,\"t\",[\"WebPlayer.Info.TotalTime.Minutes\"],[[\"count\",\"_pluralize\"],[[22,[\"totalDuration\",\"minutes\"]],[22,[\"totalDuration\",\"minutes\"]]]]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[4,\"if\",[[26,\"gt\",[[22,[\"totalDuration\",\"hours\"]],0],null]],null,{\"statements\":[[0,\"        \"],[1,[26,\"t\",[\"WebPlayer.Info.TotalTime.Hours\"],[[\"count\",\"_pluralize\"],[[22,[\"totalDuration\",\"hours\"]],[22,[\"totalDuration\",\"hours\"]]]]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"        \"],[1,[26,\"t\",[\"WebPlayer.Info.TotalTime.Minutes\"],[[\"count\",\"_pluralize\"],[[22,[\"totalDuration\",\"minutes\"]],[22,[\"totalDuration\",\"minutes\"]]]]],false],[0,\"\\n      \"]],\"parameters\":[]}]],\"parameters\":[]}],[0,\"    \"],[9],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"tracklist__footer__release\"],[8],[0,\"\\n\"],[4,\"if\",[[21,10,[\"attributes\",\"releaseDate\"]]],null,{\"statements\":[[0,\"        \"],[1,[26,\"t\",[\"WebPlayer.Info.ReleasedDate\"],[[\"date\"],[[22,[\"releaseDate\"]]]]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[4,\"if\",[[21,10,[\"attributes\",\"lastModifiedDate\"]]],null,{\"statements\":[[0,\"        \"],[1,[26,\"t\",[\"WebPlayer.Info.Released.UpdatedDay\"],[[\"day\"],[[22,[\"lastUpdated\"]]]]],false],[0,\"\\n      \"]],\"parameters\":[]},null]],\"parameters\":[]}],[0,\"    \"],[9],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"tracklist__footer__copyright\"],[8],[0,\"\\n      \"],[1,[21,10,[\"attributes\",\"copyright\"]],false],[0,\"\\n    \"],[9],[0,\"\\n  \"],[9],[0,\"\\n\\n\"],[4,\"unless\",[[26,\"or\",[[21,16,[]],[26,\"not\",[[21,15,[]]],null]],null]],null,{\"statements\":[[0,\"  \"],[6,\"div\"],[10,\"class\",\"tracklist__upsell\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"tracklist__upsell__logo\"],[8],[9],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"tracklist__upsell__copy\"],[8],[0,\"\\n      \"],[1,[26,\"t\",[\"WebPlayer.Upsell.Header\"],null],false],[0,\"\\n    \"],[9],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"tracklist__upsell__buttons\"],[8],[0,\"\\n      \"],[6,\"button\"],[10,\"class\",\"cta\"],[11,\"onclick\",[26,\"action\",[[21,8,[]],false],null],null],[8],[0,\"\\n        \"],[1,[26,\"t\",[\"WebPlayer.Upsell.CTA\"],null],false],[0,\"\\n      \"],[9],[0,\"\\n      \"],[6,\"button\"],[10,\"class\",\"login\"],[11,\"onclick\",[26,\"action\",[[21,9,[]],false],null],null],[8],[0,\"\\n        \"],[1,[26,\"t\",[\"WebPlayer.SignInButton\"],null],false],[0,\"\\n      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n  \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"\\n\"],[9],[0,\"\\n\\n\"],[6,\"div\"],[10,\"class\",\"scrollhint bottom\"],[8],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"gradient\"],[8],[9],[0,\"\\n\"],[9],[0,\"\\n\\n\"],[6,\"div\"],[11,\"class\",[27,[\"tracklist-modal tracklist-modal--share \",[26,\"if\",[[21,17,[]],\"show\",\"hide\"],null]]]],[8],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__overlay\"],[11,\"onclick\",[26,\"action\",[[21,18,[]],false],null],null],[8],[9],[0,\"\\n  \"],[6,\"button\"],[10,\"class\",\"tracklist-modal__close\"],[11,\"onclick\",[26,\"action\",[[21,18,[]],false],null],null],[8],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__bg\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__content\"],[8],[0,\"\\n      \"],[6,\"input\"],[10,\"id\",\"copy-to-clipboard\"],[10,\"readonly\",\"\"],[10,\"type\",\"text\"],[8],[9],[0,\"\\n\"],[4,\"if\",[[21,5,[]]],null,{\"statements\":[[0,\"        \"],[6,\"button\"],[10,\"class\",\"button add-song\"],[11,\"onclick\",[26,\"action\",[[21,7,[]],\"addSongToLibrary\",[21,5,[]]],null],null],[8],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"text\"],[8],[1,[26,\"t\",[\"WebPlayer.Share.Song.Library\"],null],false],[9],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n        \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"      \"],[6,\"button\"],[10,\"class\",\"button add-playlist\"],[11,\"onclick\",[26,\"action\",[[21,19,[]]],null],null],[8],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"text\"],[8],[0,\"\\n\"],[4,\"if\",[[21,14,[]]],null,{\"statements\":[[0,\"            \"],[1,[26,\"t\",[\"WebPlayer.Share.Playlist.Library\"],null],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"            \"],[1,[26,\"t\",[\"WebPlayer.Share.Album.Library\"],null],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"        \"],[9],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n      \"],[9],[0,\"\\n\"],[4,\"if\",[[21,5,[]]],null,{\"statements\":[[0,\"        \"],[6,\"button\"],[10,\"class\",\"button link-song\"],[11,\"onclick\",[26,\"action\",[[21,6,[]],[21,5,[\"attributes\",\"url\"]],false,\"copyLinkToSong\"],null],null],[8],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"text\"],[8],[1,[26,\"t\",[\"WebPlayer.Share.Song.CopyLink\"],null],false],[9],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n        \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"      \"],[6,\"button\"],[10,\"class\",\"button link-album\"],[11,\"onclick\",[26,\"action\",[[21,6,[]],[21,10,[\"attributes\",\"url\"]],false,\"copyLinkToAlbum/Playlist\"],null],null],[8],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"text\"],[8],[0,\"\\n\"],[4,\"if\",[[21,14,[]]],null,{\"statements\":[[0,\"            \"],[1,[26,\"t\",[\"WebPlayer.Share.Playlist.CopyLink\"],null],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"            \"],[1,[26,\"t\",[\"WebPlayer.Share.Album.CopyLink\"],null],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"        \"],[9],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n      \"],[9],[0,\"\\n\"],[4,\"if\",[[21,5,[]]],null,{\"statements\":[[0,\"        \"],[6,\"button\"],[10,\"class\",\"button embed-song\"],[11,\"onclick\",[26,\"action\",[[21,6,[]],[21,5,[\"attributes\",\"url\"]],true,\"copySongEmbedCode\"],null],null],[8],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"text\"],[8],[1,[26,\"t\",[\"WebPlayer.Share.Song.Embed\"],null],false],[9],[0,\"\\n          \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n        \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"      \"],[6,\"button\"],[10,\"class\",\"button embed-playlist\"],[11,\"onclick\",[26,\"action\",[[21,6,[]],[21,10,[\"attributes\",\"url\"]],true,\"copyAlbum/PlaylistEmbedCode\"],null],null],[8],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"text\"],[8],[0,\"\\n\"],[4,\"if\",[[21,14,[]]],null,{\"statements\":[[0,\"            \"],[1,[26,\"t\",[\"WebPlayer.Share.Playlist.Embed\"],null],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"            \"],[1,[26,\"t\",[\"WebPlayer.Share.Album.Embed\"],null],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"        \"],[9],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n      \"],[9],[0,\"\\n      \"],[6,\"button\"],[10,\"class\",\"button open-popup\"],[11,\"onclick\",[26,\"action\",[[21,20,[]]],null],null],[8],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"text\"],[8],[1,[26,\"t\",[\"WebPlayer.Share.OpenInPopup\"],null],false],[9],[0,\"\\n        \"],[6,\"div\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n  \"],[9],[0,\"\\n\\n  \"],[6,\"a\"],[10,\"class\",\"tracklist-modal__legal\"],[10,\"href\",\"https://support.apple.com/kb/HT208364\"],[10,\"target\",\"_blank\"],[8],[1,[26,\"t\",[\"WebPlayer.AboutWebPlayerAndPrivacy\"],null],false],[9],[0,\"\\n\"],[9],[0,\"\\n\\n\"],[6,\"div\"],[11,\"class\",[27,[\"tracklist-modal tracklist-modal--upsell \",[26,\"if\",[[21,21,[]],\"show\",\"hide\"],null]]]],[8],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__overlay\"],[11,\"onclick\",[26,\"action\",[[21,18,[]],true],null],null],[8],[9],[0,\"\\n  \"],[6,\"button\"],[10,\"class\",\"tracklist-modal__close\"],[11,\"onclick\",[26,\"action\",[[21,18,[]],true],null],null],[8],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__bg\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__content\"],[8],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__logo\"],[8],[9],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__copy\"],[8],[1,[26,\"t\",[\"WebPlayer.Upsell.Header\"],null],false],[9],[0,\"\\n      \"],[6,\"div\"],[10,\"class\",\"tracklist-modal__buttons\"],[8],[0,\"\\n        \"],[6,\"button\"],[10,\"class\",\"cta\"],[11,\"onclick\",[26,\"action\",[[21,8,[]],true],null],null],[8],[1,[26,\"t\",[\"WebPlayer.Upsell.CTA\"],null],false],[9],[0,\"\\n        \"],[6,\"button\"],[10,\"class\",\"login\"],[11,\"onclick\",[26,\"action\",[[21,9,[]],true],null],null],[8],[1,[26,\"t\",[\"WebPlayer.SignInButton\"],null],false],[9],[0,\"\\n      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n  \"],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/web-embed-app/components/Tracklist" } };

var __extends$7 = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$5 = undefined && undefined.__metadata || function (k, v) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var TransportControl = /** @class */function (_super) {
    __extends$7(TransportControl, _super);
    function TransportControl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.playButtonText = t('WebPlayer.PlayButton').toLocaleUpperCase();
        return _this;
    }
    Object.defineProperty(TransportControl.prototype, "isPlayingState", {
        get: function get$$1() {
            return this.args.isPlaying || this.args.isWaiting || this.args.isPlayingDuringSeek;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransportControl.prototype, "isUnAvailable", {
        get: function get$$1() {
            return !this.args.content.attributes.playParams;
        },
        enumerable: true,
        configurable: true
    });
    __decorate$5([tracked('args'), __metadata$5("design:type", Boolean), __metadata$5("design:paramtypes", [])], TransportControl.prototype, "isPlayingState", null);
    __decorate$5([tracked('args'), __metadata$5("design:type", Boolean), __metadata$5("design:paramtypes", [])], TransportControl.prototype, "isUnAvailable", null);
    return TransportControl;
}(Component);

var __ui_components_TransportControl_template__ = { "id": "quSBeVQ2", "block": "{\"symbols\":[\"@formattedDuration\",\"@formattedTime\",\"@next\",\"@play\",\"@pause\",\"@isSingleItem\",\"@currentTime\",\"@duration\",\"@progress\",\"@scrub\",\"@seeking\",\"@toggleTimeFormat\",\"@timeRemainingMode\",\"@hasNotPlayed\",\"@isWaiting\",\"@selection\",\"@disableExplicit\",\"@isResting\"],\"statements\":[[4,\"if\",[[21,18,[]]],null,{\"statements\":[[0,\"  \"],[6,\"div\"],[10,\"class\",\"song__resting\"],[11,\"onclick\",[26,\"action\",[[21,4,[]]],null],null],[8],[0,\"\\n\"],[4,\"if\",[[22,[\"isUnAvailable\"]]],null,{\"statements\":[[0,\"      \"],[6,\"button\"],[10,\"class\",\"song__resting__button unavailable\"],[8],[0,\"\\n\"],[4,\"if\",[[21,6,[]]],null,{\"statements\":[[0,\"          \"],[6,\"span\"],[8],[1,[26,\"t\",[\"WebPlayer.Error.SongNotReleased\"],null],false],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"          \"],[6,\"span\"],[8],[1,[26,\"t\",[\"WebPlayer.Error.AlbumNotReleased\"],null],false],[9],[0,\"\\n\"]],\"parameters\":[]}],[0,\"      \"],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"      \"],[6,\"button\"],[11,\"class\",[27,[\"song__resting__button \",[26,\"if\",[[26,\"and\",[[26,\"and\",[[21,17,[]],[26,\"eq\",[[21,16,[\"contentRating\"]],\"explicit\"],null]],null],[26,\"and\",[[26,\"not\",[[21,16,[\"attributes\",\"playParams\"]]],null],[26,\"not\",[[21,16,[\"attributes\",\"previews\",\"0\",\"url\"]]],null]],null]],null],\"disabled\"],null]]]],[8],[0,\"\\n        \"],[6,\"span\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n        \"],[6,\"span\"],[10,\"class\",\"text\"],[8],[1,[20,\"playButtonText\"],false],[9],[0,\"\\n      \"],[9],[0,\"\\n\"]],\"parameters\":[]}],[0,\"  \"],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[4,\"if\",[[26,\"and\",[[21,15,[]],[21,14,[]]],null]],null,{\"statements\":[[0,\"  \"],[6,\"div\"],[10,\"class\",\"song__buffering\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"loader\"],[8],[9],[0,\"\\n  \"],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"  \"],[6,\"div\"],[10,\"class\",\"song__transport\"],[8],[0,\"\\n    \"],[6,\"div\"],[10,\"class\",\"song__transport__control\"],[8],[0,\"\\n\"],[4,\"if\",[[22,[\"isPlayingState\"]]],null,{\"statements\":[[0,\"        \"],[6,\"button\"],[10,\"class\",\"pause\"],[11,\"onclick\",[26,\"action\",[[21,5,[]]],null],null],[8],[0,\"\\n          \"],[6,\"span\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n        \"],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"        \"],[6,\"button\"],[10,\"class\",\"play\"],[11,\"onclick\",[26,\"action\",[[21,4,[]]],null],null],[8],[0,\"\\n          \"],[6,\"span\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n        \"],[9],[0,\"\\n\"]],\"parameters\":[]}],[4,\"if\",[[26,\"not\",[[21,6,[]]],null]],null,{\"statements\":[[0,\"        \"],[6,\"button\"],[10,\"class\",\"skip\"],[11,\"onclick\",[26,\"action\",[[21,3,[]]],null],null],[8],[0,\"\\n          \"],[6,\"span\"],[10,\"class\",\"icon\"],[8],[9],[0,\"\\n        \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"    \"],[9],[0,\"\\n\\n    \"],[6,\"div\"],[10,\"class\",\"song__transport__scrub\"],[8],[0,\"\\n      \"],[5,\"ProgressBar\",[],[[\"@currentTime\",\"@duration\",\"@progress\",\"@scrub\",\"@seeking\"],[[21,7,[]],[21,8,[]],[21,9,[]],[26,\"action\",[[21,10,[]]],null],[26,\"action\",[[21,11,[]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n      \"],[6,\"span\"],[10,\"class\",\"time\"],[11,\"onclick\",[26,\"action\",[[21,12,[]]],null],null],[8],[0,\"\\n\"],[4,\"if\",[[21,13,[]]],null,{\"statements\":[[0,\"          \"],[1,[21,2,[]],false],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"          \"],[1,[21,1,[]],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n  \"],[9],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[]}]],\"hasEval\":false}", "meta": { "specifier": "template:/web-embed-app/components/TransportControl" } };

function and(_a) {
    var a = _a[0],
        b = _a[1];
    return a && b;
}

function artwork(_a) {
    var artwork = _a[0];
    var param = Object.assign({
        url: 'assets/images/fallback-artwork-daaf98e9e0d836a3fca827e4098f9883.png'
    }, artwork);
    return param.url.replace(/bb(\.[a-z]{3,})$/, 'cc$1').replace(/{[w|h]}/g, '500');
}

function counter(_a) {
    var n = _a[0];
    return n + 1;
}

function eq(_a) {
    var a = _a[0],
        b = _a[1];
    return a === b;
}

function gt(_a) {
    var a = _a[0],
        b = _a[1];
    return a > b;
}

function log(params) {
    var arg1 = params[0],
        arg2 = params[1];
    if (arg2) {
        console.log(arg1 + " : " + arg2);
    } else {
        console.log("" + arg1);
    }
    return null;
}

function movement(song) {
    var songName = song[0];
    var workName = song[1];
    return songName.includes(workName) ? songName.replace(workName + ": ", '') : songName;
}

function not(_a) {
    var a = _a[0];
    return !a;
}

function or(_a) {
    var a = _a[0],
        b = _a[1];
    return a ? a : b;
}

var moduleMap = { 'component:/web-embed-app/components/EmbedPlayer': EmbedPlayer, 'template:/web-embed-app/components/EmbedPlayer': __ui_components_EmbedPlayer_template__, 'component:/web-embed-app/components/PlaybackBars': PlaybackBars, 'template:/web-embed-app/components/PlaybackBars': __ui_components_PlaybackBars_template__, 'component:/web-embed-app/components/ProgressBar': ProgressBar, 'template:/web-embed-app/components/ProgressBar': __ui_components_ProgressBar_template__, 'component:/web-embed-app/components/SongPlayer': SongPlayer, 'template:/web-embed-app/components/SongPlayer': __ui_components_SongPlayer_template__, 'component:/web-embed-app/components/Toast': Toast, 'template:/web-embed-app/components/Toast': __ui_components_Toast_template__, 'component:/web-embed-app/components/Tracklist': Tracklist, 'template:/web-embed-app/components/Tracklist': __ui_components_Tracklist_template__, 'component:/web-embed-app/components/TransportControl': TransportControl, 'template:/web-embed-app/components/TransportControl': __ui_components_TransportControl_template__, 'helper:/web-embed-app/components/and': and, 'helper:/web-embed-app/components/artwork': artwork, 'helper:/web-embed-app/components/counter': counter, 'helper:/web-embed-app/components/eq': eq, 'helper:/web-embed-app/components/gt': gt, 'helper:/web-embed-app/components/log': log, 'helper:/web-embed-app/components/movement': movement, 'helper:/web-embed-app/components/not': not, 'helper:/web-embed-app/components/or': or, 'helper:/web-embed-app/components/t': t };

var resolverConfiguration = { "app": { "name": "web-embed-app", "rootName": "web-embed-app" }, "types": { "application": { "definitiveCollection": "main" }, "component": { "definitiveCollection": "components" }, "component-test": { "unresolvable": true }, "helper": { "definitiveCollection": "components" }, "helper-test": { "unresolvable": true }, "renderer": { "definitiveCollection": "main" }, "template": { "definitiveCollection": "components" } }, "collections": { "main": { "types": ["application", "renderer"] }, "components": { "group": "ui", "types": ["component", "component-test", "template", "helper", "helper-test"], "defaultType": "component", "privateCollections": ["utils"] }, "styles": { "group": "ui", "unresolvable": true }, "utils": { "unresolvable": true } } };

var __extends = undefined && undefined.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var App = /** @class */function (_super) {
    __extends(App, _super);
    function App() {
        var _this = this;
        var moduleRegistry = new BasicRegistry(moduleMap);
        var resolver = new Resolver(resolverConfiguration, moduleRegistry);
        var element = document.body;
        _this = _super.call(this, {
            builder: new DOMBuilder({ element: element, nextSibling: null }),
            loader: new RuntimeCompilerLoader(resolver),
            renderer: new SyncRenderer(),
            resolver: resolver,
            rootName: resolverConfiguration.app.rootName
        }) || this;
        return _this;
    }
    return App;
}(Application);

/// <reference path="../node_modules/typescript/lib/lib.dom.d.ts" />
/// <reference path="../node_modules/typescript/lib/lib.es6.d.ts" />
/// <reference path="../node_modules/typescript/lib/lib.dom.iterable.d.ts" />
/// <reference path="../node_modules/typescript/lib/lib.scripthost.d.ts" />
var app = new App();
var containerElement = document.getElementById('app');
setPropertyDidChange(function () {
    app.scheduleRerender();
});
app.registerInitializer({
    initialize: function initialize(registry) {
        registry.register("component-manager:/" + app.rootName + "/component-managers/main", ComponentManager);
    }
});
app.renderComponent('EmbedPlayer', containerElement, null);
app.boot();

})));
